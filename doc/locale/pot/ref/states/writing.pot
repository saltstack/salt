# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013 SaltStack, Inc.
# This file is distributed under the same license as the Salt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-848-g77b77a3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-12 23:19+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/writing.rst:6
# a0c0a56f9a5042b6a1d57e3b1bd95c37
msgid "State Modules"
msgstr ""

#: ../../ref/states/writing.rst:8
# 3d1b863011f24b62bda464fa224dad7c
msgid "State Modules are the components that map to actual enforcement and management of Salt states."
msgstr ""

#: ../../ref/states/writing.rst:12
# 8adfd8e9612d4dfb8e7a50ef34546ecd
msgid "States are Easy to Write!"
msgstr ""

#: ../../ref/states/writing.rst:14
# 7f3e2ff862ea4dfea908e99e6b6c73a6
msgid "State Modules should be easy to write and straightforward. The information passed to the SLS data structures will map directly to the states modules."
msgstr ""

#: ../../ref/states/writing.rst:17
# eb343e053583448aaf479692771a2687
msgid "Mapping the information from the SLS data is simple, this example should illustrate:"
msgstr ""

#: ../../ref/states/writing.rst:30
# 766ab0399b854afe893f4ea05418dbd5
msgid "Therefore this SLS data can be directly linked to a module, function and arguments passed to that function."
msgstr ""

#: ../../ref/states/writing.rst:33
# 26515e6bfd0042e4a3cc8df771405641
msgid "This does issue the burden, that function names, state names and function arguments should be very human readable inside state modules, since they directly define the user interface."
msgstr ""

#: ../../ref/states/writing.rst:37
# de2bf68b97b04c4f8613e09bc0e3ef9d
msgid "Keyword Arguments"
msgstr ""

#: ../../ref/states/writing.rst:39
# a31b3b38fd9f4c27980cb9c49a806dd0
msgid "Salt passes a number of keyword arguments to states when rendering them, including the environment, a unique identifier for the state, and more. Additionally, keep in mind that the requisites for a state are part of the keyword arguments. Therefore, if you need to iterate through the keyword arguments in a state, these must be considered and handled appropriately. One such example is in the :mod:`pkgrepo.managed <salt.states.pkgrepo.managed>` state, which needs to be able to handle arbitrary keyword arguments and pass them to module execution functions. An example of how these keyword arguments can be handled can be found here_."
msgstr ""

#: ../../ref/states/writing.rst:54
# d172d201ca604d6e92ebbe08bd6571f2
msgid "Using Custom State Modules"
msgstr ""

#: ../../ref/states/writing.rst:56
# 651fc91ffd0b47a986d6c2deb4f88e8a
msgid "Place your custom state modules inside a ``_states`` directory within the :conf_master:`file_roots` specified by the master config file. These custom state modules can then be distributed in a number of ways. Custom state modules are distributed when :mod:`state.highstate <salt.modules.state.highstate>` is run, or by executing the :mod:`saltutil.sync_states <salt.modules.saltutil.sync_states>` or :mod:`saltutil.sync_all <salt.modules.saltutil.sync_all>` functions."
msgstr ""

#: ../../ref/states/writing.rst:64
# d886e8fcb7104031a9b55eacb629c12a
msgid "Any custom states which have been synced to a minion, that are named the same as one of Salt's default set of states, will take the place of the default state with the same name. Note that a state's default name is its filename (i.e. ``foo.py`` becomes state ``foo``), but that its name can be overridden by using a :ref:`__virtual__ function <virtual-modules>`."
msgstr ""

#: ../../ref/states/writing.rst:72
# 5750ecba970c4bfe9c17008a6fb911b2
msgid "Cross Calling Modules"
msgstr ""

#: ../../ref/states/writing.rst:74
# 238f8e1452744e49b47628d7358ee517
msgid "As with Execution Modules, State Modules can also make use of the ``__salt__`` and ``__grains__`` data."
msgstr ""

#: ../../ref/states/writing.rst:77
# 11a1eff89b634dd6a19eba9062f96a29
msgid "It is important to note that the real work of state management should not be done in the state module unless it is needed. A good example is the pkg state module. This module does not do any package management work, it just calls the pkg execution module. This makes the pkg state module completely generic, which is why there is only one pkg state module and many backend pkg execution modules."
msgstr ""

#: ../../ref/states/writing.rst:84
# e7ddb84e9e7d42dfb186fd969dd007bb
msgid "On the other hand some modules will require that the logic be placed in the state module, a good example of this is the file module. But in the vast majority of cases this is not the best approach, and writing specific execution modules to do the backend work will be the optimal solution."
msgstr ""

#: ../../ref/states/writing.rst:90
# 33776da5ae8c4c81b528d897a89d6a8f
msgid "Return Data"
msgstr ""

#: ../../ref/states/writing.rst:92
# 273ecb24ae24476a80cd3d9c4f756f15
msgid "A State Module must return a dict containing the following keys/values:"
msgstr ""

#: ../../ref/states/writing.rst:94
# c3a462d8633b49e6892330922d5b74f9
msgid "**name:** The same value passed to the state as \"name\"."
msgstr ""

#: ../../ref/states/writing.rst:95
# f4d653a36f85496cbf7eade3d9179175
msgid "**changes:** A dict describing the changes made. Each thing changed should be a key, with its value being another dict with keys called \"old\" and \"new\" containing the old/new values. For example, the pkg state's **changes** dict has one key for each package changed, with the \"old\" and \"new\" keys in its sub-dict containing the old and new versions of the package."
msgstr ""

#: ../../ref/states/writing.rst:100
# a88c94e55345430ea72406c4f2a108b3
msgid "**result:** A boolean value. *True* if the action was successful, otherwise *False*."
msgstr ""

#: ../../ref/states/writing.rst:102
# 8b84c367c1694c2389b5fae992818401
msgid "**comment:** A string containing a summary of the result."
msgstr ""

#: ../../ref/states/writing.rst:105
# 6ebb4e5991e144cb9d34ea0057173920
msgid "Test State"
msgstr ""

#: ../../ref/states/writing.rst:107
# ce92e755c07f4e0cbae7a70603a4106a
msgid "All states should check for and support ``test`` being passed in the options. This will return data about what changes would occur if the state were actually run. An example of such a check could look like this:"
msgstr ""

#: ../../ref/states/writing.rst:119
# b4c9a1580bb14ebe82c6752364a6ea98
msgid "Make sure to test and return before performing any real actions on the minion."
msgstr ""

#: ../../ref/states/writing.rst:122
# 1971fba8db5e4492b82aa02ade3f1df1
msgid "Watcher Function"
msgstr ""

#: ../../ref/states/writing.rst:124
# 45a508b221e84b65b9c022acb8b26968
msgid "If the state being written should support the watch requisite then a watcher function needs to be declared. The watcher function is called whenever the watch requisite is invoked and should be generic to the behavior of the state itself."
msgstr ""

#: ../../ref/states/writing.rst:129
# 3892cec4e84c4719b14d86d1322ac3a5
msgid "The watcher function should accept all of the options that the normal state functions accept (as they will be passed into the watcher function)."
msgstr ""

#: ../../ref/states/writing.rst:132
# c1dac6b685004e43ad217d359304062d
msgid "A watcher function typically is used to execute state specific reactive behavior, for instance, the watcher for the service module restarts the named service and makes it useful for the watcher to make the service react to changes in the environment."
msgstr ""

#: ../../ref/states/writing.rst:137
# db593654d1b7459389e0b40332dcef12
msgid "The watcher function also needs to return the same data that a normal state function returns."
msgstr ""

#: ../../ref/states/writing.rst:142
# 69944cc867774b2db2e677e26d90f823
msgid "Mod_init Interface"
msgstr ""

#: ../../ref/states/writing.rst:144
# 83e7cf75563a4d13a877b2d83518efc5
msgid "Some states need to execute something only once to ensure that an environment has been set up, or certain conditions global to the state behavior can be predefined. This is the realm of the mod_init interface."
msgstr ""

#: ../../ref/states/writing.rst:148
# 8180fb42b5c244398bb76ddca21cabfe
msgid "A state module can have a function called **mod_init** which executes when the first state of this type is called. This interface was created primarily to improve the pkg state. When packages are installed the package metadata needs to be refreshed, but refreshing the package metadata every time a package is installed is wasteful. The mod_init function for the pkg state sets a flag down so that the first, and only the first, package installation attempt will refresh the package database (the package database can of course be manually called to refresh via the ``refresh`` option in the pkg state)."
msgstr ""

#: ../../ref/states/writing.rst:157
# 9c5903fce432448fb64a66f07cf85e3d
msgid "The mod_init function must accept the **Low State Data** for the given executing state as an argument. The low state data is a dict and can be seen by executing the state.show_lowstate function. Then the mod_init function must return a bool. If the return value is True, then the mod_init function will not be executed again, meaning that the needed behavior has been set up. Otherwise, if the mod_init function returns False, then the function will be called the next time."
msgstr ""

#: ../../ref/states/writing.rst:165
# 15deb3f6c22a4d80a103cbae69167648
msgid "A good example of the mod_init function is found in the pkg state module:"
msgstr ""

#: ../../ref/states/writing.rst:181
# e985cbb76bbf456c9d1e83ac0176076f
msgid "The mod_init function in the pkg state accepts the low state data as ``low`` and then checks to see if the function being called is going to install packages, if the function is not going to install packages then there is no need to refresh the package database. Therefore if the package database is prepared to refresh, then return True and the mod_init will not be called the next time a pkg state is evaluated, otherwise return False and the mod_init will be called next time a pkg state is evaluated."
msgstr ""

