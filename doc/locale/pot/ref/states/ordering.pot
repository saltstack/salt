# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013 SaltStack, Inc.
# This file is distributed under the same license as the Salt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-848-g77b77a3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-12 23:19+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/ordering.rst:6
# b238e4bd5781449bb7346ab6f48cf1f3
msgid "Ordering States"
msgstr ""

#: ../../ref/states/ordering.rst:8
# 78f8c936571d45159649c69fe8e0fdb7
msgid "The way in which configuration management systems are executed is a hotly debated topic in the configuration management world. Two major philosophies exist on the subject, to either execute in an imperative fashion where things are executed in the order in which they are defined, or in a declarative fashion where dependencies need to be mapped between objects."
msgstr ""

#: ../../ref/states/ordering.rst:14
# 86e3c016309149baa07e7a5901bc6d7b
msgid "Imperative ordering is finite and generally considered easier to write, but declarative ordering is much more powerful and flexible but generally considered more difficult to create."
msgstr ""

#: ../../ref/states/ordering.rst:18
# d7d3b83a30cd4f959c6686797e51069d
msgid "Salt has been created to get the best of both worlds. States are evaluated in a finite order, which guarantees that states are always executed in the same order, and the states runtime is declarative, making Salt fully aware of dependencies via the requisite system."
msgstr ""

#: ../../ref/states/ordering.rst:24
# d2f8846c752a4847bef165a239ae2393
msgid "State Auto Ordering"
msgstr ""

#: ../../ref/states/ordering.rst:28
# b63fcdb3dbe44bee9de808348b873802
msgid "Salt always executes states in a finite manner, meaning that they will always execute in the same order regardless of the system that is executing them. But in Salt 0.17.0, the ``state_auto_order`` option was added. This option makes states get evaluated in the order in which they are defined in sls files."
msgstr ""

#: ../../ref/states/ordering.rst:34
# 2d87cd24608048b3a21c9126c260cc7d
msgid "The evaluation order makes it easy to know what order the states will be executed in, but it is important to note that the requisite system will override the ordering defined in the files, and the ``order`` option described below will also override the order in which states are defined in sls files."
msgstr ""

#: ../../ref/states/ordering.rst:39
# 4dc116da19e2414ca48913af620e6db5
msgid "If the classic ordering is preferred (lexicographic), then set ``state_auto_order`` to ``False`` in the master configuration file."
msgstr ""

#: ../../ref/states/ordering.rst:43
# 097055b296884fc5ab495c430707a37b
msgid "Requisite Statements"
msgstr ""

#: ../../ref/states/ordering.rst:47
# 21cb8556adc447c59d5328cc74cee0b4
msgid "This document represents behavior exhibited by Salt requisites as of version 0.9.7 of Salt."
msgstr ""

#: ../../ref/states/ordering.rst:50
# 0734c2d5f432483a9d710c678846332b
msgid "Often when setting up states any single action will require or depend on another action. Salt allows you to build relationships between states with requisite statements. A requisite statement ensure that the named state is evaluated before the state requiring it. There are two types of requisite statements in Salt, **require** and **watch**."
msgstr ""

#: ../../ref/states/ordering.rst:56
# 56de7a0b88f647c6aef21bd49c1fb492
msgid "These requisite statements are applied to a specific state declaration:"
msgstr ""

#: ../../ref/states/ordering.rst:69
# 7fa2a2c61e894f4da4d62dce576701e8
msgid "In this example we use the **require** requisite to declare that the file /etc/httpd/conf/httpd.conf should only be set up if the pkg state executes successfully."
msgstr ""

#: ../../ref/states/ordering.rst:73
# a497f5639e4a4133999944545a89c9ff
msgid "The requisite system works by finding the states that are required and executing them before the state that requires them. Then the required states can be evaluated to see if they have executed correctly."
msgstr ""

#: ../../ref/states/ordering.rst:77
# a8c3960229004612a8c510c7467ac236
msgid "Requisite matching"
msgstr ""

#: ../../ref/states/ordering.rst:79
# 33b07b01a58143369366f40197302ba9
msgid "Requisites match on both the ID Declaration and the ``name`` parameter. Therefore, if you are using the ``pkgs`` or ``sources`` argument to install a list of packages in a pkg state, it's important to note that you cannot have a requisite that matches on an individual package in the list."
msgstr ""

#: ../../ref/states/ordering.rst:86
# 8e4b01ba7be545e1b62db55e8452b3fa
msgid "Multiple Requisites"
msgstr ""

#: ../../ref/states/ordering.rst:88
# 30a90000b7394291b8ec048f28566b86
msgid "The requisite statement is passed as a list, allowing for the easy addition of more requisites. Both requisite types can also be separately declared:"
msgstr ""

#: ../../ref/states/ordering.rst:114
# aa2943a759e2472c98ad56ba8321d138
msgid "In this example the httpd service is only going to be started if the package, user, group and file are executed successfully."
msgstr ""

#: ../../ref/states/ordering.rst:118
# e72cd040262d482096beac8e46e1cb30
msgid "The Require Requisite"
msgstr ""

#: ../../ref/states/ordering.rst:120
# 5a3acb2691a6467cbeaf0640fb8e6363
msgid "The foundation of the requisite system is the ``require`` requisite. The require requisite ensures that the required state(s) are executed before the requiring state. So, if a state is declared that sets down a vimrc, then it would be pertinent to make sure that the vimrc file would only be set down if the vim package has been installed:"
msgstr ""

#: ../../ref/states/ordering.rst:136
# 849baf1f7cfb422c9a09b2f7ff139463
msgid "In this case, the vimrc file will only be applied by Salt if and after the vim package is installed."
msgstr ""

#: ../../ref/states/ordering.rst:140
# 7fdc5c6517bc4b1db118baa500621f66
msgid "The Watch Requisite"
msgstr ""

#: ../../ref/states/ordering.rst:142
# 1c571d4246c944a3a1c85ee6270594e3
msgid "The ``watch`` requisite is more advanced than the ``require`` requisite. The watch requisite executes the same logic as require (therefore if something is watched it does not need to also be required) with the addition of executing logic if the required states have changed in some way."
msgstr ""

#: ../../ref/states/ordering.rst:147
# fdfedbb8d39f4db68c0ec8528928739d
msgid "The watch requisite checks to see if the watched states have returned any changes. If the watched state returns changes, and the watched states execute successfully, then the watching state will execute a function that reacts to the changes in the watched states."
msgstr ""

#: ../../ref/states/ordering.rst:152
# 64441d5acd424a7099fb56b5126a0e6b
msgid "Perhaps an example can better explain the behavior:"
msgstr ""

#: ../../ref/states/ordering.rst:170
# 606e1b2a71234c22b12f669c1ee5691c
msgid "In this example the redis service will only be started if the file /etc/redis.conf is applied, and the file is only applied if the package is installed. This is normal require behavior, but if the watched file changes, or the watched package is installed or upgraded, then the redis service is restarted."
msgstr ""

#: ../../ref/states/ordering.rst:177
# fe0dbcd9c8aa49cca4fabd287927b893
msgid "Watch and the mod_watch Function"
msgstr ""

#: ../../ref/states/ordering.rst:179
# 375fabc9697c48fd97bed8796d9eb9dc
msgid "The watch requisite is based on the ``mod_watch`` function. Python state modules can include a function called ``mod_watch`` which is then called if the watch call is invoked. When ``mod_watch`` is called depends on the execution of the watched state, which:"
msgstr ""

#: ../../ref/states/ordering.rst:184
# 463c0fe2ac2e4342bc6a461dec5117f7
msgid "If no changes then just run the watching state itself as usual. ``mod_watch`` is not called. This behavior is same as using a ``require``."
msgstr ""

#: ../../ref/states/ordering.rst:187
# 299a8b412e7f42029aa3b360799f4ec9
msgid "If changes then run the watching state *AND* if that changes nothing then react by calling ``mod_watch``."
msgstr ""

#: ../../ref/states/ordering.rst:190
# 11fc8bf35b20497787c8ff546c2826ce
msgid "When reacting, in the case of the service module the underlying service is restarted. In the case of the cmd state the command is executed."
msgstr ""

#: ../../ref/states/ordering.rst:193
# 995cc39e0b29486d8314347557e8532d
msgid "The ``mod_watch`` function for the service state looks like this:"
msgstr ""

#: ../../ref/states/ordering.rst:225
# 652abfa4163649199e1ec968c4487c85
msgid "The watch requisite only works if the state that is watching has a ``mod_watch`` function written. If watch is set on a state that does not have a ``mod_watch`` function (like pkg), then the listed states will behave only as if they were under a ``require`` statement."
msgstr ""

#: ../../ref/states/ordering.rst:230
# 692835d9de104df5bba93960d3fa1cc3
msgid "Also notice that a ``mod_watch`` may accept additional keyword arguments, which, in the sls file, will be taken from the same set of arguments specified for the state that includes the ``watch`` requisite. This means, for the earlier ``service.running`` example above,  you can tell the service to ``reload`` instead of restart like this:"
msgstr ""

#: ../../ref/states/ordering.rst:251
# fdaa8b997f924e41bcb4500677bab6cc
msgid "The Order Option"
msgstr ""

#: ../../ref/states/ordering.rst:253
# 40ba427c9e0743a5bfd23cb9ed9fbe47
msgid "Before using the order option, remember that the majority of state ordering should be done with a :term:`requisite declaration`, and that a requisite declaration will override an order option."
msgstr ""

#: ../../ref/states/ordering.rst:257
# eca908a5c54a45ce89effe54e0bbed0d
msgid "The order option is used by adding an order number to a state declaration with the option `order`:"
msgstr ""

#: ../../ref/states/ordering.rst:266
# f79833b16dbd4e73abde778f45308d81
msgid "By adding the order option to `1` this ensures that the vim package will be installed in tandem with any other state declaration set to the order `1`."
msgstr ""

#: ../../ref/states/ordering.rst:269
# 5af3047991e047c1be39bd858f054825
msgid "Any state declared without an order option will be executed after all states with order options are executed."
msgstr ""

#: ../../ref/states/ordering.rst:272
# e64e2d84a33f4d9c88747e3d24a8f151
msgid "But this construct can only handle ordering states from the beginning. Sometimes you may want to send a state to the end of the line. To do this, set the order to ``last``:"
msgstr ""

#: ../../ref/states/ordering.rst:282
# 2c5139e730a84ea3b3437edc3e40755c
msgid "Remember that requisite statements override the order option. So the order option should be applied to the highest component of the requisite chain:"
msgstr ""

