# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013 SaltStack, Inc.
# This file is distributed under the same license as the Salt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-848-g77b77a3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-12 23:19+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/layers.rst:6
# 936e18e8d087461fb74c7ec64ef51f0a
msgid "State System Layers"
msgstr ""

#: ../../ref/states/layers.rst:8
# ad8e1e9c79cb4bf08d3a83a547778aef
msgid "The Salt state system is comprised of multiple layers. While using Salt does not require an understanding of the state layers, a deeper understanding of how Salt compiles and manages states can be very beneficial."
msgstr ""

#: ../../ref/states/layers.rst:13
# fea652e830ad45a6a9ed383a30424ee2
msgid "Function Call"
msgstr ""

#: ../../ref/states/layers.rst:15
# 990b058cf3b34caca51e82c5e108a508
msgid "The lowest layer of functionality in the state system is the direct state function call. State executions are executions of single state functions at the core. These individual functions are defined in state modules and can be called directly via the ``state.single`` command."
msgstr ""

#: ../../ref/states/layers.rst:25
# 22996b59d7c644069f96e0cd2d6dd9c8
msgid "Low Chunk"
msgstr ""

#: ../../ref/states/layers.rst:27
# cadc4ae9070f43e8beb493f8831e6841
msgid "The low chunk is the bottom of the Salt state compiler. This is a data representation of a single function call. The low chunk is sent to the state caller and used to execute a single state function."
msgstr ""

#: ../../ref/states/layers.rst:31
# 9636f30b933b4298a00034910693d2dd
msgid "A single low chunk can be executed manually via the ``state.low`` command."
msgstr ""

#: ../../ref/states/layers.rst:37
# 4acd3b24155848fb92c790ae84e6476c
msgid "The passed data reflects what the state execution system gets after compiling the data down from sls formulas."
msgstr ""

#: ../../ref/states/layers.rst:41
# e2b4f2e38cb74fa7aecafea76da14881
msgid "Low State"
msgstr ""

#: ../../ref/states/layers.rst:43
# 6e00a2506977482d89f39888f57fb84c
msgid "The `Low State` layer is the list of low chunks \"evaluated\" in order. To see what the low state looks like for a highstate, run:"
msgstr ""

#: ../../ref/states/layers.rst:50
# 417d2d6f16d94e82a27ffd058f19a2cc
msgid "This will display the raw lowstate in the order which each low chunk will be evaluated. The order of evaluation is not necessarily the order of execution, since requisites are evaluated at runtime. Requisite execution and evaluation is finite; this means that the order of execution can be ascertained with 100% certainty based on the order of the low state."
msgstr ""

#: ../../ref/states/layers.rst:57
# cbaa14800ca5456f9d2aa645635f7e96
msgid "High Data"
msgstr ""

#: ../../ref/states/layers.rst:59
# 3bbca0f67a684663af9ca12d0213ded2
msgid "High data is the data structure represented in YAML via SLS files. The High data structure is created by merging the data components rendered inside sls files (or other render systems). The High data can be easily viewed by executing the ``state.show_highstate`` or ``state.show_sls`` functions. Since this data is a somewhat complex data structure, it may be easier to read using the json, yaml, or pprint outputters:"
msgstr ""

#: ../../ref/states/layers.rst:72
# b6204a6065014010bdec83865423bc17
msgid "SLS"
msgstr ""

#: ../../ref/states/layers.rst:74
# 6acce4b966ac4190b45056b9394ec251
msgid "Above \"High Data\", the logical layers are no longer technically required to be executed, or to be executed in a hierarchy. This means that how the High data is generated is optional and very flexible. The SLS layer allows for many mechanisms to be used to render sls data from files or to use the fileserver backend to generate sls and file data from external systems."
msgstr ""

#: ../../ref/states/layers.rst:80
# f221f7f5e6724cc3aa0fd99a230e521c
msgid "The SLS layer can be called directly to execute individual sls formulas."
msgstr ""

#: ../../ref/states/layers.rst:84
# ec82de113746403a8077d6ed80c30b0c
msgid "SLS Formulas have historically been called \"SLS files\". This is because a single SLS was only constituted in a single file. Now the term \"SLS Formula\" better expresses how a compartmentalized SLS can be expressed in a much more dynamic way by combining pillar and other sources, and the SLS can be dynamically generated."
msgstr ""

#: ../../ref/states/layers.rst:90
# ea086d71c46b4f129f233aae3297becd
msgid "To call a single SLS formula named ``edit.vim``, execute ``state.sls``:"
msgstr ""

#: ../../ref/states/layers.rst:97
# 93f225267a8449af9a340a51e03c09ce
msgid "HighState"
msgstr ""

#: ../../ref/states/layers.rst:99
# b6299d46144b4074b0f95cae91c31147
msgid "Calling SLS directly logically assigns what states should be executed from the context of the calling minion. The Highstate layer is used to allow for full contextual assignment of what is executed where to be tied to groups of, or individual, minions entirely from the master. This means that the environment of a minion, and all associated execution data pertinent to said minion, can be assigned from the master without needing to execute or configure anything on the target minion. This also means that the minion can independently retrieve information about its complete configuration from the master."
msgstr ""

#: ../../ref/states/layers.rst:108
# a557f23aa7de47eb8800ba91612f8c0c
msgid "To execute the High State call ``state.highstate``:"
msgstr ""

#: ../../ref/states/layers.rst:115
# 297664e1faa2457ba19ad1d585013dc1
msgid "OverState"
msgstr ""

#: ../../ref/states/layers.rst:117
# 87f6e93bbc214d5a899e8dbd4af333db
msgid "The overstate layer expresses the highest functional layer of Salt's automated logic systems. The Overstate allows for stateful and functional orchestration of routines from the master. The overstate defines in data execution stages which minions should execute states, or functions, and in what order using requisite logic."
msgstr ""

