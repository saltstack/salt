# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013 SaltStack, Inc.
# This file is distributed under the same license as the Salt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-848-g77b77a3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-12 23:19+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/requisites.rst:6
# 7514a0910fce42e5b9b3cdb24f924efc
msgid "Requisites"
msgstr ""

#: ../../ref/states/requisites.rst:8
# 7898d1ea7e244f108bbdeb7028a0e8cf
msgid "The Salt requisite system is used to create relationships between states. The core idea being that, when one state is dependent somehow on another, that inter-dependency can be easily defined."
msgstr ""

#: ../../ref/states/requisites.rst:12
# df50d69c9e7a4d3dac1cc0343c763859
msgid "Requisites come in two types. Direct requisites, and requisite_ins. The relationships are directional, so a requisite statement makes the requiring state declaration depend on the required state declaration:"
msgstr ""

#: ../../ref/states/requisites.rst:27
# dcabef9501ea4ca4bdeaa2be68433bf3
msgid "So in this example, the file ``/etc/vimrc`` depends on the vim package."
msgstr ""

#: ../../ref/states/requisites.rst:29
# 19639d81dc554098862c2338aac37b0c
msgid "Requisite_in statements are the opposite, instead of saying \"I depend on something\", requisite_ins say \"Someone depends on me\":"
msgstr ""

#: ../../ref/states/requisites.rst:43
# 40c3a373e46949d181d71d0cd1cff2d4
msgid "So here, with a requisite_in, the same thing is accomplished, but just from the other way around. The vim package is saying \"/etc/vimrc depends on me\"."
msgstr ""

#: ../../ref/states/requisites.rst:46
# 2dad340b2b5e473cb6c1bb493421ed9b
msgid "In the end, a single dependency map is created and everything is executed in a finite and predictable order."
msgstr ""

#: ../../ref/states/requisites.rst:49
# 09dda3db07db44478e4a74f707800b90
msgid "Requisite matching"
msgstr ""

#: ../../ref/states/requisites.rst:51
# ca0ac76f4b3c415b8cdbb0930adc1af9
msgid "Requisites match on both the ID Declaration and the ``name`` parameter. This means that, in the example above, the ``require_in`` requisite would also have been matched if the ``/etc/vimrc`` state was written as follows:"
msgstr ""

#: ../../ref/states/requisites.rst:64
# bedf00526009428588bd61fe9d8f92eb
msgid "Requisite and Requisite in types"
msgstr ""

#: ../../ref/states/requisites.rst:66
# f7aa9896791f4529bf7af422d7b85d55
msgid "There are three requisite statements that can be used in Salt. the ``require``, ``watch`` and ``use`` requisites. Each requisite also has a corresponding requisite_in: ``require_in``, ``watch_in`` and ``use_in``. All of the requisites define specific relationships and always work with the dependency logic defined above."
msgstr ""

#: ../../ref/states/requisites.rst:73
# e77e42d2b0db4a3a8a2cf997804d297d
msgid "Require"
msgstr ""

#: ../../ref/states/requisites.rst:75
# 2b49c3f572d849ca8ad58de5379d8033
msgid "The most basic requisite statement is ``require``. The behavior of require is simple. Make sure that the dependent state is executed before the depending state, and if the dependent state fails, don't run the depending state. So in the above examples the file ``/etc/vimrc`` will only be applied after the vim package is installed and only if the vim package is installed successfully."
msgstr ""

#: ../../ref/states/requisites.rst:82
# 3568ad411a6f458595f13b2b495143e0
msgid "Require an entire sls file"
msgstr ""

#: ../../ref/states/requisites.rst:84
# b61014ee08e3413fab3503f3b506b4a4
msgid "As of Salt 0.16.0, it is possible to require an entire sls file. Do this by first including the sls file and then setting a state to ``require`` the included sls file."
msgstr ""

#: ../../ref/states/requisites.rst:98
# c8590da76ffa49b7bdbc6725c56e6f32
msgid "Watch"
msgstr ""

#: ../../ref/states/requisites.rst:100
# b6172701404b4838bb9e647bac2f3276
msgid "The watch statement does everything the require statement does, but with a little more. The watch statement looks into the state modules for a function called ``mod_watch``. If this function is not available in the corresponding state module, then watch does the same thing as require. If the ``mod_watch`` function is in the state module, then the watched state is checked to see if it made any changes to the system, if it has, then ``mod_watch`` is called."
msgstr ""

#: ../../ref/states/requisites.rst:107
# 9daf7d007765498ca2264e81407c1469
msgid "Perhaps the best example of using watch is with a :mod:`service.running <salt.states.service.running>` state. When a service watches a state, then the service is reloaded/restarted when the watched state changes::"
msgstr ""

#: ../../ref/states/requisites.rst:120
# daa9c9c02b6c433e86b9074501fcc598
msgid "Prereq"
msgstr ""

#: ../../ref/states/requisites.rst:122
# b14b7ba0674a477ebe5d18d13cbc88e9
msgid "The ``prereq`` requisite is a powerful requisite added in 0.16.0. This requisite allows for actions to be taken based on the expected results of a state that has not yet been executed. In more practical terms, a service can be shut down because the ``prereq`` knows that underlying code is going to be updated and the service should be off-line while the update occurs."
msgstr ""

#: ../../ref/states/requisites.rst:128
# 06bf70dc561e440a81d13fa0a355607e
msgid "The motivation to add this requisite was to allow for routines to remove a system from a load balancer while code is being updated."
msgstr ""

#: ../../ref/states/requisites.rst:131
# fe2185b7d32e48be9a692e1f7dc1aa21
msgid "The ``prereq`` checks if the required state expects to have any changes by running the single state with ``test=True``. If the pre-required state returns changes, then the state requiring it will execute."
msgstr ""

#: ../../ref/states/requisites.rst:148
# 8c32ac37d72641af91b8aa8e5668d42e
msgid "In this case the apache server will only be shutdown if the site-code state expects to deploy fresh code via the file.recurse call, and the site-code deployment will only be executed if the graceful-down run completes successfully."
msgstr ""

#: ../../ref/states/requisites.rst:154
# a63f38448d20410c94cfe1ed6bb0cd79
msgid "Use"
msgstr ""

#: ../../ref/states/requisites.rst:156
# 87eea9aac890403e83a05dd622a4a975
msgid "The ``use`` requisite is used to inherit the arguments passed in another id declaration. This is useful when many files need to have the same defaults."
msgstr ""

#: ../../ref/states/requisites.rst:176
# 0610906e9c004ea9a35372e0316f80a1
msgid "The ``use`` statement was developed primarily for the networking states but can be used on any states in Salt. This made sense for the networking state because it can define a long list of options that need to be applied to multiple network interfaces."
msgstr ""

#: ../../ref/states/requisites.rst:184
# e27e4bc83c344d7f9004e4885aed5fb0
msgid "Require In"
msgstr ""

#: ../../ref/states/requisites.rst:186
# 31b7879b2ffb4abb927c9423bbf44c74
msgid "The ``require_in`` requisite is the literal reverse of ``require``. If a state declaration needs to be required by another state declaration then require_in can accommodate it, so these two sls files would be the same in the end:"
msgstr ""

#: ../../ref/states/requisites.rst:191
# 56550b289a2f4fccb13c447c57ca2e71
msgid "Using ``require``"
msgstr ""

#: ../../ref/states/requisites.rst:203
# bf40073da5a74025b3591b878b315c52
msgid "Using ``require_in``"
msgstr ""

#: ../../ref/states/requisites.rst:215
# 1dce6210a8724d319ba5243f6699233c
msgid "The ``require_in`` statement is particularly useful when assigning a require in a separate sls file. For instance it may be common for httpd to require components used to set up PHP or mod_python, but the HTTP state does not need to be aware of the additional components that require it when it is set up:"
msgstr ""

#: ../../ref/states/requisites.rst:220
# 2acc2e86eb604255905ab7e508720c34
msgid "http.sls"
msgstr ""

#: ../../ref/states/requisites.rst:232
# 576486505ea041de8a3408da231ca891
msgid "php.sls"
msgstr ""

#: ../../ref/states/requisites.rst:245
# 6ee56bda0ad0431e9be0f4a6c0fea4b5
msgid "mod_python.sls"
msgstr ""

#: ../../ref/states/requisites.rst:258
# edd47834e57f43c6892affbc9e4f4da2
msgid "Now the httpd server will only start if php or mod_python are first verified to be installed. Thus allowing for a requisite to be defined \"after the fact\"."
msgstr ""

#: ../../ref/states/requisites.rst:264
# 442700cad593425ea4cd6c0af4781f05
msgid "Watch In"
msgstr ""

#: ../../ref/states/requisites.rst:266
# 74f76c948d0e463284d07cce180c1323
msgid "Watch in functions the same as require in, but applies a watch statement rather than a require statement to the external state declaration."
msgstr ""

#: ../../ref/states/requisites.rst:270
# 3ec3c190b6a745558be0c57b9c5eecf5
msgid "Prereq In"
msgstr ""

#: ../../ref/states/requisites.rst:272
# c8f9c1a92b6f4aedbe3858eb965d6ca0
msgid "The ``prereq_in`` requisite in follows the same assignment logic as the ``require_in`` requisite in. The ``prereq_in`` call simply assigns ``prereq`` to the state referenced. The above example for ``prereq`` can be modified to function in the same way using ``prereq_in``:"
msgstr ""

