# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013 SaltStack, Inc.
# This file is distributed under the same license as the Salt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-848-g77b77a3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-12 23:19+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../topics/tutorials/starting_states.rst:6
# aecc3ed8b15f4f15a27b7961f397c52e
msgid "How Do I Use Salt States?"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:8
# 47948ac847834068acfda275c3796502
msgid "Simplicity, Simplicity, Simplicity"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:10
# 7d0d16b0cd7b419c816f45146c736ed3
msgid "Many of the most powerful and useful engineering solutions are founded on simple principles. Salt States strive to do just that: K.I.S.S. (Keep It Stupidly Simple)"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:14
# 347ce5d1a40948dbb46b1a624b635193
msgid "The core of the Salt State system is the SLS, or **S**\\ a\\ **L**\\ t **S**\\ tate file. The SLS is a representation of the state in which a system should be in, and is set up to contain this data in a simple format. This is often called configuration management."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:21
# 504d9efc02634022bc6dc6ad36c45f67
msgid "This is just the beginning of using states, make sure to read up on pillar :doc:`Pillar </topics/tutorials/pillar>` next."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:26
# da65672160f541819e63fa369d811872
msgid "It is All Just Data"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:28
# 77bfa4673af04bf98558ebabfe4d15be
msgid "Before delving into the particulars, it will help to understand that the SLS file is just a data structure under the hood. While understanding that the SLS is just a data structure isn't critical for understanding and making use of Salt States, it should help bolster knowledge of where the real power is."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:33
# 0958f97f0e204b4781eec8f132d04b7b
msgid "SLS files are therefore, in reality, just :ref:`dictionaries <python2:typesmapping>`, :ref:`lists <python2:typesseq>`, :ref:`strings <python2:typesseq>`, and :ref:`numbers <python2:typesnumeric>`. By using this approach Salt can be much more flexible. As one writes more state files, it becomes clearer exactly what is being written. The result is a system that is easy to understand, yet grows with the needs of the admin or developer."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:42
# cceb16cc3e9b4ffeb11418e2eae4d321
msgid "The Top File"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:44
# d4982f7f73804998b6af73247e09eb69
msgid "The example SLS files in the below sections can be assigned to hosts using a file called :strong:`top.sls`. This file is described in-depth :doc:`here </ref/states/top>`."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:50
# b1fb8b682d814e739e30ee33a89056d4
msgid "Default Data - YAML"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:52
# ed4c58bee4bd4625ab8dc32c90fa2b08
msgid "By default Salt represents the SLS data in what is one of the simplest serialization formats available - `YAML`_."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:55
# d1b224b5e65d41f88a91f03edfcdbfc3
msgid "A typical SLS file will often look like this in YAML:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:59
# 7f9a94dd942a4a6982409577c201ace8
msgid "These demos use some generic service and package names, different distributions often use different names for packages and services. For instance `apache` should be replaced with `httpd` on a Red Hat system. Salt uses the name of the init script, systemd name, upstart name etc. based on what the underlying service management for the platform. To get a list of the available service names on a platform execute the service.get_all salt function."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:67
# 736f39db4f1a42e09accde5650ae5225
msgid "Information on how to make states work with multiple distributions is later in the tutorial."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:80
# 9dd2516f0b394483ab8ac231177b0a83
msgid "This SLS data will ensure that the package named apache is installed, and that the apache service is running. The components can be explained in a simple way."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:84
# 324d7050ed844faa936487edd8715704
msgid "The first line is the ID for a set of data, and it is called the ID Declaration. This ID sets the name of the thing that needs to be manipulated."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:87
# b8cfdd9936a446e4b86ba46318e5af05
msgid "The second and fourth lines are the start of the State Declarations, so they are using the pkg and service states respectively. The pkg state manages a software package to be installed via the system's native package manager, and the service state manages a system daemon."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:92
# 3a8c46d3551347538c7ab41160ab02f6
msgid "The third and fifth lines are the function to run. This function defines what state the named package and service should be in. Here, the package is to be installed, and the service should be running."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:96
# 4c09720eb4bd4459b7f85aa149d6c4e9
msgid "Finally, on line six, is the word ``require``. This is called a Requisite Statement, and it makes sure that the Apache service is only started after a successful installation of the apache package."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:104
# 2234f5a0250840e598ca1b39a4c857e3
msgid "Adding Configs and Users"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:106
# ff91d7f65abd4624ba1f1dc526974d1b
msgid "When setting up a service like an Apache web server, many more components may need to be added. The Apache configuration file will most likely be managed, and a user and group may need to be set up."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:140
# 379e66b4039e4ac4be3a5fa638bec211
msgid "This SLS data greatly extends the first example, and includes a config file, a user, a group and new requisite statement: ``watch``."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:143
# 3758bf646d144de2885a19afecf771a4
msgid "Adding more states is easy, since the new user and group states are under the Apache ID, the user and group will be the Apache user and group. The ``require`` statements will make sure that the user will only be made after the group, and that the group will be made only after the Apache package is installed."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:149
# 23177d7e47f64d77bbe6b46f15bd7682
msgid "Next,the ``require`` statement under service was changed to watch, and is now watching 3 states instead of just one. The watch statement does the same thing as require, making sure that the other states run before running the state with a watch, but it adds an extra component. The ``watch`` statement will run the state's watcher function for any changes to the watched states. So if the package was updated, the config file changed, or the user uid modified, then the service state's watcher will be run. The service state's watcher just restarts the service, so in this case, a change in the config file will also trigger a restart of the respective service."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:161
# c8a7c8361f134fff992029eb237ed7b9
msgid "Moving Beyond a Single SLS"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:163
# b940a347cd9549b088749fa91d2d8eca
msgid "When setting up Salt States in a scalable manner, more than one SLS will need to be used. The above examples were in a single SLS file, but two or more SLS files can be combined to build out a State Tree. The above example also references a file with a strange source - ``salt://apache/httpd.conf``. That file will need to be available as well."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:169
# 8183f87bdd0f4905b6f905cbb109a998
msgid "The SLS files are laid out in a directory structure on the Salt master; an SLS is just a file and files to download are just files."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:172
# 4d21d81c608d410091bad45d753fcd0c
msgid "The Apache example would be laid out in the root of the Salt file server like this::"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:178
# a82884feb5d146b18fe69da818e971ce
msgid "So the httpd.conf is just a file in the apache directory, and is referenced directly."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:181
# 338d78a66ddb401288c0b3f8876bf98f
msgid "But when using more than one single SLS file, more components can be added to the toolkit. Consider this SSH example:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:184
# 4272c5dcd4914b6ba220140aded5e3ac
msgid "``ssh/init.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:200
# a8126d1c5b6b4752b9646319e5a66195
msgid "``ssh/server.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:239
# a40decb73f5f4519a0c07ac4dfc49408
msgid "Notice that we use two similar ways of denoting that a file is managed by Salt. In the `/etc/ssh/sshd_config` state section above, we use the `file.managed` state declaration whereas with the `/etc/ssh/banner` state section, we use the `file` state declaration and add a `managed` attribute to that state declaration. Both ways produce an identical result; the first way -- using `file.managed` -- is merely a shortcut."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:247
# 4caf9fc94d4040ca9264381323fd63de
msgid "Now our State Tree looks like this::"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:257
# 409e9bab02cb474da0d981f07cb2f8d2
msgid "This example now introduces the ``include`` statement. The include statement includes another SLS file so that components found in it can be required, watched or as will soon be demonstrated - extended."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:261
# a85c031606934463a8d69f5fc8ec49d7
msgid "The include statement allows for states to be cross linked. When an SLS has an include statement it is literally extended to include the contents of the included SLS files."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:265
# 9e5cf513fee4459ba3f2b2614b028b17
msgid "Note that some of the SLS files are called init.sls, while others are not. More info on what this means can be found in the :ref:`States Tutorial <sls-file-namespace>`."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:271
# 9ae028524af74309ba3c3d41faba46bb
msgid "Extending Included SLS Data"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:273
# d162e35f48554c37970df01c8fece0f5
msgid "Sometimes SLS data needs to be extended. Perhaps the apache service needs to watch additional resources, or under certain circumstances a different file needs to be placed."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:277
# 6de99091097b4ca99e1021acb2b80dc2
msgid "In these examples, the first will add a custom banner to ssh and the second will add more watchers to apache to include mod_python."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:280
# d5ed6581592044c2a728e8b0b5cecc08
msgid "``ssh/custom-server.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:292
# fadf3840b08945a6b39d8c1dcd2c3d03
msgid "``python/mod_python.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:308
# 860ea3f142104ab984c7dfc4c1cfa006
msgid "The ``custom-server.sls`` file uses the extend statement to overwrite where the banner is being downloaded from, and therefore changing what file is being used to configure the banner."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:312
# 30727221844a4c1293c05f796ee2275c
msgid "In the new mod_python SLS the mod_python package is added, but more importantly the apache service was extended to also watch the mod_python package."
msgstr ""

#: ../../_incl/extend_with_require_watch.rst:1
# a5ab786589f44b898dd536e5ef258054
msgid "Using extend with require or watch"
msgstr ""

#: ../../_incl/extend_with_require_watch.rst:3
# cc5c4f5c6a3d46b0bca96e1955c00809
msgid "The ``extend`` statement works differently for ``require`` or ``watch``. It appends to, rather than replacing the requisite component."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:319
# 893abb86cf3046298fe57b0cba539970
msgid "Understanding the Render System"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:321
# 8a91f79a2baf4c96ab7b71895bba8b0b
msgid "Since SLS data is simply that (data), it does not need to be represented with YAML. Salt defaults to YAML because it is very straightforward and easy to learn and use. But the SLS files can be rendered from almost any imaginable medium, so long as a renderer module is provided."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:326
# 8bf260081cb747948ad1493e2f394d0d
msgid "The default rendering system is the ``yaml_jinja`` renderer. The ``yaml_jinja`` renderer will first pass the template through the `Jinja2`_ templating system, and then through the YAML parser. The benefit here is that full programming constructs are available when creating SLS files."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:331
# a3673102d7924f3e9166ad0242ff8ef1
msgid "Other renderers available are ``yaml_mako`` and ``yaml_wempy`` which each use the `Mako`_ or `Wempy`_ templating system respectively rather than the jinja templating system, and more notably, the pure Python or ``py`` and ``pydsl`` renderers. The ``py`` renderer allows for SLS files to be written in pure Python, allowing for the utmost level of flexibility and power when preparing SLS data; while the :doc:`pydsl</ref/renderers/all/salt.renderers.pydsl>` renderer provides a flexible, domain-specific language for authoring SLS data in Python."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:345
# e806a5d377064ed09a6fddf65ae34f38
msgid "The templating engines described above aren't just available in SLS files. They can also be used in :mod:`file.managed <salt.states.file.managed>` states, making file management much more dynamic and flexible. Some examples for using templates in managed files can be found in the documentation for the :doc:`file states </ref/states/all/salt.states.file>`, as well as the :ref:`MooseFS example<jinja-example-moosefs>` below."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:355
# d8f9db7e44aa46cbadb58003d3157365
msgid "Getting to Know the Default - yaml_jinja"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:357
# df252e93d6714980a18b2e2c078118a7
msgid "The default renderer - ``yaml_jinja``, allows for use of the jinja templating system. A guide to the Jinja templating system can be found here: http://jinja.pocoo.org/docs"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:361
# 9f1d56e526404f4fb99e1a9421fc9683
msgid "When working with renderers a few very useful bits of data are passed in. In the case of templating engine based renderers, three critical components are available, ``salt``, ``grains``, and ``pillar``. The ``salt`` object allows for any Salt function to be called from within the template, and ``grains`` allows for the Grains to be accessed from within the template. A few examples:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:367
# b3bb876e32034b04b92a69dc8e966f3f
msgid "``apache/init.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:403
# 8c7d5f6fa861474ab28076e0e5e116f4
msgid "This example is simple. If the ``os`` grain states that the operating system is Red Hat, then the name of the Apache package and service needs to be httpd."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:408
# 3a037d1e0a784d2598a86fc90f589771
msgid "A more aggressive way to use Jinja can be found here, in a module to set up a MooseFS distributed filesystem chunkserver:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:411
# 941081b6ff5941568508b835694257e7
msgid "``moosefs/chunk.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:467
# 163a953ba60145c2ab9231341c3a6d0f
msgid "This example shows much more of the available power of Jinja. Multiple for loops are used to dynamically detect available hard drives and set them up to be mounted, and the ``salt`` object is used multiple times to call shell commands to gather data."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:474
# b9b20d95e8594a6c84c9d85332077b74
msgid "Introducing the Python and the PyDSL Renderers"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:476
# efcf11d0d7ab4e539c3c1ef28ad1f59a
msgid "Sometimes the chosen default renderer might not have enough logical power to accomplish the needed task. When this happens, the Python renderer can be used. Normally a YAML renderer should be used for the majority of SLS files, but an SLS file set to use another renderer can be easily added to the tree."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:481
# b07f28ec8b8d4412bfd4a8a289f66a90
msgid "This example shows a very basic Python SLS file:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:483
#: ../../topics/tutorials/starting_states.rst:505
# f65423e722f54c51a86f224c7c145ed1
# 9a8b061a3e094676a240bef900146471
msgid "``python/django.sls:``"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:496
# 74fea2576c0c44cd932a5d95c1b0eee9
msgid "This is a very simple example; the first line has an SLS shebang that tells Salt to not use the default renderer, but to use the ``py`` renderer. Then the run function is defined, the return value from the run function must be a Salt friendly data structure, or better known as a Salt :doc:`HighState data structure</ref/states/highstate>`."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:502
# 95ebea90890c4cd28ae7396e8e0fbc8d
msgid "Alternatively, using the :doc:`pydsl</ref/renderers/all/salt.renderers.pydsl>` renderer, the above example can be written more succinctly as:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:515
# bbe7434fe71541f1b9a1b44043388b99
msgid "This Python examples would look like this if they were written in YAML:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:525
# 8b4cf3c87c124b59843747f6946acc6d
msgid "This example clearly illustrates that; one, using the YAML renderer by default is a wise decision and two, unbridled power can be obtained where needed by using a pure Python SLS."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:530
# 0e9d7953d9144a0fab94f0f4da1d4b86
msgid "Running and debugging salt states."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:532
# 8931280bcffb46b7b0e312756669f606
msgid "Once the rules in an SLS are ready, they should be tested to ensure they work properly. To invoke these rules, simply execute ``salt '*' state.highstate`` on the command line. If you get back only hostnames with a ``:`` after, but no return, chances are there is a problem with one or more of the sls files. On the minion, use the ``salt-call`` command: ``salt-call state.highstate -l debug`` to examine the output for errors. This should help troubleshoot the issue. The minions can also be started in the foreground in debug mode: ``salt-minion -l debug``."
msgstr ""

#: ../../topics/tutorials/starting_states.rst:542
# 55cfe19f4d804729b195255e5b5d7519
msgid "Next Reading"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:544
# 711916388a4b4dae8c02d94304693c7b
msgid "With an understanding of states, the next recommendation is to become familiar with Salt's pillar interface:"
msgstr ""

#: ../../topics/tutorials/starting_states.rst:547
# 6268733647f2457da5f40cb0eaedd54b
msgid ":doc:`Pillar Walkthrough </topics/tutorials/pillar>`"
msgstr ""

