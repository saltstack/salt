# 
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-799-g9ccf089\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-11 21:20\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/layers.rst:6
msgid "State System Layers"
msgstr ""

#: ../../ref/states/layers.rst:8
msgid ""
"The Salt state system is comprised of multiple layers. While using Salt does"
" not require an understanding of the state layers, a deeper understanding of"
" how Salt compiles and manages states can be very beneficial."
msgstr ""

#: ../../ref/states/layers.rst:13
msgid "Function Call"
msgstr ""

#: ../../ref/states/layers.rst:15
msgid ""
"The lowest layer of functionality in the state system is the direct state "
"function call. State executions are executions of single state functions at "
"the core. These individual functions are defined in state modules and can be"
" called directly via the ``state.single`` command."
msgstr ""

#: ../../ref/states/layers.rst:25
msgid "Low Chunk"
msgstr ""

#: ../../ref/states/layers.rst:27
msgid ""
"The low chunk is the bottom of the Salt state compiler. This is a data "
"representation of a single function call. The low chunk is sent to the state"
" caller and used to execute a single state function."
msgstr ""

#: ../../ref/states/layers.rst:31
msgid ""
"A single low chunk can be executed manually via the ``state.low`` command."
msgstr ""

#: ../../ref/states/layers.rst:37
msgid ""
"The passed data reflects what the state execution system gets after "
"compiling the data down from sls formulas."
msgstr ""

#: ../../ref/states/layers.rst:41
msgid "Low State"
msgstr ""

#: ../../ref/states/layers.rst:43
msgid ""
"The `Low State` layer is the list of low chunks \"evaluated\" in order. To "
"see what the low state looks like for a highstate, run:"
msgstr ""

#: ../../ref/states/layers.rst:50
msgid ""
"This will display the raw lowstate in the order which each low chunk will be"
" evaluated. The order of evaluation is not necessarily the order of "
"execution, since requisites are evaluated at runtime. Requisite execution "
"and evaluation is finite; this means that the order of execution can be "
"ascertained with 100% certainty based on the order of the low state."
msgstr ""

#: ../../ref/states/layers.rst:57
msgid "High Data"
msgstr ""

#: ../../ref/states/layers.rst:59
msgid ""
"High data is the data structure represented in YAML via SLS files. The High "
"data structure is created by merging the data components rendered inside sls"
" files (or other render systems). The High data can be easily viewed by "
"executing the ``state.show_highstate`` or ``state.show_sls`` functions. "
"Since this data is a somewhat complex data structure, it may be easier to "
"read using the json, yaml, or pprint outputters:"
msgstr ""

#: ../../ref/states/layers.rst:72
msgid "SLS"
msgstr ""

#: ../../ref/states/layers.rst:74
msgid ""
"Above \"High Data\", the logical layers are no longer technically required "
"to be executed, or to be executed in a hierarchy. This means that how the "
"High data is generated is optional and very flexible. The SLS layer allows "
"for many mechanisms to be used to render sls data from files or to use the "
"fileserver backend to generate sls and file data from external systems."
msgstr ""

#: ../../ref/states/layers.rst:80
msgid ""
"The SLS layer can be called directly to execute individual sls formulas."
msgstr ""

#: ../../ref/states/layers.rst:84
msgid ""
"SLS Formulas have historically been called \"SLS files\". This is because a "
"single SLS was only constituted in a single file. Now the term \"SLS "
"Formula\" better expresses how a compartmentalized SLS can be expressed in a"
" much more dynamic way by combining pillar and other sources, and the SLS "
"can be dynamically generated."
msgstr ""

#: ../../ref/states/layers.rst:90
msgid ""
"To call a single SLS formula named ``edit.vim``, execute ``state.sls``:"
msgstr ""

#: ../../ref/states/layers.rst:97
msgid "HighState"
msgstr ""

#: ../../ref/states/layers.rst:99
msgid ""
"Calling SLS directly logically assigns what states should be executed from "
"the context of the calling minion. The Highstate layer is used to allow for "
"full contextual assignment of what is executed where to be tied to groups "
"of, or individual, minions entirely from the master. This means that the "
"environment of a minion, and all associated execution data pertinent to said"
" minion, can be assigned from the master without needing to execute or "
"configure anything on the target minion. This also means that the minion can"
" independently retrieve information about its complete configuration from "
"the master."
msgstr ""

#: ../../ref/states/layers.rst:108
msgid "To execute the High State call ``state.highstate``:"
msgstr ""

#: ../../ref/states/layers.rst:115
msgid "OverState"
msgstr ""

#: ../../ref/states/layers.rst:117
msgid ""
"The overstate layer expresses the highest functional layer of Salt's "
"automated logic systems. The Overstate allows for stateful and functional "
"orchestration of routines from the master. The overstate defines in data "
"execution stages which minions should execute states, or functions, and in "
"what order using requisite logic."
msgstr ""
