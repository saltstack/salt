# 
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-799-g9ccf089\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-11 21:20\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/writing.rst:6
msgid "State Modules"
msgstr ""

#: ../../ref/states/writing.rst:8
msgid ""
"State Modules are the components that map to actual enforcement and "
"management of Salt states."
msgstr ""

#: ../../ref/states/writing.rst:12
msgid "States are Easy to Write!"
msgstr ""

#: ../../ref/states/writing.rst:14
msgid ""
"State Modules should be easy to write and straightforward. The information "
"passed to the SLS data structures will map directly to the states modules."
msgstr ""

#: ../../ref/states/writing.rst:17
msgid ""
"Mapping the information from the SLS data is simple, this example should "
"illustrate:"
msgstr ""

#: ../../ref/states/writing.rst:30
msgid ""
"Therefore this SLS data can be directly linked to a module, function and "
"arguments passed to that function."
msgstr ""

#: ../../ref/states/writing.rst:33
msgid ""
"This does issue the burden, that function names, state names and function "
"arguments should be very human readable inside state modules, since they "
"directly define the user interface."
msgstr ""

#: ../../ref/states/writing.rst:37
msgid "Keyword Arguments"
msgstr ""

#: ../../ref/states/writing.rst:39
msgid ""
"Salt passes a number of keyword arguments to states when rendering them, "
"including the environment, a unique identifier for the state, and more. "
"Additionally, keep in mind that the requisites for a state are part of the "
"keyword arguments. Therefore, if you need to iterate through the keyword "
"arguments in a state, these must be considered and handled appropriately. "
"One such example is in the :mod:`pkgrepo.managed "
"<salt.states.pkgrepo.managed>` state, which needs to be able to handle "
"arbitrary keyword arguments and pass them to module execution functions. An "
"example of how these keyword arguments can be handled can be found here_."
msgstr ""

#: ../../ref/states/writing.rst:54
msgid "Using Custom State Modules"
msgstr ""

#: ../../ref/states/writing.rst:56
msgid ""
"Place your custom state modules inside a ``_states`` directory within the "
":conf_master:`file_roots` specified by the master config file. These custom "
"state modules can then be distributed in a number of ways. Custom state "
"modules are distributed when :mod:`state.highstate "
"<salt.modules.state.highstate>` is run, or by executing the "
":mod:`saltutil.sync_states <salt.modules.saltutil.sync_states>` or "
":mod:`saltutil.sync_all <salt.modules.saltutil.sync_all>` functions."
msgstr ""

#: ../../ref/states/writing.rst:64
msgid ""
"Any custom states which have been synced to a minion, that are named the "
"same as one of Salt's default set of states, will take the place of the "
"default state with the same name. Note that a state's default name is its "
"filename (i.e. ``foo.py`` becomes state ``foo``), but that its name can be "
"overridden by using a :ref:`__virtual__ function <virtual-modules>`."
msgstr ""

#: ../../ref/states/writing.rst:72
msgid "Cross Calling Modules"
msgstr ""

#: ../../ref/states/writing.rst:74
msgid ""
"As with Execution Modules, State Modules can also make use of the "
"``__salt__`` and ``__grains__`` data."
msgstr ""

#: ../../ref/states/writing.rst:77
msgid ""
"It is important to note that the real work of state management should not be"
" done in the state module unless it is needed. A good example is the pkg "
"state module. This module does not do any package management work, it just "
"calls the pkg execution module. This makes the pkg state module completely "
"generic, which is why there is only one pkg state module and many backend "
"pkg execution modules."
msgstr ""

#: ../../ref/states/writing.rst:84
msgid ""
"On the other hand some modules will require that the logic be placed in the "
"state module, a good example of this is the file module. But in the vast "
"majority of cases this is not the best approach, and writing specific "
"execution modules to do the backend work will be the optimal solution."
msgstr ""

#: ../../ref/states/writing.rst:90
msgid "Return Data"
msgstr ""

#: ../../ref/states/writing.rst:92
msgid ""
"A State Module must return a dict containing the following keys/values:"
msgstr ""

#: ../../ref/states/writing.rst:94
msgid "**name:** The same value passed to the state as \"name\"."
msgstr ""

#: ../../ref/states/writing.rst:95
msgid ""
"**changes:** A dict describing the changes made. Each thing changed should "
"be a key, with its value being another dict with keys called \"old\" and "
"\"new\" containing the old/new values. For example, the pkg state's "
"**changes** dict has one key for each package changed, with the \"old\" and "
"\"new\" keys in its sub-dict containing the old and new versions of the "
"package."
msgstr ""

#: ../../ref/states/writing.rst:100
msgid ""
"**result:** A boolean value. *True* if the action was successful, otherwise "
"*False*."
msgstr ""

#: ../../ref/states/writing.rst:102
msgid "**comment:** A string containing a summary of the result."
msgstr ""

#: ../../ref/states/writing.rst:105
msgid "Test State"
msgstr ""

#: ../../ref/states/writing.rst:107
msgid ""
"All states should check for and support ``test`` being passed in the "
"options. This will return data about what changes would occur if the state "
"were actually run. An example of such a check could look like this:"
msgstr ""

#: ../../ref/states/writing.rst:119
msgid ""
"Make sure to test and return before performing any real actions on the "
"minion."
msgstr ""

#: ../../ref/states/writing.rst:122
msgid "Watcher Function"
msgstr ""

#: ../../ref/states/writing.rst:124
msgid ""
"If the state being written should support the watch requisite then a watcher"
" function needs to be declared. The watcher function is called whenever the "
"watch requisite is invoked and should be generic to the behavior of the "
"state itself."
msgstr ""

#: ../../ref/states/writing.rst:129
msgid ""
"The watcher function should accept all of the options that the normal state "
"functions accept (as they will be passed into the watcher function)."
msgstr ""

#: ../../ref/states/writing.rst:132
msgid ""
"A watcher function typically is used to execute state specific reactive "
"behavior, for instance, the watcher for the service module restarts the "
"named service and makes it useful for the watcher to make the service react "
"to changes in the environment."
msgstr ""

#: ../../ref/states/writing.rst:137
msgid ""
"The watcher function also needs to return the same data that a normal state "
"function returns."
msgstr ""

#: ../../ref/states/writing.rst:142
msgid "Mod_init Interface"
msgstr ""

#: ../../ref/states/writing.rst:144
msgid ""
"Some states need to execute something only once to ensure that an "
"environment has been set up, or certain conditions global to the state "
"behavior can be predefined. This is the realm of the mod_init interface."
msgstr ""

#: ../../ref/states/writing.rst:148
msgid ""
"A state module can have a function called **mod_init** which executes when "
"the first state of this type is called. This interface was created primarily"
" to improve the pkg state. When packages are installed the package metadata "
"needs to be refreshed, but refreshing the package metadata every time a "
"package is installed is wasteful. The mod_init function for the pkg state "
"sets a flag down so that the first, and only the first, package installation"
" attempt will refresh the package database (the package database can of "
"course be manually called to refresh via the ``refresh`` option in the pkg "
"state)."
msgstr ""

#: ../../ref/states/writing.rst:157
msgid ""
"The mod_init function must accept the **Low State Data** for the given "
"executing state as an argument. The low state data is a dict and can be seen"
" by executing the state.show_lowstate function. Then the mod_init function "
"must return a bool. If the return value is True, then the mod_init function "
"will not be executed again, meaning that the needed behavior has been set "
"up. Otherwise, if the mod_init function returns False, then the function "
"will be called the next time."
msgstr ""

#: ../../ref/states/writing.rst:165
msgid ""
"A good example of the mod_init function is found in the pkg state module:"
msgstr ""

#: ../../ref/states/writing.rst:181
msgid ""
"The mod_init function in the pkg state accepts the low state data as ``low``"
" and then checks to see if the function being called is going to install "
"packages, if the function is not going to install packages then there is no "
"need to refresh the package database. Therefore if the package database is "
"prepared to refresh, then return True and the mod_init will not be called "
"the next time a pkg state is evaluated, otherwise return False and the "
"mod_init will be called next time a pkg state is evaluated."
msgstr ""
