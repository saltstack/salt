# 
msgid ""
msgstr ""
"Project-Id-Version: Salt 0.17.0-799-g9ccf089\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-11 21:20\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../ref/states/ordering.rst:6
msgid "Ordering States"
msgstr ""

#: ../../ref/states/ordering.rst:8
msgid ""
"The way in which configuration management systems are executed is a hotly "
"debated topic in the configuration management world. Two major philosophies "
"exist on the subject, to either execute in an imperative fashion where "
"things are executed in the order in which they are defined, or in a "
"declarative fashion where dependencies need to be mapped between objects."
msgstr ""

#: ../../ref/states/ordering.rst:14
msgid ""
"Imperative ordering is finite and generally considered easier to write, but "
"declarative ordering is much more powerful and flexible but generally "
"considered more difficult to create."
msgstr ""

#: ../../ref/states/ordering.rst:18
msgid ""
"Salt has been created to get the best of both worlds. States are evaluated "
"in a finite order, which guarantees that states are always executed in the "
"same order, and the states runtime is declarative, making Salt fully aware "
"of dependencies via the requisite system."
msgstr ""

#: ../../ref/states/ordering.rst:24
msgid "State Auto Ordering"
msgstr ""

#: ../../ref/states/ordering.rst:28
msgid ""
"Salt always executes states in a finite manner, meaning that they will "
"always execute in the same order regardless of the system that is executing "
"them. But in Salt 0.17.0, the ``state_auto_order`` option was added. This "
"option makes states get evaluated in the order in which they are defined in "
"sls files."
msgstr ""

#: ../../ref/states/ordering.rst:34
msgid ""
"The evaluation order makes it easy to know what order the states will be "
"executed in, but it is important to note that the requisite system will "
"override the ordering defined in the files, and the ``order`` option "
"described below will also override the order in which states are defined in "
"sls files."
msgstr ""

#: ../../ref/states/ordering.rst:39
msgid ""
"If the classic ordering is preferred (lexicographic), then set "
"``state_auto_order`` to ``False`` in the master configuration file."
msgstr ""

#: ../../ref/states/ordering.rst:43
msgid "Requisite Statements"
msgstr ""

#: ../../ref/states/ordering.rst:47
msgid ""
"This document represents behavior exhibited by Salt requisites as of version"
" 0.9.7 of Salt."
msgstr ""

#: ../../ref/states/ordering.rst:50
msgid ""
"Often when setting up states any single action will require or depend on "
"another action. Salt allows you to build relationships between states with "
"requisite statements. A requisite statement ensure that the named state is "
"evaluated before the state requiring it. There are two types of requisite "
"statements in Salt, **require** and **watch**."
msgstr ""

#: ../../ref/states/ordering.rst:56
msgid ""
"These requisite statements are applied to a specific state declaration:"
msgstr ""

#: ../../ref/states/ordering.rst:69
msgid ""
"In this example we use the **require** requisite to declare that the file "
"/etc/httpd/conf/httpd.conf should only be set up if the pkg state executes "
"successfully."
msgstr ""

#: ../../ref/states/ordering.rst:73
msgid ""
"The requisite system works by finding the states that are required and "
"executing them before the state that requires them. Then the required states"
" can be evaluated to see if they have executed correctly."
msgstr ""

#: ../../ref/states/ordering.rst:77
msgid "Requisite matching"
msgstr ""

#: ../../ref/states/ordering.rst:79
msgid ""
"Requisites match on both the ID Declaration and the ``name`` parameter. "
"Therefore, if you are using the ``pkgs`` or ``sources`` argument to install "
"a list of packages in a pkg state, it's important to note that you cannot "
"have a requisite that matches on an individual package in the list."
msgstr ""

#: ../../ref/states/ordering.rst:86
msgid "Multiple Requisites"
msgstr ""

#: ../../ref/states/ordering.rst:88
msgid ""
"The requisite statement is passed as a list, allowing for the easy addition "
"of more requisites. Both requisite types can also be separately declared:"
msgstr ""

#: ../../ref/states/ordering.rst:114
msgid ""
"In this example the httpd service is only going to be started if the "
"package, user, group and file are executed successfully."
msgstr ""

#: ../../ref/states/ordering.rst:118
msgid "The Require Requisite"
msgstr ""

#: ../../ref/states/ordering.rst:120
msgid ""
"The foundation of the requisite system is the ``require`` requisite. The "
"require requisite ensures that the required state(s) are executed before the"
" requiring state. So, if a state is declared that sets down a vimrc, then it"
" would be pertinent to make sure that the vimrc file would only be set down "
"if the vim package has been installed:"
msgstr ""

#: ../../ref/states/ordering.rst:136
msgid ""
"In this case, the vimrc file will only be applied by Salt if and after the "
"vim package is installed."
msgstr ""

#: ../../ref/states/ordering.rst:140
msgid "The Watch Requisite"
msgstr ""

#: ../../ref/states/ordering.rst:142
msgid ""
"The ``watch`` requisite is more advanced than the ``require`` requisite. The"
" watch requisite executes the same logic as require (therefore if something "
"is watched it does not need to also be required) with the addition of "
"executing logic if the required states have changed in some way."
msgstr ""

#: ../../ref/states/ordering.rst:147
msgid ""
"The watch requisite checks to see if the watched states have returned any "
"changes. If the watched state returns changes, and the watched states "
"execute successfully, then the watching state will execute a function that "
"reacts to the changes in the watched states."
msgstr ""

#: ../../ref/states/ordering.rst:152
msgid "Perhaps an example can better explain the behavior:"
msgstr ""

#: ../../ref/states/ordering.rst:170
msgid ""
"In this example the redis service will only be started if the file "
"/etc/redis.conf is applied, and the file is only applied if the package is "
"installed. This is normal require behavior, but if the watched file changes,"
" or the watched package is installed or upgraded, then the redis service is "
"restarted."
msgstr ""

#: ../../ref/states/ordering.rst:177
msgid "Watch and the mod_watch Function"
msgstr ""

#: ../../ref/states/ordering.rst:179
msgid ""
"The watch requisite is based on the ``mod_watch`` function. Python state "
"modules can include a function called ``mod_watch`` which is then called if "
"the watch call is invoked. When ``mod_watch`` is called depends on the "
"execution of the watched state, which:"
msgstr ""

#: ../../ref/states/ordering.rst:184
msgid ""
"If no changes then just run the watching state itself as usual. "
"``mod_watch`` is not called. This behavior is same as using a ``require``."
msgstr ""

#: ../../ref/states/ordering.rst:187
msgid ""
"If changes then run the watching state *AND* if that changes nothing then "
"react by calling ``mod_watch``."
msgstr ""

#: ../../ref/states/ordering.rst:190
msgid ""
"When reacting, in the case of the service module the underlying service is "
"restarted. In the case of the cmd state the command is executed."
msgstr ""

#: ../../ref/states/ordering.rst:193
msgid "The ``mod_watch`` function for the service state looks like this:"
msgstr ""

#: ../../ref/states/ordering.rst:225
msgid ""
"The watch requisite only works if the state that is watching has a "
"``mod_watch`` function written. If watch is set on a state that does not "
"have a ``mod_watch`` function (like pkg), then the listed states will behave"
" only as if they were under a ``require`` statement."
msgstr ""

#: ../../ref/states/ordering.rst:230
msgid ""
"Also notice that a ``mod_watch`` may accept additional keyword arguments, "
"which, in the sls file, will be taken from the same set of arguments "
"specified for the state that includes the ``watch`` requisite. This means, "
"for the earlier ``service.running`` example above,  you can tell the service"
" to ``reload`` instead of restart like this:"
msgstr ""

#: ../../ref/states/ordering.rst:251
msgid "The Order Option"
msgstr ""

#: ../../ref/states/ordering.rst:253
msgid ""
"Before using the order option, remember that the majority of state ordering "
"should be done with a :term:`requisite declaration`, and that a requisite "
"declaration will override an order option."
msgstr ""

#: ../../ref/states/ordering.rst:257
msgid ""
"The order option is used by adding an order number to a state declaration "
"with the option `order`:"
msgstr ""

#: ../../ref/states/ordering.rst:266
msgid ""
"By adding the order option to `1` this ensures that the vim package will be "
"installed in tandem with any other state declaration set to the order `1`."
msgstr ""

#: ../../ref/states/ordering.rst:269
msgid ""
"Any state declared without an order option will be executed after all states"
" with order options are executed."
msgstr ""

#: ../../ref/states/ordering.rst:272
msgid ""
"But this construct can only handle ordering states from the beginning. "
"Sometimes you may want to send a state to the end of the line. To do this, "
"set the order to ``last``:"
msgstr ""

#: ../../ref/states/ordering.rst:282
msgid ""
"Remember that requisite statements override the order option. So the order "
"option should be applied to the highest component of the requisite chain:"
msgstr ""
