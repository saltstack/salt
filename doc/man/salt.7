.TH "SALT" "7" "July 01, 2013" "0.16.0" "Salt"
.SH NAME
salt \- Salt Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructeredText.
.
.SH INTRODUCTION TO SALT
Weâ€™re not just talking about NaCl..SS The 30 second summary
.sp
Salt is:
.INDENT 0.0
.IP \(bu 2
a configuration management system, capable of maintaining remote nodes
in defined states (for example, ensuring that specific packages are installed and
specific services are running)
.IP \(bu 2
a distributed remote execution system used to execute commands and
query data on remote nodes, either individually or by arbitrary
selection criteria
.UNINDENT
.sp
It was developed in order to bring the best solutions found in the
world of remote execution together and make them better, faster, and more
malleable. Salt accomplishes this through its ability to handle large loads of
information, and not just dozens but hundreds and even thousands of individual
servers quickly through a simple and manageable interface.
.SS Simplicity
.sp
Providing versatility between massive scale deployments and smaller systems may seem
daunting, but Salt is very simple to set up and maintain, regardless of the
size of the project. The architecture of Salt is designed to work with any
number of servers, from a handful of local network systems to international
deployments across different datacenters. The topology is a simple
server/client model with the needed functionality built into a single set of
daemons. While the default configuration will work with little to no
modification, Salt can be fine tuned to meet specific needs.
.SS Parallel execution
.sp
The core functions of Salt:
.INDENT 0.0
.IP \(bu 2
enable commands to remote systems to be called in parallel rather than serially
.IP \(bu 2
use a secure and encrypted protocol
.IP \(bu 2
use the smallest and fastest network payloads possible
.IP \(bu 2
provide a simple programming interface
.UNINDENT
.sp
Salt also introduces more granular controls to the realm of remote
execution, allowing systems to be targeted not just by hostname, but
also by system properties.
.SS Building on proven technology
.sp
Salt takes advantage of a number of technologies and techniques. The
networking layer is built with the excellent \fI\%ZeroMQ\fP networking
library, so the Salt daemon includes a viable and transparent AMQ
broker. Salt uses public keys for authentication with the master
daemon, then uses faster \fI\%AES\fP encryption for payload communication;
authentication and encryption are integral to Salt.  Salt takes
advantage of communication via \fI\%msgpack\fP, enabling fast and light
network traffic.
.SS Python client interface
.sp
In order to allow for simple expansion, Salt execution routines can be written
as plain Python modules. The data collected from Salt executions can be sent
back to the master server, or to any arbitrary program. Salt can be called from
a simple Python API, or from the command line, so that Salt can be used to
execute one\-off commands as well as operate as an integral part of a larger
application.
.SS Fast, flexible, scalable
.sp
The result is a system that can execute commands at high speed on
target server groups ranging from one to very many servers. Salt is
very fast, easy to set up, amazingly malleable and provides a single
remote execution architecture that can manage the diverse
requirements of any number of servers.  The Salt infrastructure
brings together the best of the remote execution world, amplifies its
capabilities and expands its range, resulting in a system that is as
versatile as it is practical, suitable for any network.
.SS Open
.sp
Salt is developed under the \fI\%Apache 2.0 license\fP, and can be used for
open and proprietary projects. Please submit your expansions back to
the Salt project so that we can all benefit together as Salt grows.
Please feel free to sprinkle Salt around your systems and let the
deliciousness come forth.
.SH INSTALLATION
.sp
The Salt system setup is amazingly simple, as this is one of the central design
goals of Salt.
.IP "See also"
.sp
\fBInstalling Salt for development\fP and contributing
to the project.
.RE
.SS Quick Install
.sp
Many popular distributions will be able to install the salt minion by executing the bootstrap script:
.sp
.nf
.ft C
wget \-O \- http://bootstrap.saltstack.org | sudo sh
.ft P
.fi
.sp
The script should also make it simple to install a salt master, if desired.
.sp
Currently the install script has been tested to work on:
.INDENT 0.0
.IP \(bu 2
Ubuntu 10.x/11.x/12.x
.IP \(bu 2
Debian 6.x
.IP \(bu 2
CentOS 6.3
.IP \(bu 2
Fedora
.IP \(bu 2
Arch
.IP \(bu 2
FreeBSD 9.0
.UNINDENT
.sp
See \fI\%Salt Bootstrap\fP for more information.
.SS Platform\-specific installation instructions
.sp
These guides go into detail how to install salt on a given platform.
.SS Arch Linux
.SS Installation
.sp
Salt is currently available via the Arch User Repository (AUR). There are
currently stable and \-git packages available.
.SS Stable Release
.sp
Install Salt stable releases from the Arch Linux AUR as follows:
.sp
.nf
.ft C
wget https://aur.archlinux.org/packages/sa/salt/salt.tar.gz
tar xf salt.tar.gz
cd salt/
makepkg \-is
.ft P
.fi
.sp
A few of Salt\(aqs dependencies are currently only found within the AUR, so it is
necessary to download and run \fBmakepkg \-is\fP on these as well. As a reference, Salt
currently relies on the following packages which are only available via the AUR:
.INDENT 0.0
.IP \(bu 2
\fI\%https://aur.archlinux.org/packages/py/python2-msgpack/python2-msgpack.tar.gz\fP
.IP \(bu 2
\fI\%https://aur.archlinux.org/packages/py/python2-psutil/python2-psutil.tar.gz\fP
.UNINDENT
.IP Note
yaourt
.sp
If a tool such as \fI\%Yaourt\fP is used, the dependencies will be
gathered and built automatically.
.sp
The command to install salt using the yaourt tool is:
.sp
.nf
.ft C
yaourt salt
.ft P
.fi
.RE
.SS Tracking develop
.sp
To install the bleeding edge version of Salt (\fBmay include bugs!\fP),
use the \-git package. Installing the \-git package as follows:
.sp
.nf
.ft C
wget https://aur.archlinux.org/packages/sa/salt\-git/salt\-git.tar.gz
tar xf salt\-git.tar.gz
cd salt\-git/
makepkg \-is
.ft P
.fi
.sp
See the note above about Salt\(aqs dependencies.
.SS Post\-installation tasks
.sp
\fBsystemd\fP
.sp
Activate the Salt Master and/or Minion via \fBsystemctl\fP as follows:
.sp
.nf
.ft C
systemctl enable salt\-master.service
systemctl enable salt\-minion.service
.ft P
.fi
.sp
\fBStart the Master\fP
.sp
Once you\(aqve completed all of these steps you\(aqre ready to start your Salt
Master. You should be able to start your Salt Master now using the command
seen here:
.sp
.nf
.ft C
systemctl start salt\-master
.ft P
.fi
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Debian Installation
.sp
Currently the latest packages for Debian Old Stable, Stable and
Unstable (Squeeze, Wheezy and Sid) are published in our
(saltstack.com) debian repository.
.SS Configure Apt
.SS Squeeze (Old Stable)
.sp
For squeeze, you will need to enable the debian backports repository
as well as the debian.saltstack.com repository. To do so, add the
following to \fB/etc/apt/sources.list\fP or a file in
\fB/etc/apt/sources.list.d\fP:
.sp
.nf
.ft C
deb http://debian.saltstack.com/debian squeeze\-saltstack main
deb http://backports.debian.org/debian\-backports squeeze\-backports main contrib non\-free
.ft P
.fi
.SS Wheezy (Stable)
.sp
For wheezy, the following line is needed in either
\fB/etc/apt/sources.list\fP or a file in \fB/etc/apt/sources.list.d\fP:
.sp
.nf
.ft C
deb http://debian.saltstack.com/debian wheezy\-saltstack main
.ft P
.fi
.SS Sid (Unstable)
.sp
For sid, the following line is needed in either
\fB/etc/apt/sources.list\fP or a file in \fB/etc/apt/sources.list.d\fP:
.sp
.nf
.ft C
deb http://debian.saltstack.com/debian unstable main
.ft P
.fi
.SS Import the repository key.
.sp
You will need to import the key used for signing.
.sp
.nf
.ft C
wget \-q \-O\- "http://debian.saltstack.com/debian\-salt\-team\-joehealy.gpg.key" | apt\-key add \-
.ft P
.fi
.IP Note
You can optionally verify the key integrity with \fBsha512sum\fP using the
public key signature shown here. E.g:
.sp
.nf
.ft C
echo "b702969447140d5553e31e9701be13ca11cc0a7ed5fe2b30acb8491567560ee62f834772b5095d735dfcecb2384a5c1a20045f52861c417f50b68dd5ff4660e6  debian\-salt\-team\-joehealy.gpg.key" | sha512sum \-c
.ft P
.fi
.RE
.SS Update the package database
.sp
.nf
.ft C
apt\-get update
.ft P
.fi
.SS Install packages
.sp
Install the Salt master, minion, or syndic from the repository with the apt\-get
command. These examples each install one daemon, but more than one package name
may be given at a time:
.sp
.nf
.ft C
apt\-get install salt\-master
.ft P
.fi
.sp
.nf
.ft C
apt\-get install salt\-minion
.ft P
.fi
.sp
.nf
.ft C
apt\-get install salt\-syndic
.ft P
.fi
.SS Post\-installation tasks
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Notes
.sp
1. These packages will be backported from the packages intended to be
uploaded into debian unstable. This means that the packages will be
built for unstable first and then backported over the next day or so.
.sp
2. These packages will be tracking the released versions of salt
rather than maintaining a stable fixed feature set. If a fixed version
is what you desire, then either pinning or manual installation may be
more appropriate for you.
.sp
3. The version numbering and backporting process should provide clean
upgrade paths between debian versions.
.sp
If you have any questions regarding these, please email the mailing
list or look for joehh on irc.
.SS Fedora
.sp
Beginning with version 0.9.4, Salt has been available in the primary Fedora
repositories and \fI\%EPEL\fP. It is installable using yum. Fedora will have more
up to date versions of Salt than other members of the Red Hat family, which
makes it a great place to help improve Salt!
.SS Installation
.sp
Salt can be installed using \fByum\fP and is available in the standard Fedora
repositories.
.SS Stable Release
.sp
Salt is packaged separately for the minion and the master. It is necessary only to
install the appropriate package for the role the machine will play. Typically, there
will be one master and multiple minions.
.sp
.nf
.ft C
yum install salt\-master
yum install salt\-minion
.ft P
.fi
.SS Post\-installation tasks
.sp
\fBMaster\fP
.sp
To have the Master start automatically at boot time:
.sp
.nf
.ft C
systemctl enable salt\-master.service
.ft P
.fi
.sp
To start the Master:
.sp
.nf
.ft C
systemctl start salt\-master.service
.ft P
.fi
.sp
\fBMinion\fP
.sp
To have the Minion start automatically at boot time:
.sp
.nf
.ft C
systemctl enable salt\-minion.service
.ft P
.fi
.sp
To start the Minion:
.sp
.nf
.ft C
systemctl start salt\-minion.service
.ft P
.fi
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS FreeBSD
.sp
Salt was added to the FreeBSD ports tree Dec 26th, 2011 by Christer Edwards
<\fI\%christer.edwards@gmail.com\fP>. It has been tested on FreeBSD 7.4, 8.2, 9.0 and 9.1
releases.
.sp
Salt is dependent on the following additional ports. These will be installed as
dependencies of the \fBsysutils/py\-salt\fP port.
.sp
.nf
.ft C
/devel/py\-yaml
/devel/py\-pyzmq
/devel/py\-Jinja2
/devel/py\-msgpack
/security/py\-pycrypto
/security/py\-m2crypto
.ft P
.fi
.SS Installation
.sp
To install Salt from the FreeBSD ports tree, use the command:
.sp
.nf
.ft C
make \-C /usr/ports/sysutils/py\-salt install clean
.ft P
.fi
.SS Post\-installation tasks
.sp
\fBMaster\fP
.sp
Copy the sample configuration file:
.sp
.nf
.ft C
cp /usr/local/etc/salt/master.sample /usr/local/etc/salt/master
.ft P
.fi
.sp
\fBrc.conf\fP
.sp
Activate the Salt Master in \fB/etc/rc.conf\fP or \fB/etc/rc.conf.local\fP and add:
.sp
.nf
.ft C
+ salt_master_enable="YES"
.ft P
.fi
.sp
\fBStart the Master\fP
.sp
Start the Salt Master as follows:
.sp
.nf
.ft C
service salt_master start
.ft P
.fi
.sp
\fBMinion\fP
.sp
Copy the sample configuration file:
.sp
.nf
.ft C
cp /usr/local/etc/salt/minion.sample /usr/local/etc/salt/minion
.ft P
.fi
.sp
\fBrc.conf\fP
.sp
Activate the Salt Minion in \fB/etc/rc.conf\fP or \fB/etc/rc.conf.local\fP and add:
.sp
.nf
.ft C
+ salt_minion_enable="YES"
+ salt_minion_paths="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"
.ft P
.fi
.sp
\fBStart the Minion\fP
.sp
Start the Salt Minion as follows:
.sp
.nf
.ft C
service salt_minion start
.ft P
.fi
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Gentoo
.sp
Salt can be easily installed on Gentoo via Portage:
.sp
.nf
.ft C
emerge app\-admin/salt
.ft P
.fi
.SS Post\-installation tasks
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS OS X
.SS Dependency Installation
.sp
ZeroMQ and swig need to be installed first.
.sp
Using homebrew:
.sp
.nf
.ft C
brew install swig
brew install zmq
.ft P
.fi
.sp
Using macports, zmq, swig, and pip may need to be installed this way:
.sp
.nf
.ft C
sudo port install py\-zmq
sudo port install py27\-m2crypto
sudo port install py27\-crypto
sudo port install py27\-msgpack
sudo port install swig\-python
sudo port install py\-pip
.ft P
.fi
.sp
For installs using the OSX system python, pip install needs to use \(aqsudo\(aq:
.sp
.nf
.ft C
sudo pip install salt
.ft P
.fi
.sp
For installs using \fI\%python installed via homebrew\fP, sudo should be unnecessary:
.sp
.nf
.ft C
pip install salt
.ft P
.fi
.SS Salt\-Master Customizations
.sp
To run salt\-master on OSX, the root user maxfiles limit must be increased:
.sp
.nf
.ft C
sudo launchctl limit maxfiles 10000
.ft P
.fi
.sp
And add this configuration option to the /etc/salt/master file:
.sp
.nf
.ft C
max_open_files: 10000
.ft P
.fi
.sp
Now the salt\-master should run without errors:
.sp
.nf
.ft C
sudo salt\-master \-\-log\-level=all
.ft P
.fi
.SS Post\-installation tasks
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS RHEL / CentOS / Scientific Linux / Amazon Linux / Oracle Linux
.sp
Beginning with version 0.9.4, Salt has been available in \fI\%EPEL\fP. It is installable using yum. Salt should work properly with all mainstream derivatives
of RHEL, including CentOS, Scientific Linux, Oracle Linux and Amazon Linux. Report any bugs or issues to the salt github project.
.SS Installation
.sp
Salt and all dependencies have been accepted into the yum repositories for
EPEL5 and EPEL6. The latest salt version can be found in epel\-testing, while an
older but more tested version can be found in regular epel.
.sp
Example showing how to install salt from epel\-testing:
.sp
.nf
.ft C
yum \-\-enablerepo=epel\-testing install salt\-minion
.ft P
.fi
.sp
On RHEL6, the proper Jinja package \(aqpython\-jinja2\(aq was moved from EPEL to the
"RHEL Server Optional Channel". Verify this repository is enabled before
installing salt on RHEL6.
.sp
Salt can be installed using \fByum\fP and is available in the standard Fedora
repositories.
.SS Enabling EPEL on RHEL
.sp
If EPEL is not enabled on your system, you can use the following commands to
enable it.
.sp
For RHEL 5:
.sp
.nf
.ft C
rpm \-Uvh http://mirror.pnl.gov/epel/5/i386/epel\-release\-5\-4.noarch.rpm
.ft P
.fi
.sp
For RHEL 6:
.sp
.nf
.ft C
rpm \-Uvh http://ftp.linux.ncsu.edu/pub/epel/6/i386/epel\-release\-6\-8.noarch.rpm
.ft P
.fi
.SS Stable Release
.sp
Salt is packaged separately for the minion and the master. It is necessary only to install the appropriate package for the role the machine will play. Typically, there will be one master and multiple minions.
.sp
On the salt\-master, run this:
.sp
.nf
.ft C
yum install salt\-master
.ft P
.fi
.sp
On each salt\-minion, run this:
.sp
.nf
.ft C
yum install salt\-minion
.ft P
.fi
.SS Post\-installation tasks
.sp
\fBMaster\fP
.sp
To have the Master start automatically at boot time:
.sp
.nf
.ft C
chkconfig salt\-master on
.ft P
.fi
.sp
To start the Master:
.sp
.nf
.ft C
service salt\-master start
.ft P
.fi
.sp
\fBMinion\fP
.sp
To have the Minion start automatically at boot time:
.sp
.nf
.ft C
chkconfig salt\-minion on
.ft P
.fi
.sp
To start the Minion:
.sp
.nf
.ft C
service salt\-minion start
.ft P
.fi
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Solaris
.sp
Salt was added to the OpenCSW package repository in September of 2012 by Romeo
Theriault <\fI\%romeot@hawaii.edu\fP> at version 0.10.2 of Salt. It has mainly been
tested on Solaris 10 (sparc), though it is built for and has been tested
minimally on Solaris 10 (x86), Solaris 9 (sparc/x86) and 11 (sparc/x86).
(Please let me know if you\(aqre using it on these platforms!) Most of the testing
has also just focused on the minion, though it has verified that the master
starts up successfully on Solaris 10.
.sp
Comments and patches for better support on these platforms is very welcome.
.sp
As of version 0.10.4, Solaris is well supported under salt, with all of the
following working well:
.INDENT 0.0
.IP 1. 3
remote execution
.IP 2. 3
grain detection
.IP 3. 3
service control with SMF
.IP 4. 3
\(aqpkg\(aq states with \(aqpkgadd\(aq and \(aqpkgutil\(aq modules
.IP 5. 3
cron modules/states
.IP 6. 3
user and group modules/states
.IP 7. 3
shadow password management modules/states
.UNINDENT
.sp
Salt is dependent on the following additional packages. These will
automatically be installed as dependencies of the \fBpy_salt\fP package.:
.sp
.nf
.ft C
py_yaml
py_pyzmq
py_jinja2
py_msgpack_python
py_m2crypto
py_crypto
python
.ft P
.fi
.SS Installation
.sp
To install Salt from the OpenCSW package repository you first need to install
\fI\%pkgutil\fP assuming you don\(aqt already have it installed:
.sp
On Solaris 10:
.sp
.nf
.ft C
pkgadd \-d http://get.opencsw.org/now
.ft P
.fi
.sp
On Solaris 9:
.sp
.nf
.ft C
wget http://mirror.opencsw.org/opencsw/pkgutil.pkg
pkgadd \-d pkgutil.pkg all
.ft P
.fi
.sp
Once pkgutil is installed you\(aqll need to edit it\(aqs config file
\fB/etc/opt/csw/pkgutil.conf\fP to point it at the unstable catalog:
.sp
.nf
.ft C
\- #mirror=http://mirror.opencsw.org/opencsw/testing
+ mirror=http://mirror.opencsw.org/opencsw/unstable
.ft P
.fi
.sp
OK, time to install salt.
.sp
.nf
.ft C
# Update the catalog
root> /opt/csw/bin/pkgutil \-U
# Install salt
root> /opt/csw/bin/pkgutil \-i \-y py_salt
.ft P
.fi
.SS Minion Configuration
.sp
Now that salt is installed you can find it\(aqs configuration files in
\fB/etc/opt/csw/salt/\fP.
.sp
You\(aqll want to edit the minion config file to set the name of your salt master
server:
.sp
.nf
.ft C
\- #master: salt
+ master: your\-salt\-server
.ft P
.fi
.sp
If you would like to use \fI\%pkgutil\fP as the default package provider for your
Solaris minions, you can do so using the \fBproviders\fP option in the
minion config file.
.sp
You can now start the salt minion like so:
.sp
On Solaris 10:
.sp
.nf
.ft C
svcadm enable salt\-minion
.ft P
.fi
.sp
On Solaris 9:
.sp
.nf
.ft C
/etc/init.d/salt\-minion start
.ft P
.fi
.sp
You should now be able to log onto the salt master and check to see if the
salt\-minion key is awaiting acceptance:
.sp
.nf
.ft C
salt\-key \-l un
.ft P
.fi
.sp
Accept the key:
.sp
.nf
.ft C
salt\-key \-a <your\-salt\-minion>
.ft P
.fi
.sp
Run a simple test against the minion:
.sp
.nf
.ft C
salt \(aq<your\-salt\-minion>\(aq test.ping
.ft P
.fi
.SS Troubleshooting
.sp
Logs are in \fB/var/log/salt\fP
.SS Ubuntu Installation
.SS Add repository
.sp
The latest packages for Ubuntu are published in the saltstack PPA. If you have
the \fBadd\-apt\-repository\fP utility, you can add the repository and import the
key in one step:
.sp
.nf
.ft C
sudo add\-apt\-repository ppa:saltstack/salt
.ft P
.fi
.IP "add\-apt\-repository: command not found?"
.sp
The \fBadd\-apt\-repository\fP command is not always present on Ubuntu systems.
This can be fixed by installing \fIpython\-software\-properties\fP:
.sp
.nf
.ft C
sudo apt\-get install python\-software\-properties
.ft P
.fi
.sp
Note that since Ubuntu 12.10 (Raring Ringtail), \fBadd\-apt\-repository\fP is
found in the \fIsoftware\-properties\-common\fP package, and is part of the base
install. Thus, \fBadd\-apt\-repository\fP should be able to be used
out\-of\-the\-box to add the PPA.
.RE
.sp
Alternately, manually add the repository and import the PPA key with these commands:
.sp
.nf
.ft C
echo deb http://ppa.launchpad.net/saltstack/salt/ubuntu \(galsb_release \-sc\(ga main | sudo tee /etc/apt/sources.list.d/saltstack.list
wget \-q \-O\- "http://keyserver.ubuntu.com:11371/pks/lookup?op=get&search=0x4759FA960E27C0A6" | sudo apt\-key add \-
.ft P
.fi
.sp
After adding the repository, update the package management database:
.sp
.nf
.ft C
sudo apt\-get update
.ft P
.fi
.SS Install packages
.sp
Install the Salt master, minion, or syndic from the repository with the apt\-get
command. These examples each install one daemon, but more than one package name
may be given at a time:
.sp
.nf
.ft C
sudo apt\-get install salt\-master
.ft P
.fi
.sp
.nf
.ft C
sudo apt\-get install salt\-minion
.ft P
.fi
.sp
.nf
.ft C
sudo apt\-get install salt\-syndic
.ft P
.fi
.SS Post\-installation tasks
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Windows
.sp
Salt has full support for running the Salt Minion on Windows.
.sp
There are no plans for the foreseeable future to develop a Salt
Master on Windows. For now you must run your Salt Master on a
supported operating system to control your Salt Minions on Windows.
.sp
Many of the standard Salt modules have been ported to work on Windows
and many of the Salt States currently work on Windows, as well.
.SS Windows Installer
.sp
A Salt Minion Windows installer can be found here:
.IP "Download here"
.INDENT 0.0
.IP \(bu 2
0.15.3
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.3-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.3-AMD64-Setup.exe\fP
.IP \(bu 2
0.15.2
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.2-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.2-AMD64-Setup.exe\fP
.IP \(bu 2
0.15.1
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.1-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.1-AMD64-Setup.exe\fP
.IP \(bu 2
0.15.0
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.0-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.15.0-AMD64-Setup.exe\fP
.IP \(bu 2
0.14.1
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.14.1-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.14.1-AMD64-Setup.exe\fP
.IP \(bu 2
0.14.0
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.14.0-win32-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.14.0-AMD64-Setup.exe\fP
.IP \(bu 2
0.13.3
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.3-x86-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.3-AMD64-Setup.exe\fP
.IP \(bu 2
0.13.2
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.2-x86-Setup.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.2-AMD64-Setup.exe\fP
.IP \(bu 2
0.13.1
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.1-Setup-amd64.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.13.1-Setup-win32.exe\fP
.IP \(bu 2
0.12.1
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.12.1-Setup-amd64.exe\fP
.IP \(bu 2
\fI\%http://saltstack.com/downloads/Salt-Minion-0.12.1-Setup-win32.exe\fP
.UNINDENT
.RE
.sp
The 64bit installer has been tested on Windows 7 64bit and Windows Server
2008R2 64bit. The 32bit installer has been tested on Windows 2003 Server 32bit.
Please file a bug report on our github repo if issues for other platforms are
found.
.sp
The installer asks for 2 bits of information; the master hostname and the
minion name. The installer will update the minion config with these options and
then start the minion.
.sp
The \fIsalt\-minion\fP service will appear in the Windows Service Manager and can be
started and stopped there or with the command line program \fIsc\fP like any other
Windows service.
.sp
If the minion won\(aqt start, try installing the Microsoft Visual C++ 2008 x64 SP1
redistributable. Allow all Windows updates to run salt\-minion smoothly.
.sp
Make sure that the minion config file has the line \fIipc_mode: tcp\fP
.SS Silent Installer option
.sp
The installer can be run silently by providing the \fI/S\fP option at the command
line. The options \fI/master\fP and \fI/minion\-name\fP allow for configuring the master
hostname and minion name, respectively. Here\(aqs an example of using the silent
installer:
.sp
.nf
.ft C
Salt\-Minion\-0.15.3\-Setup\-amd64.exe /S /master=yoursaltmaster /minion\-name=yourminionname
.ft P
.fi
.SS Installer Source
.sp
The Salt Windows installer is built with the open\-source NSIS compiler. The
source for the installer is found in the pkg directory of the Salt repo here:
\fI\%https://github.com/saltstack/salt/blob/develop/pkg/windows/installer/Salt-Minion-Setup.nsi\fP.
To create the installer run \fBpython setup.py bdist_esky\fP, extract the
frozen archive from \fBdist/\fP into \fBpkg/windows/buildenv/\fP and run NSIS.
.sp
The NSIS installer can be found here: \fI\%http://nsis.sourceforge.net/Main_Page\fP
.SS Installation from source
.sp
To install Salt from source one must install each dependency separately and
configure Salt to run on your Windows host.
.sp
Rather than send you on a wild goose chase across the Internet, we\(aqve collected
some of the more difficult to find installers in our github repo for you.
.SS Install on Windows XP 32bit
.INDENT 0.0
.IP 1. 3
Install \fI\%msysgit\fP
.INDENT 3.0
.IP 1. 3
Clone the Salt git repository from github
.UNINDENT
.UNINDENT
.sp
.nf
.ft C
git clone git://github.com/saltstack/salt.git
.ft P
.fi
.INDENT 0.0
.IP 2. 4
Install Microsoft Visual Studio 2008 Express.
You must use Visual Studio 2008 Express, \fBnot\fP Visual Studio 2010 Express.
.IP 3. 4
Install \fI\%Python 2.7.x\fP
.IP 4. 4
Add c:\ePython27 to your system path
.IP 5. 4
Install the Microsoft Visual C++ 2008 SP1 Redistributable, \fI\%vcredist_x86\fP.
.IP 6. 4
Install \fI\%Win32OpenSSL-1_0_0e.exe\fP
.INDENT 4.0
.IP 1. 3
Choose first option to install in Windows system directory
.UNINDENT
.IP 7. 4
Install \fI\%pyzmq-2.1.11.win32-py2.7.msi\fP
.IP 8. 4
Install \fI\%pycrypto-2.3.win32-py2.7.msi\fP
.IP 9. 4
Install \fI\%M2Crypto\fP
.IP 10. 4
Install \fI\%pywin32\fP
.IP 11. 4
Install \fI\%PyYAML-3.10.win32-py2.7.msi\fP
.IP 12. 4
Install \fI\%Cython-0.15.1.win32-py2.79.exe\fP
.IP 13. 4
Download and run \fI\%distribute_setup.py\fP
.UNINDENT
.sp
.nf
.ft C
python distribute_setup.py
.ft P
.fi
.INDENT 0.0
.IP 14. 4
Download and run \fI\%pip\fP
.UNINDENT
.sp
.nf
.ft C
python get\-pip.py
.ft P
.fi
.INDENT 0.0
.IP 15. 4
Add c:\epython27\escripts to your path
.IP 16. 4
Close terminal window and open a new terminal window (\fIcmd\fP)
.IP 17. 4
Install jinja2
.UNINDENT
.sp
.nf
.ft C
pip install jinja2
.ft P
.fi
.INDENT 0.0
.IP 18. 4
Install wmi
.UNINDENT
.sp
.nf
.ft C
pip install wmi
.ft P
.fi
.INDENT 0.0
.IP 19. 4
Install Messagepack
.UNINDENT
.sp
.nf
.ft C
pip install msgpack\-python
.ft P
.fi
.INDENT 0.0
.IP 20. 4
Install Salt
.UNINDENT
.sp
.nf
.ft C
cd ./salt
python setup.py install
.ft P
.fi
.INDENT 0.0
.IP 21. 4
Edit c:\eetc\esalt\eminion
.UNINDENT
.sp
.nf
.ft C
master: ipaddress or hostname of your salt\-master
master_port: 4506
ipc_mode: tcp
root_dir: c:\e
pki_dir: /etc/salt/pki
cachedir: /var/cache/salt
renderer: yaml_jinja
open_mode: False
multiprocessing: False
.ft P
.fi
.INDENT 0.0
.IP 22. 4
Start the salt\-minion
.UNINDENT
.sp
.nf
.ft C
cd c:\epython27\escripts
python salt\-minion
.ft P
.fi
.INDENT 0.0
.IP 23. 4
On the salt\-master accept the new minion\(aqs key
.UNINDENT
.sp
.nf
.ft C
sudo salt\-key \-A

(This accepts all unaccepted keys. If you\(aqre concerned about security just accept the key for this specific minion)
.ft P
.fi
.INDENT 0.0
.IP 24. 4
Test that your minion is responding
.INDENT 4.0
.INDENT 3.5
.INDENT 0.0
.IP a. 3
On the salt\-master run:
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
.nf
.ft C
sudo salt \(aq*\(aq test.ping
.ft P
.fi
.sp
You should get the following response: {\(aqyour minion hostname\(aq: True}
.SS Single command bootstrap script
.sp
On a 64 bit Windows host the following script makes an unattended install of salt, including all dependencies:
.sp
.nf
.ft C
"PowerShell (New\-Object System.Net.WebClient).DownloadFile(\(aqhttp://csa\-net.dk/salt/bootstrap64.bat\(aq,\(aqC:\ebootstrap.bat\(aq);(New\-Object \-com Shell.Application).ShellExecute(\(aqC:\ebootstrap.bat\(aq);"

(All in one line.)
.ft P
.fi
.sp
You can execute the above command remotely from a Linux host using winexe:
.sp
.nf
.ft C
winexe \-U "administrator" //fqdn "PowerShell (New\-Object ......);"
.ft P
.fi
.sp
For more info check \fI\%http://csa-net.dk/salt\fP
.SS SUSE Installation
.SS openSUSE
.sp
For openSUSE Factory run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/openSUSE_Factory/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.sp
For openSUSE 12.3 run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/openSUSE_12.3/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.sp
For openSUSE 12.2 run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/openSUSE_12.2/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.sp
For openSUSE 12.1 run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/openSUSE_12.1/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.sp
For bleeding edge python Factory run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/bleeding_edge_python_Factory/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.SS SLES 11 SP2
.sp
For SLE 11 SP2 run the following as root:
.sp
.nf
.ft C
zypper addrepo http://download.opensuse.org/repositories/devel:languages:python/SLE_11_SP2/devel:languages:python.repo
zypper refresh
zypper install salt salt\-minion salt\-master
.ft P
.fi
.SS Post\-installation tasks
.sp
Now go to the \fBConfiguring Salt\fP page.
.SS Dependencies
.sp
Salt should run on any Unix\-like platform so long as the dependencies are met.
.INDENT 0.0
.IP \(bu 2
\fI\%Python 2.6\fP >= 2.6 <3.0
.IP \(bu 2
\fI\%ZeroMQ\fP >= 2.1.9
.IP \(bu 2
\fI\%pyzmq\fP >= 2.1.9 \- ZeroMQ Python bindings
.IP \(bu 2
\fI\%PyCrypto\fP \- The Python cryptography toolkit
.IP \(bu 2
\fI\%msgpack-python\fP \- High\-performance message interchange format
.IP \(bu 2
\fI\%YAML\fP \- Python YAML bindings
.IP \(bu 2
\fI\%Jinja2\fP \- parsing Salt States (configurable in the master settings)
.UNINDENT
.SS Optional Dependencies
.INDENT 0.0
.IP \(bu 2
\fI\%mako\fP \- an optional parser for Salt States (configurable in the master settings)
.IP \(bu 2
gcc \- dynamic \fI\%Cython\fP module compiling
.UNINDENT
.SH CONFIGURING SALT
.sp
Salt configuration is very simple. The default configuration for the
\fImaster\fP will work for most installations and the only requirement for
setting up a \fIminion\fP is to set the location of the master in the minion
configuration file.
.INDENT 0.0
.TP
.B master
The Salt master is the central server that all minions connect to.
Commands are run on the minions through the master, and minions send data
back to the master (unless otherwise redirected with a \fBreturner\fP). It is started with the
\fBsalt\-master\fP program.
.TP
.B minion
Salt minions are the potentially hundreds or thousands of servers that
may be queried and controlled from the master.
.UNINDENT
.sp
The configuration files will be installed to \fB/etc/salt\fP and are named
after the respective components, \fB/etc/salt/master\fP and
\fB/etc/salt/minion\fP.
.SS Master Configuration
.sp
By default the Salt master listens on ports 4505 and 4506 on all
interfaces (0.0.0.0). To bind Salt to a specific IP, redefine the
"interface" directive in the master configuration file, typically
\fB/etc/salt/master\fP, as follows:
.sp
.nf
.ft C
\- #interface: 0.0.0.0
+ interface: 10.0.0.1
.ft P
.fi
.sp
After updating the configuration file, restart the Salt master.
See the \fBmaster configuration reference\fP
for more details about other configurable options.
.SS Minion Configuration
.sp
Although there are many Salt Minion configuration options, configuring
a Salt Minion is very simple. By default a Salt Minion will
try to connect to the DNS name "salt"; if the Minion is able to
resolve that name correctly, no configuration is needed.
.sp
If the DNS name "salt" does not resolve to point to the correct
location of the Master, redefine the "master" directive in the minion
configuration file, typically \fB/etc/salt/minion\fP, as follows:
.sp
.nf
.ft C
\- #master: salt
+ master: 10.0.0.1
.ft P
.fi
.sp
After updating the configuration file, restart the Salt minion.
See the \fBminion configuration reference\fP
for more details about other configurable options.
.SS Running Salt
.INDENT 0.0
.IP 1. 3
Start the master in the foreground (to daemonize the process, pass the
\fI\-d flag\fP):
.sp
.nf
.ft C
# salt\-master
.ft P
.fi
.IP 2. 3
Start the minion in the foreground (to daemonize the process, pass the
\fI\-d flag\fP):
.sp
.nf
.ft C
# salt\-minion
.ft P
.fi
.UNINDENT
.IP "Having trouble?"
.sp
The simplest way to troubleshoot Salt is to run the master and minion in
the foreground with \fIlog level\fP set to \fBdebug\fP:
.sp
.nf
.ft C
salt\-master \-\-log\-level=debug
.ft P
.fi
.RE
.IP "Run as an unprivileged (non\-root) user?"
.sp
To run Salt as another user, specify \fB\-\-user\fP in the command
line or assign \fBuser\fP in the
\fBconfiguration file\fP.
.RE
.sp
There is also a full \fBtroubleshooting guide\fP
available.
.SS Key Management
.sp
Salt uses AES encryption for all communication between the Master and
the Minion. This ensures that the commands sent to the Minions cannot
be tampered with, and that communication between Master and Minion is
authenticated through trusted, accepted keys.
.sp
Before commands can be sent to a Minion, its key must be accepted on
the Master. Run the \fBsalt\-key\fP command to list the keys known to
the Salt Master:
.sp
.nf
.ft C
[root@master ~]# salt\-key \-L
Unaccepted Keys:
alpha
bravo
charlie
delta
Accepted Keys:
.ft P
.fi
.sp
This example shows that the Salt Master is aware of four Minions, but none of
the keys has been accepted. To accept the keys and allow the Minions to be
controlled by the Master, again use the \fBsalt\-key\fP command:
.sp
.nf
.ft C
[root@master ~]# salt\-key \-A
[root@master ~]# salt\-key \-L
Unaccepted Keys:
Accepted Keys:
alpha
bravo
charlie
delta
.ft P
.fi
.sp
The \fBsalt\-key\fP command allows for signing keys individually or in bulk. The
example above, using \fB\-A\fP bulk\-accepts all pending keys. To accept keys
individually use the lowercase of the same option, \fB\-a keyname\fP.
.IP "See also"
.sp
\fBsalt\-key manpage\fP
.RE
.SS Sending Commands
.sp
Communication between the Master and a Minion may be verified by running
the \fBtest.ping\fP remote command.
.sp
.nf
.ft C
[root@master ~]# salt \(aqalpha\(aq test.ping
alpha:
    True
.ft P
.fi
.sp
Communication between the Master and all Minions may be tested in a
similar way.
.sp
.nf
.ft C
[root@master ~]# salt \(aq*\(aq test.ping
alpha:
    True
bravo:
    True
charlie:
    True
delta:
    True
.ft P
.fi
.sp
Each of the Minions should send a "True" response as shown above.
.SS What\(aqs Next?
.sp
Depending on the primary way you want to manage your machines you may
either want to visit the section regarding Salt States, or the section
on Modules.
.SH DEVELOPING SALT
.sp
There is a great need for contributions to salt and patches are welcome! The goal
here is to make contributions clear, make sure there is a trail for where the code
has come from, and most importantly, to give credit where credit is due!
.sp
There are a number of ways to contribute to salt development.
.SS Sending a Github pull request
.sp
This is the preferred method for contributions. Simply create a Github
fork, commit changes to the fork, and then open up a pull request.
.sp
The following is an example (from \fI\%Open Comparison Contributing Docs\fP )
of an efficient workflow for forking, cloning, branching, committing, and
sending a pull request for a github repository.
.sp
First, make a local clone of your github fork of the salt github repo and make
edits and changes locally.
.sp
Then, create a new branch on your clone by entering the following commands:
.sp
.nf
.ft C
git checkout \-b fixed\-broken\-thing

Switched to a new branch \(aqfixed\-broken\-thing\(aq
.ft P
.fi
.sp
Choose a name for your branch that describes its purpose.
.sp
Now commit your changes to this new branch with the following command:
.sp
.nf
.ft C
#add and commit all changes at once
git commit \-a \-m \(aqdescription of my fixes for the broken thing\(aq
.ft P
.fi
.sp
And then push your locally committed changes back up to GitHub:
.sp
.nf
.ft C
git push \-\-set\-upstream origin fixed\-broken\-thing
.ft P
.fi
.sp
Now go look at your fork of the salt repo on the GitHub website. The new
branch will now be listed under the "Source" tab where it says "Switch Branches".
Select the new branch from this list, and then click the "Pull request" button.
.sp
Put in a descriptive comment, and include links to any project issues related to the pull request.
.sp
The repo managers will be notified of your pull request and it will
be reviewed. If a reviewer asks for changes, just make the changes locally in the
same local feature branch, push them to GitHub, then add a comment to the
discussion section of the pull request.
.IP Note
Travis\-CI
.sp
To make reviewing pull requests easier for the maintainers, please enable Travis\-CI on
the fork. Salt is already configured, so simply follow the first
2 steps on the Travis\-CI \fI\%Getting Started Doc\fP.
.RE
.SS Keeping Salt Forks in Sync
.sp
Salt is advancing quickly. It is therefore critical to pull upstream changes from master into forks on a regular basis. Nothing is worse than putting in a days of hard work into a pull request only to have it rejected because it has diverged too far from master.
.sp
To pull in upstream changes:
.sp
.nf
.ft C
# For ssh github
git remote add upstream git@github.com:saltstack/salt.git
git fetch upstream

# For https github
git remote add upstream https://github.com/saltstack/salt.git
git fetch upstream
.ft P
.fi
.sp
To check the log to be sure that you actually want the changes, run this before merging:
.sp
.nf
.ft C
git log upstream/develop
.ft P
.fi
.sp
Then to accept the changes and merge into the current branch:
.sp
.nf
.ft C
git merge upstream/develop
.ft P
.fi
.sp
For more info, see \fI\%Github Fork a Repo Guide\fP or \fI\%Open Comparison Contributing Docs\fP
.SS Posting patches to the mailing list
.sp
Patches will also be accepted by email. Format patches using \fI\%git format-patch\fP
and send them to the Salt users mailing list. The contributor will then get credit
for the patch, and the Salt community will have an archive of the patch and a place for discussion.
.SS Installing Salt for development
.sp
Clone the repository using:
.sp
.nf
.ft C
git clone https://github.com/saltstack/salt
.ft P
.fi
.IP Note
tags
.sp
Just cloning the repository is enough to work with Salt and make
contributions. However, fetching additional tags from git is required to
have Salt report the correct version for itself. To do this, first
add the git repository as an upstream source:
.sp
.nf
.ft C
git remote add upstream http://github.com/saltstack/salt
.ft P
.fi
.sp
Fetching tags is done with the git \(aqfetch\(aq utility:
.sp
.nf
.ft C
git fetch \-\-tags upstream
.ft P
.fi
.RE
.sp
Create a new \fI\%virtualenv\fP:
.sp
.nf
.ft C
virtualenv /path/to/your/virtualenv
.ft P
.fi
.sp
On Arch Linux, where Python 3 is the default installation of Python, use the
\fBvirtualenv2\fP command instead of \fBvirtualenv\fP.
.IP Note
Using system Python modules in the virtualenv
.sp
To use already\-installed python modules in virtualenv (instead of having pip
download and compile new ones), run \fBvirtualenv \-\-system\-site\-packages\fP
Using this method eliminates the requirement to install the salt dependencies
again, although it does assume that the listed modules are all installed in the
system PYTHONPATH at the time of virtualenv creation.
.RE
.sp
Activate the virtualenv:
.sp
.nf
.ft C
source /path/to/your/virtualenv/bin/activate
.ft P
.fi
.sp
Install Salt (and dependencies) into the virtualenv:
.sp
.nf
.ft C
pip install M2Crypto    # Don\(aqt install on Debian/Ubuntu (see below)
pip install pyzmq PyYAML pycrypto msgpack\-python jinja2 psutil
pip install \-e ./salt   # the path to the salt git clone from above
.ft P
.fi
.IP Note
Installing M2Crypto
.sp
\fBswig\fP and \fBlibssl\-dev\fP are required to build M2Crypto. To fix
the error \fBcommand \(aqswig\(aq failed with exit status 1\fP while installing M2Crypto,
try installing it with the following command:
.sp
.nf
.ft C
env SWIG_FEATURES="\-cpperraswarn \-includeall \-D__\(gauname \-m\(ga__ \-I/usr/include/openssl" pip install M2Crypto
.ft P
.fi
.sp
Debian and Ubuntu systems have modified openssl libraries and mandate that
a patched version of M2Crypto be installed. This means that M2Crypto
needs to be installed via apt:
.sp
.nf
.ft C
apt\-get install python\-m2crypto
.ft P
.fi
.sp
This also means that pulling in the M2Crypto installed using apt requires using
\fB\-\-system\-site\-packages\fP when creating the virtualenv.
.RE
.IP Note
Installing psutil
.sp
Python header files are required to build this module, otherwise the pip
install will fail. If your distribution separates binaries and headers into
separate packages, make sure that you have the headers installed. In most
Linux distributions which split the headers into their own package, this
can be done by installing the \fBpython\-dev\fP or \fBpython\-devel\fP package.
For other platforms, the package will likely be similarly named.
.RE
.IP Note
Important note for those developing using RedHat variants
.sp
For developers using a RedHat variant, be advised that the package
provider for newer Redhat\-based systems (\fByumpkg.py\fP) relies on RedHat\(aqs python
interface for yum. The variants that use this module to provide package
support include the following:
.INDENT 0.0
.IP \(bu 2
\fI\%RHEL\fP and \fI\%CentOS\fP releases 6 and later
.IP \(bu 2
\fI\%Fedora Linux\fP releases 11 and later
.IP \(bu 2
\fI\%Amazon Linux\fP
.UNINDENT
.sp
Developers using one of these systems should create the salt virtualenv using the
\fB\-\-system\-site\-packages\fP option to ensure that the correct modules are available.
.RE
.IP Note
Installing dependencies on OS X.
.sp
You can install needed dependencies on OS X using homebrew or macports.
See \fBOS X Installation\fP
.RE
.SS Running a self\-contained development version
.sp
During development it is easiest to be able to run the Salt master and minion
that are installed in the virtualenv you created above, and also to have all
the configuration, log, and cache files contained in the virtualenv as well.
.sp
Copy the master and minion config files into your virtualenv:
.sp
.nf
.ft C
mkdir \-p /path/to/your/virtualenv/etc/salt
cp ./salt/conf/master /path/to/your/virtualenv/etc/salt/master
cp ./salt/conf/minion /path/to/your/virtualenv/etc/salt/minion
.ft P
.fi
.sp
Edit the master config file:
.INDENT 0.0
.IP 1. 3
Uncomment and change the \fBuser: root\fP value to your own user.
.IP 2. 3
Uncomment and change the \fBroot_dir: /\fP value to point to
\fB/path/to/your/virtualenv\fP.
.IP 3. 3
If you are running version 0.11.1 or older, uncomment and change the
\fBpidfile: /var/run/salt\-master.pid\fP value to point to
\fB/path/to/your/virtualenv/salt\-master.pid\fP.
.IP 4. 3
If you are also running a non\-development version of Salt you will have to
change the \fBpublish_port\fP and \fBret_port\fP values as well.
.UNINDENT
.sp
Edit the minion config file:
.INDENT 0.0
.IP 1. 3
Repeat the edits you made in the master config for the \fBuser\fP and
\fBroot_dir\fP values as well as any port changes.
.IP 2. 3
If you are running version 0.11.1 or older, uncomment and change the
\fBpidfile: /var/run/salt\-minion.pid\fP value to point to
\fB/path/to/your/virtualenv/salt\-minion.pid\fP.
.IP 3. 3
Uncomment and change the \fBmaster: salt\fP value to point at \fBlocalhost\fP.
.IP 4. 3
Uncomment and change the \fBid:\fP value to something descriptive like
"saltdev". This isn\(aqt strictly necessary but it will serve as a reminder of
which Salt installation you are working with.
.UNINDENT
.IP Note
Using \fIsalt\-call\fP with a \fBStandalone Minion\fP
.sp
If you plan to run \fIsalt\-call\fP with this self\-contained development
environment in a masterless setup, you should invoke \fIsalt\-call\fP with
\fB\-c /path/to/your/virtualenv/etc/salt\fP so that salt can find the minion
config file. Without the \fB\-c\fP option, Salt finds its config files in
\fI/etc/salt\fP.
.RE
.sp
Start the master and minion, accept the minion\(aqs key, and verify your local Salt
installation is working:
.sp
.nf
.ft C
cd /path/to/your/virtualenv
salt\-master \-c ./etc/salt \-d
salt\-minion \-c ./etc/salt \-d
salt\-key \-c ./etc/salt \-L
salt\-key \-c ./etc/salt \-A
salt \-c ./etc/salt \(aq*\(aq test.ping
.ft P
.fi
.sp
Running the master and minion in debug mode can be helpful when developing. To
do this, add \fB\-l debug\fP to the calls to \fBsalt\-master\fP and \fBsalt\-minion\fP.
If you would like to log to the console instead of to the log file, remove the
\fB\-d\fP.
.sp
Once the minion starts, you may see an error like the following:
.sp
.nf
.ft C
zmq.core.error.ZMQError: ipc path "/path/to/your/virtualenv/var/run/salt/minion/minion_event_7824dcbcfd7a8f6755939af70b96249f_pub.ipc" is longer than 107 characters (sizeof(sockaddr_un.sun_path)).
.ft P
.fi
.sp
This means the the path to the socket the minion is using is too long. This is
a system limitation, so the only workaround is to reduce the length of this
path. This can be done in a couple different ways:
.INDENT 0.0
.IP 1. 3
Create your virtualenv in a path that is short enough.
.IP 2. 3
Edit the \fBsock_dir\fP minion config variable and reduce its
length. Remember that this path is relative to the value you set in
\fBroot_dir\fP.
.UNINDENT
.sp
\fBNOTE:\fP The socket path is limited to 107 characters on Solaris and Linux,
and 103 characters on BSD\-based systems.
.IP Note
File descriptor limits
.sp
Ensure that the system open file limit is raised to at least 2047:
.sp
.nf
.ft C
# check your current limit
ulimit \-n

# raise the limit. persists only until reboot
# use \(aqlimit descriptors 2047\(aq for c\-shell
ulimit \-n 2047
.ft P
.fi
.sp
To set file descriptors on OSX, refer to the \fBOS X Installation\fP instructions.
.RE
.SS Using easy_install to Install Salt
.sp
If you are installing using \fBeasy_install\fP, you will need to define a
\fBUSE_SETUPTOOLS\fP environment variable, otherwise dependencies will not
be installed.
.INDENT 0.0
.INDENT 3.5
$ USE_SETUPTOOLS=1 easy_install salt
.UNINDENT
.UNINDENT
.SS Running the tests
.sp
You will need \fBmock\fP to run the tests:
.sp
.nf
.ft C
pip install mock
.ft P
.fi
.sp
If you are on Python < 2.7 then you will also need unittest2:
.sp
.nf
.ft C
pip install unittest2
.ft P
.fi
.sp
Finally you use setup.py to run the tests with the following command:
.sp
.nf
.ft C
\&./setup.py test
.ft P
.fi
.sp
For greater control while running the tests, please try:
.sp
.nf
.ft C
\&./tests/runtests.py \-h
.ft P
.fi
.SS Editing and previewing the documention
.sp
You need \fBsphinx\-build\fP command to build the docs. In Debian/Ubuntu this is
provided in the \fBpython\-sphinx\fP package. Sphinx can also be installed
to a virtualenv using pip:
.sp
.nf
.ft C
pip install Sphinx
.ft P
.fi
.sp
Change to salt documention directory, then:
.sp
.nf
.ft C
cd doc; make html
.ft P
.fi
.INDENT 0.0
.IP \(bu 2
This will build the HTML docs. Run \fBmake\fP without any arguments to see the
available make targets, which include \fBhtml\fP, \fBman\fP, and
\fBtext\fP.
.IP \(bu 2
The docs then are built within the \fBdocs/_build/\fP folder. To update
the docs after making changes, run \fBmake\fP again.
.IP \(bu 2
The docs use \fI\%reStructuredText\fP for markup.
See a live demo at \fI\%http://rst.ninjs.org/\fP.
.IP \(bu 2
The help information on each module or state is culled from the python code
that runs for that piece. Find them in \fBsalt/modules/\fP or \fBsalt/states/\fP.
.IP \(bu 2
To build the docs on Arch Linux, the \fBpython2\-sphinx\fP package is
required. Additionally, it is necessary to tell \fBmake\fP where to find
the proper \fBsphinx\-build\fP binary, like so:
.sp
.nf
.ft C
make SPHINXBUILD=sphinx\-build2 html
.ft P
.fi
.IP \(bu 2
To build the docs on RHEL/CentOS 6, the \fBpython\-sphinx10\fP package
must be installed from EPEL, and the following make command must be used:
.sp
.nf
.ft C
make SPHINXBUILD=sphinx\-1.0\-build html
.ft P
.fi
.UNINDENT
.SH TARGETING
.INDENT 0.0
.TP
.B Targeting
Specifying which minions should run a command or execute a state by
matching against hostnames, or system information, or defined groups,
or even combinations thereof.
.UNINDENT
.sp
For example the command \fBsalt web1 apache.signal restart\fP to restart the
Apache httpd server specifies the machine \fBweb1\fP as the target and the
command will only be run on that one minion.
.sp
Similarly when using States, the following \fItop file\fP specifies that only
the \fBweb1\fP minion should execute the contents of \fBwebserver.sls\fP:
.sp
.nf
.ft C
base:
  \(aqweb1\(aq:
    \- webserver
.ft P
.fi
.sp
There are many ways to target individual minions or groups of minions in Salt:
.SS Matching the \fBminion id\fP
.INDENT 0.0
.TP
.B minion id
A unique identifier for a given minion. By default the minion id is the
FQDN of that host but this can be overridden.
.UNINDENT
.sp
Each minion needs a unique identifier. By default when a minion starts for the
first time it chooses its FQDN as that
identifier. The minion id can be overridden via the minion\(aqs \fBid\fP
configuration setting.
.IP Tip
minion id and minion keys
.sp
The \fIminion id\fP is used to generate the minion\(aqs public/private keys
and if it ever changes the master must then accept the new key as though
the minion was a new host.
.RE
.SS Globbing
.sp
The default matching that Salt utilizes is \fI\%shell-style globbing\fP around the
\fIminion id\fP. This also works for states in the \fItop file\fP.
.IP Note
You must wrap \fBsalt\fP calls that use globbing in single\-quotes to
prevent the shell from expanding the globs before Salt is invoked.
.RE
.sp
Match all minions:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping
.ft P
.fi
.sp
Match all minions in the example.net domain or any of the example domains:
.sp
.nf
.ft C
salt \(aq*.example.net\(aq test.ping
salt \(aq*.example.*\(aq test.ping
.ft P
.fi
.sp
Match all the \fBwebN\fP minions in the example.net domain
(\fBweb1.example.net\fP, \fBweb2.example.net\fP â€¦ \fBwebN.example.net\fP):
.sp
.nf
.ft C
salt \(aqweb?.example.net\(aq test.ping
.ft P
.fi
.sp
Match the \fBweb1\fP through \fBweb5\fP minions:
.sp
.nf
.ft C
salt \(aqweb[1\-5]\(aq test.ping
.ft P
.fi
.sp
Match the \fBweb\-x\fP, \fBweb\-y\fP, and \fBweb\-z\fP minions:
.sp
.nf
.ft C
salt \(aqweb\-[x\-z]\(aq test.ping
.ft P
.fi
.SS Regular Expressions
.sp
Minions can be matched using Perl\-compatible \fI\%regular expressions\fP (which is
globbing on steroids and a ton of caffeine).
.sp
Match both \fBweb1\-prod\fP and \fBweb1\-devel\fP minions:
.sp
.nf
.ft C
salt \-E \(aqweb1\-(prod|devel)\(aq test.ping
.ft P
.fi
.sp
When using regular expressions in a State\(aqs \fItop file\fP, you must specify
the matcher as the first option. The following example executes the contents of
\fBwebserver.sls\fP on the above\-mentioned minions.
.sp
.nf
.ft C
base:
  \(aqweb1\-(prod|devel)\(aq:
  \- match: pcre
  \- webserver
.ft P
.fi
.SS Lists
.sp
At the most basic level, you can specify a flat list of minion IDs:
.sp
.nf
.ft C
salt \-L \(aqweb1,web2,web3\(aq test.ping
.ft P
.fi
.SS Grains
.sp
Salt comes with an interface to derive information about the underlying system.
This is called the grains interface, because it presents salt with grains of
information.
.INDENT 0.0
.TP
.B Grains
Static bits of information that a minion collects about the system when
the minion first starts.
.UNINDENT
.sp
The grains interface is made available to Salt modules and components so that
the right salt minion commands are automatically available on the right
systems.
.sp
It is important to remember that grains are bits of information loaded when
the salt minion starts, so this information is static. This means that the
information in grains is unchanging, therefore the nature of the data is
static. So grains information are things like the running kernel, or the
operating system.
.sp
Match all CentOS minions:
.sp
.nf
.ft C
salt \-G \(aqos:CentOS\(aq test.ping
.ft P
.fi
.sp
Match all minions with 64\-bit CPUs and return number of available cores:
.sp
.nf
.ft C
salt \-G \(aqcpuarch:x86_64\(aq grains.item num_cpus
.ft P
.fi
.sp
Additionally, globs can be used in grain matches, and grains that are nested in
a dictionary can be matched by adding a colon for each level that is traversed.
For example, the following will match hosts that have a grain called
\fBec2_tags\fP, which itself is a dict with a key named \fBenvironment\fP, which
has a value that contains the word \fBproduction\fP:
.sp
.nf
.ft C
salt \-G \(aqec2_tags:environment:*production*\(aq
.ft P
.fi
.SS Listing Grains
.sp
Available grains can be listed by using the \(aqgrains.ls\(aq module:
.sp
.nf
.ft C
salt \(aq*\(aq grains.ls
.ft P
.fi
.sp
Grains data can be listed by using the \(aqgrains.items\(aq module:
.sp
.nf
.ft C
salt \(aq*\(aq grains.items
.ft P
.fi
.SS Grains in the Minion Config
.sp
Grains can also be statically assigned within the minion configuration file.
Just add the option \fBgrains\fP and pass options to it:
.sp
.nf
.ft C
grains:
  roles:
    \- webserver
    \- memcache
  deployment: datacenter4
  cabinet: 13
  cab_u: 14\-15
.ft P
.fi
.sp
Then status data specific to your servers can be retrieved via Salt, or used
inside of the State system for matching. It also makes targeting, in the case
of the example above, simply based on specific data about your deployment.
.SS Writing Grains
.sp
Grains are easy to write. The grains interface is derived by executing
all of the "public" functions found in the modules located in the grains
package or the custom grains directory. The functions in the modules of
the grains must return a Python \fI\%dict\fP, where the keys in the dict are the
names of the grains and the values are the values.
.sp
Custom grains should be placed in a \fB_grains\fP directory located under the
\fBfile_roots\fP specified by the master config file. They will be
distributed to the minions when \fBstate.highstate\fP is run, or by executing the
\fBsaltutil.sync_grains\fP or
\fBsaltutil.sync_all\fP functions.
.sp
Before adding a grain to Salt, consider what the grain is and remember that
grains need to be static data. If the data is something that is likely to
change, consider using \fBPillar\fP instead.
.SS Examples of Grains
.sp
The core module in the grains package is where the main grains are loaded by
the Salt minion and provides the principal example of how to write grains:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/grains/core.py\fP
.SS Syncing Grains
.sp
Syncing grains can be done a number of ways, they are automatically synced when
state.highstate is called, or the grains can be synced and reloaded by calling
the saltutil.sync_grains or saltutil.sync_all functions.
.SS Node groups
.INDENT 0.0
.TP
.B Node group
A predefined group of minions declared in the master configuration file
\fBnodegroups\fP setting as a compound target.
.UNINDENT
.sp
Nodegroups are declared using a compound target specification. The compound
target documentation can be found here:
.sp
\fBCompound Matchers\fP
.sp
For example, in the master config file \fBnodegroups\fP setting:
.sp
.nf
.ft C
nodegroups:
  group1: \(aqL@foo.domain.com,bar.domain.com,baz.domain.com or bl*.domain.com\(aq
  group2: \(aqG@os:Debian and foo.domain.com\(aq
.ft P
.fi
.sp
Specify a nodegroup via the \fB\-N\fP option at the command\-line:
.sp
.nf
.ft C
salt \-N group1 test.ping
.ft P
.fi
.sp
Specify a nodegroup with \fB\- match: nodegroup\fP in a \fItop file\fP:
.sp
.nf
.ft C
base:
  group1:
    \- match: nodegroup
    \- webserver
.ft P
.fi
.SS Compound matchers
.INDENT 0.0
.TP
.B Compound matcher
A combination of many target definitions that can be combined with
boolean operators.
.UNINDENT
.sp
Compound matchers allow very granular minion targeting using any of the
previously discussed matchers. The default matcher is a \fI\%glob\fP, as usual. For
matching via anything other than glob, preface it with the letter denoting
the match type. The currently implemented "letters" are:
.TS
center;
|l|l|l|.
_
T{
Letter
T}	T{
Meaning
T}	T{
Example
T}
_
T{
G
T}	T{
Grains glob match
T}	T{
\fBG@os:Ubuntu\fP
T}
_
T{
E
T}	T{
PCRE Minion id match
T}	T{
\fBE@web\ed+\e.(dev|qa|prod)\e.loc\fP
T}
_
T{
P
T}	T{
Grains PCRE match
T}	T{
\fBP@os:(RedHat|Fedora|CentOS)\fP
T}
_
T{
L
T}	T{
List of minions
T}	T{
\fBL@minion1.example.com,minion3.domain.com or bl*.domain.com\fP
T}
_
T{
I
T}	T{
Pillar glob match
T}	T{
\fBI@pdata:foobar\fP
T}
_
T{
S
T}	T{
Subnet/IP addr match
T}	T{
\fBS@192.168.1.0/24\fP or \fBS@192.168.1.100\fP
T}
_
T{
R
T}	T{
Range cluster match
T}	T{
\fBR@%foo.bar\fP
T}
_
T{
D
T}	T{
Minion Data match
T}	T{
\fBD@key:value\fP
T}
_
.TE
.sp
Matchers can be joined using boolean \fBand\fP, \fBor\fP, and \fBnot\fP operators.
.sp
For example, the following command matches all minions that have a hostname
that begins with "webserv" and that are running Debian or it matches any
minions that have a hostname that matches the \fI\%regular expression\fP
\fBweb\-dc1\-srv.*\fP:
.sp
.nf
.ft C
salt \-C \(aqwebserv* and G@os:Debian or E@web\-dc1\-srv.*\(aq test.ping
.ft P
.fi
.sp
That same example expressed in a \fItop file\fP looks like the following:
.sp
.nf
.ft C
base:
  \(aqwebserv* and G@os:Debian or E@web\-dc1\-srv.*\(aq:
    \- match: compound
    \- webserver
.ft P
.fi
.sp
Note that you cannot have a leading \fBnot\fP in a command.  Instead you must do
something like the following:
.sp
.nf
.ft C
salt \-C \(aq* and not G@kernel:Darwin\(aq test.ping
.ft P
.fi
.SS Batch Size
.sp
The batch size option allows commands to be executed while maintaining that
only so many hosts are executing the command at one time. This option can
take a percentage or a finite number:
.sp
.nf
.ft C
salt \e* \-b 10 test.ping

salt \-G \(aqos:RedHat\(aq \-\-batch\-size 25% apache.signal restart
.ft P
.fi
.sp
This will only run test.ping on 10 of the targeted minions at a time and then
restart apache on 25% of the minions matching \fBos:RedHat\fP at a time and work
through them all until the task is complete. This makes jobs like rolling web
server restarts behind a load balancer or doing maintenance on BSD firewalls
using carp much easier with salt.
.sp
The batch system maintains a window of running minions, so, if there are a
total of 150 minions targeted and the batch size is 10, then the command is
sent to 10 minions, when one minion returns then the command is sent to one
additional minion, so that the job is constantly running on 10 minions.
.SH SALT TUTORIALS
.SS Bootstrapping Salt on Linux EC2 with Cloud\-Init
.sp
\fI\%Salt\fP is a great tool for remote execution and
configuration management, however you will still need to bootstrap the
daemon when spinning up a new node. One option is to create and save a
custom \fI\%AMI\fP, but this creates another resource to maintain and document.
.sp
A better method for Linux machines uses Canonical\(aqs \fI\%CloudInit\fP to run a bootstrap script
during an \fI\%EC2 Instance\fP initialization. Cloud\-init takes the \fBuser_data\fP
string passed into a new AWS instance and runs it in a manner similar to
rc.local. The bootstrap script needs to:
.INDENT 0.0
.IP 1. 3
Install \fI\%Salt\fP with dependencies
.IP 2. 3
Point the minion to the master
.UNINDENT
.sp
Here is a sample script:
.sp
.nf
.ft C
#!/bin/bash

# Install saltstack
add\-apt\-repository ppa:saltstack/salt \-y
apt\-get update \-y
apt\-get install salt\-minion \-y
apt\-get install salt\-master \-y
apt\-get upgrade \-y

# Set salt master location and start minion
sed \-i \(aqs/#master: salt/master: [salt_master_fqdn]/\(aq /etc/salt/minion
salt\-minion \-d
.ft P
.fi
.sp
First the script adds the saltstack ppa and installs the package. Then
we copy over the minion config template and tell it where to find the
master. You will have to replace \fB[salt_master_fqdn]\fP with something
that resolves to your Salt master.
.SS Used With Boto
.sp
\fI\%Boto\fP will accept a string for user data
which can be used to pass our bootstrap script. If the script is saved to
a file, you can read it into a string:
.sp
.nf
.ft C
import boto

user_data = open(\(aqsalt_bootstrap.sh\(aq)

conn = boto.connect_ec2(<AWS_ACCESS_ID>, <AWS_SECRET_KEY>)

reservation = conn.run_instances(image_id=<ami_id>,
                                 key_name=<key_name>,
                                 user_data=user_data.read())
.ft P
.fi
.SS Additional Notes
.sp
Sometime in the future the ppa will include and install an upstart file. In the
meantime, you can use the bootstrap to \fI\%build one\fP.
.sp
It may also be useful to set the node\(aqs role during this phase. One option
would be saving the node\(aqs role to a file and then using a custom Grain
to select it.
.SS Salt as a Cloud Controller
.sp
In Salt 0.14.0 advanced cloud control systems were introduced, allowing for
private cloud vms to be managed directly with Salt. This system is generally
referred to as "Salt Virt".
.sp
The Salt Virt system already exists and is installed within Salt itself, this
means that beyond setting up Salt no additional salt code needs to be deployed.
.SS Setting up Hypervisors
.sp
The first step to set up the hypervisors involves getting the correct software
installed and setting up the hypervisor network interfaces.
.SS Installing Hypervisor Software
.sp
Salt Virt is made to be hypervisor agnostic, but currently the only
implemented hypervisor is KVM via libvirt.
.sp
The required software for a hypervisor is libvirt and kvm. For advanced
features install libguestfs or qemu\-nbd.
.IP Note
Libguestfs and qemu\-nbd allow for virtual machine images to be mounted
before startup and get pre\-seeded with configurations and a salt minion
.RE
.sp
A simple sls formula to deploy the required software and service:
.IP Note
Package names used are Red Hat specific, different package names will be
required for different platforms
.RE
.sp
.nf
.ft C
libguestfs:
  pkg.installed

qemu\-kvm:
  pkg.installed

libvirt:
  pkg.installed

libvirtd:
  service.running:
    \- enable: True
    \- watch:
      \- pkg: libvirt
.ft P
.fi
.SS Network Setup
.sp
Salt virt comes with a system to model the network interfaces used by the
deployed virtual machines, by default a single interface is created for the
deployed virtual machine and is bridged to \fIbr0\fP. To get going with the default
networking setup ensure that the bridge interface named \fIbr0\fP exists on the
hypervisor and is bridged to an active network device.
.IP Note
To use more advanced networking in Salt Virt read the \fISalt Virt
Networking\fP document:
.sp
\fISalt Virt Networking <topics/virt/nic>\fP
.RE
.SS Libvirt State
.sp
One of the challanges of deploying a libvirt based cloud is the distribution
of libvirt certificates. These certificates allow for virtual machine
migration. Salt comes with a system used to auto deploy these certificates.
Salt manages the signing authority key and generates keys for libvirt clients
on the master, signs them with the certificate authority and uses pillar to
distrbute them. This is managed via the \fBlibvirt\fP state. Simply execute this
formula on the minion to ensure that the certificate is in place and up to
date:
.sp
.nf
.ft C
libvirt_keys:
  libvirt.keys
.ft P
.fi
.SS Getting Virtual Machine Images Ready
.sp
Salt Virt, requires that virtual machine images be provided as these are not
generated on the fly. Generating these virtual machine images differs greatly
based on the underlying platform.
.sp
Virtual machine images can be manually created using KVM and running through
the installer, but this process is not recommended since it is very manual and
prone to errors.
.sp
Virtual Machine generation applications are avilable for many platforms:
.INDENT 0.0
.TP
.B vm\-builder:
\fI\%http://wiki.debian.org/VMBuilder\fP
.UNINDENT
.SS Using Salt Virt
.sp
With hypervisors set up and virtual machine images ready, Salt can start
issuing cloud commands.
.sp
Start by deploying
.SS Using cron with Salt
.sp
The Salt Minion can initiate its own highstate using the \fIsalt\-call\fP command.
.sp
.nf
.ft C
$ salt\-call state.highstate
.ft P
.fi
.sp
This will cause the minion to check in with the master and ensure it is in the
correct \(aqstate\(aq.
.SS Use cron to initiate a highstate
.sp
If you would like the Salt Minion to regularly check in with the master you can
use the venerable cron to run the \fIsalt\-call\fP command.
.sp
.nf
.ft C
# PATH=/bin:/sbin:/usr/bin:/usr/sbin

00 00 * * * salt\-call state.highstate
.ft P
.fi
.sp
The above cron entry will run a highstate every day at midnight.
.IP Note
Be aware that you may need to ensure the PATH for cron includes any
scripts or commands that need to be executed.
.RE
.SS Automatic Updates / Frozen Deployments
.sp
New in version 0.10.3.d.
.sp
Salt has support for the
\fI\%Esky\fP application freezing and update
tool. This tool allows one to build a complete zipfile out of the salt scripts
and all their dependencies \- including shared objects / DLLs.
.SS Getting Started
.sp
To build frozen applications, you\(aqll need a suitable build environment for each
of your platforms. You should probably set up a virtualenv in order to limit
the scope of Q/A.
.sp
This process does work on Windows. Follow the directions at
\fI\%https://github.com/saltstack/salt-windows-install\fP for details on
installing Salt in Windows. Only the 32\-bit Python and dependencies have been
tested, but they have been tested on 64\-bit Windows.
.sp
You will need to install \fBesky\fP and \fBbbfreeze\fP from Pypi in order to enable
the \fBbdist_esky\fP command in \fBsetup.py\fP.
.SS Building and Freezing
.sp
Once you have your tools installed and the environment configured, you can then
\fBpython setup.py bdist\fP to get the eggs prepared. After that is done, run
\fBpython setup.py bdist_esky\fP to have Esky traverse the module tree and pack
all the scripts up into a redistributable. There will be an appropriately
versioned \fBsalt\-VERSION.zip\fP in \fBdist/\fP if everything went smoothly.
.SS Windows
.sp
You will need to add \fBC:\ePython27\elib\esite\-packages\ezmq\fP to your PATH
variable. This helps bbfreeze find the zmq dll so it can pack it up.
.SS Using the Frozen Build
.sp
Unpack the zip file in your desired install location. Scripts like
\fBsalt\-minion\fP and \fBsalt\-call\fP will be in the root of the zip file. The
associated libraries and bootstrapping will be in the directories at the same
level. (Check the \fI\%Esky\fP documentation
for more information)
.sp
To support updating your minions in the wild, put your builds on a web server
that your minions can reach. \fBsalt.modules.saltutil.update()\fP will
trigger an update and (optionally) a restart of the minion service under the
new version.
.SS Gotchas
.SS My Windows minion isn\(aqt responding
.sp
The process dispatch on Windows is slower than it is on *nix. You may need to
add \(aq\-t 15\(aq to your salt calls to give them plenty of time to return.
.SS Windows and the Visual Studio Redist
.sp
You will need to install the Visual C++ 2008 32\-bit redistributable on all
Windows minions. Esky has an option to pack the library into the zipfile,
but OpenSSL does not seem to acknowledge the new location. If you get a
\fBno OPENSSL_Applink\fP error on the console when trying to start your
frozen minion, you have forgotten to install the redistributable.
.SS Mixed Linux environments and Yum
.sp
The Yum Python module doesn\(aqt appear to be available on any of the standard
Python package mirrors. If you need to support RHEL/CentOS systems, you
should build on that platform to support all your Linux nodes. Also remember
to build your virtualenv with \fB\-\-system\-site\-packages\fP so that the
\fByum\fP module is included.
.SS Automatic (Python) module discovery
.sp
Automatic (Python) module discovery does not work with the late\-loaded scheme that
Salt uses for (Salt) modules. You will need to explicitly add any
misbehaving modules to the \fBfreezer_includes\fP in Salt\(aqs \fBsetup.py\fP.
Always check the zipped application to make sure that the necessary modules
were included.
.SS Opening the Firewall up for Salt
.sp
The Salt master communicates with the minions using an AES\-encrypted ZeroMQ
connection. These communications are done over ports 4505 and 4506, which need
to be accessible on the master only. This document outlines suggested firewall
rules for allowing these incoming connections to the master.
.IP Note
\fBNo firewall configuration needs to be done on Salt minions. These changes
refer to the master only.\fP
.RE
.SS RHEL 6 / CENTOS 6
.sp
The lokkit command packaged with some Linux distributions makes opening
iptables firewall ports very simple via the command line. Just be careful
to not lock out access to the server by neglecting to open the ssh
port.
.sp
\fBlokkit example\fP
.sp
.nf
.ft C
lokkit \-p 22:tcp \-p 4505:tcp \-p 4506:tcp
.ft P
.fi
.sp
The system\-config\-firewall\-tui command provides a text\-based interface to modifying
the firewall.
.sp
\fBsystem\-config\-firewall\-tui\fP
.sp
.nf
.ft C
system\-config\-firewall\-tui
.ft P
.fi
.SS iptables
.sp
Different Linux distributions store their \fI\%iptables\fP rules in different places,
which makes it difficult to standardize firewall documentation. Included are
some of the more common locations, but your mileage may vary.
.sp
\fBFedora / RHEL / CentOS\fP
.sp
.nf
.ft C
/etc/sysconfig/iptables
.ft P
.fi
.sp
\fBArch Linux\fP
.sp
.nf
.ft C
/etc/iptables/iptables.rules
.ft P
.fi
.sp
\fBDebian\fP
.sp
Follow these instructions: \fI\%http://wiki.debian.org/iptables\fP
.sp
Once you\(aqve found your firewall rules, you\(aqll need to add the two lines below
to allow traffic on \fBtcp/4505\fP and \fBtcp/4506\fP:
.sp
.nf
.ft C
\-A INPUT \-m state \-\-state new \-m tcp \-p tcp \-\-dport 4505 \-j ACCEPT
\-A INPUT \-m state \-\-state new \-m tcp \-p tcp \-\-dport 4506 \-j ACCEPT
.ft P
.fi
.sp
\fBUbuntu\fP
.sp
Salt installs firewall rules in \fI\%/etc/ufw/applications.d/salt.ufw\fP. Enable with:
.sp
.nf
.ft C
ufw allow salt
.ft P
.fi
.SS pf.conf
.sp
The BSD\-family of operating systems uses \fI\%packet filter (pf)\fP. The following
example describes the additions to \fBpf.conf\fP needed to access the Salt
master.
.sp
.nf
.ft C
pass in on $int_if proto tcp from any to $int_if port 4505
pass in on $int_if proto tcp from any to $int_if port 4506
.ft P
.fi
.sp
Once these additions have been made to the \fBpf.conf\fP the rules will need to
be reloaded. This can be done using the \fBpfctl\fP command.
.sp
.nf
.ft C
pfctl \-vf /etc/pf.conf
.ft P
.fi
.SS GitFS Backend Walkthrough
.sp
While the default location of the salt state tree is on the Salt master,
in /srv/salt, the master can create a bridge to external resources for files.
One of these resources is the ability for the master to directly pull files
from a git repository and serve them to minions.
.IP Note
This walkthrough assumes basic knowledge of Salt:
.INDENT 0.0
.INDENT 3.5
\fBWalkthrough\fP
.UNINDENT
.UNINDENT
.sp
And a basic knowledge of file roots:
.INDENT 0.0
.INDENT 3.5
\fBFile Roots\fP
.UNINDENT
.UNINDENT
.RE
.sp
The gitfs backend hooks into any number of remote git repositories and caches
the data from the repository on the master. This makes distributing a state
tree to multiple masters seamless and automated.
.sp
Salt\(aqs file server also has a concept of environments, when using the gitfs
backend, Salt translates git branches and tags into environments, making
environment management very simple. Just merging a QA or staging branch up
to a production branch can be all that is required to make those file changes
available to Salt.
.SS Simple Configuration
.sp
To use the gitfs backend only two configuration changes are required on the
master. The \fBfileserver_backend\fP option needs to be set with \fIgit\fP:
.sp
.nf
.ft C
fileserver_backend:
  \- git
.ft P
.fi
.sp
To configure what fileserver backends will be searched for requested files.
.sp
Now the gitfs system needs to be configured with a remote:
.sp
.nf
.ft C
gitfs_remotes:
  \- git://github.com/saltstack/salt\-states.git
.ft P
.fi
.sp
These changes require a restart of the master, then the git repo will be cached
on the master and new requests for the \fIsalt://\fP protocol will send files found
in the remote git repository via the master.
.IP Note
The master caches the files from the git server and serves them out,
minions do not connect directly to the git server meaning that only
requested files are delivered to minions.
.RE
.SS Multiple Remotes
.sp
The \fBgitfs_remotes\fP option can accept a list of git remotes, the remotes are
then searched in order for the requested file. A simple scenario can illustrate
this behavior.
.sp
Assuming that the \fBgitfs_remotes\fP option specifies three remotes:
.sp
.nf
.ft C
gitfs_remotes:
  \- git://github.com/example/first.git
  \- git://github.com/example/second.git
  \- file:///root/third
.ft P
.fi
.IP Note
This example is purposefully contrived to illustrate the behavior of the
gitfs backend. This example should not be read as a recommended way to lay
out files and git repos.
.RE
.IP Note
The \fBfile://\fP prefix denotes a git repository in a local directory.
However, it will still use the given \fBfile://\fP URL as a remote, rather
than copying the git repo to the salt cache.  This means that any refs you
want accessible must exist as \fIlocal\fP refs in the specified repo.
.RE
.sp
Assume that each repository contains some files:
.INDENT 0.0
.TP
.B first.git:
top.sls
edit/vim.sls
edit/vimrc
nginx/init.sls
.TP
.B second.git:
edit/dev_vimrc
haproxy/init.sls
.TP
.B third:
haproxy/haproxy.conf
edit/dev_vimrc
.UNINDENT
.sp
The repositories will be searched for files by the master in the order in which
they are defined in the configuration, Therefore the remote
\fIgit://github.com/example/first.git\fP will be searched first, if the requested
file is found then it is served and no further searching is executed. This
means that if the file \fIsalt://haproxy/init.sls\fP is requested then it will be
pulled from the \fIgit://github.com/example/second.git\fP git repo. If
\fIsalt://haproxy/haproxy.conf\fP is requested then it will be pulled from the
third repo.
.SS Multiple Backends
.sp
Sometimes it may make sense to use multiple backends. For instance, if sls
files are stored in git, but larger files need to be stored directly on the
master.
.sp
The logic used for multiple remotes is also used for multiple backends. If
the \fBfileserver_backend\fP option contains multiple backends:
.sp
.nf
.ft C
fileserver_backend:
  \- roots
  \- git
.ft P
.fi
.sp
Then the \fIroots\fP backend (the default backend of files in /srv/salt) will be
searched first for the requested file, then if it is not found on the master
the git remotes will be searched.
.SS GitFS Remotes over SSH
.sp
In order to configure a \fBgitfs_remotes\fP repository over SSH transport the
\fBgit+ssh\fP URL form must be used.
.sp
.nf
.ft C
gitfs_remotes:
  \- git+ssh://git@github.com/example/salt\-states.git
.ft P
.fi
.sp
The private key used to connect to the repository must be located in \fB~/.ssh/id_rsa\fP
for the user running the salt\-master.
.IP Note
GitFS requires library \fBgitpython\fP > 0.3.0.
.RE
.SS Remote execution tutorial
.sp
\fBBefore continuing\fP make sure you have a working Salt installation by
following the \fBinstallation\fP and the \fBconfiguration\fP instructions.
.IP "Stuck?"
.sp
There are many ways to \fBget help from the Salt community\fP including our
\fI\%mailing list\fP
and our \fI\%IRC channel\fP #salt.
.RE
.SS Order your minions around
.sp
Now that you have a \fImaster\fP and at least one \fIminion\fP
communicating with each other you can perform commands on the minion via the
\fBsalt\fP command. Salt calls are comprised of three main components:
.sp
.nf
.ft C
salt \(aq<target>\(aq <function> [arguments]
.ft P
.fi
.IP "See also"
.sp
\fBsalt manpage\fP
.RE
.SS target
.sp
The target component allows you to filter which minions should run the
following function. The default filter is a glob on the minion id. For example:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping
salt \(aq*.example.org\(aq test.ping
.ft P
.fi
.sp
Targets can be based on minion system information using the Grains system:
.sp
.nf
.ft C
salt \-G \(aqos:Ubuntu\(aq test.ping
.ft P
.fi
.IP "See also"
.sp
\fBGrains system\fP
.RE
.sp
Targets can be filtered by regular expression:
.sp
.nf
.ft C
salt \-E \(aqvirtmach[0\-9]\(aq test.ping
.ft P
.fi
.sp
Targets can be explicitly specified in a list:
.sp
.nf
.ft C
salt \-L \(aqfoo,bar,baz,quo\(aq test.ping
.ft P
.fi
.sp
Or Multiple target types can be combined in one command:
.sp
.nf
.ft C
salt \-C \(aqG@os:Ubuntu and webser* or E@database.*\(aq test.ping
.ft P
.fi
.SS function
.sp
A function is some functionality provided by a module. Salt ships with a large
collection of available functions. List all available functions on your
minions:
.sp
.nf
.ft C
salt \(aq*\(aq sys.doc
.ft P
.fi
.sp
Here are some examples:
.sp
Show all currently available minions:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping
.ft P
.fi
.sp
Run an arbitrary shell command:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run \(aquname \-a\(aq
.ft P
.fi
.IP "See also"
.sp
\fBthe full list of modules\fP
.RE
.SS arguments
.sp
Space\-delimited arguments to the function:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.exec_code python \(aqimport sys; print sys.version\(aq
.ft P
.fi
.sp
Optional, keyword arguments are also supported:
.sp
.nf
.ft C
salt \(aq*\(aq pip.install salt timeout=5 upgrade=True
.ft P
.fi
.sp
They are always in the form of \fBkwarg=argument\fP.
.SS Multi Master Tutorial
.sp
As of Salt 0.16.0, the ability to connect minions to multiple masters has been
made available. The multi\-master system allows for redundancy of Salt
masters and facilitates multiple points of communication out to minions. When
using a multi\-master setup, all masters are running hot, and any active master
can be used to send commands out to the minions.
.sp
In 0.16.0, the masters do not share any information, keys need to be accepted on
both masters, and shared files need to be shared manually or use tools like the
git fileserver backend to ensure that the \fBfile_roots\fP are kept consistent.
.SS Summary of Steps
.INDENT 0.0
.IP 1. 3
Create a redundant master server
.IP 2. 3
Copy primary master key to redundant master
.IP 3. 3
Start redundant master
.IP 4. 3
Configure minions to connect to redundant master
.IP 5. 3
Restart minions
.IP 6. 3
Accept keys on redundant master
.UNINDENT
.SS Prepping a Redundant Master
.sp
The first task is to prepare the redundant master. There is only one
requirement when preparing a redundant master, which is that masters share the
same private key. When the first master was created, the master\(aqs identifying
key was generated and placed in the master\(aqs \fBpki_dir\fP. The default location
of the key is \fI/etc/salt/pki/master/master.pem\fP. Take this key and copy it to
the same location on the redundant master. Assuming that no minions have yet
been connected to the new redundant master, it is safe to delete any existing
key in this location and replace it.
.IP Note
There is no logical limit to the number of redundant masters that can be
used.
.RE
.sp
Once the new key is in place, the redundant master can be safely started.
.SS Configure Minions
.sp
Since minions need to be master\-aware, the new master needs to be added to the
minion configurations. Simply update the minion configurations to list all
connected masters:
.sp
.nf
.ft C
master:
  \- saltmaster1.example.com
  \- saltmaster2.example.com
.ft P
.fi
.sp
Now the minion can be safely restarted.
.sp
Now the minions will check into the original master and also check into the new
redundant master. Both masters are first\-class and have rights to the minions.
.SS Sharing Files Between Masters
.sp
Salt does not automatically share files between multiple masters. A number of
files should be shared or sharing of these files should be strongly considered.
.SS Minion Keys
.sp
Minion keys can be accepted the normal way using \fIsalt\-key\fP on both masters.
Keys accepted, deleted, or rejected on one master will NOT be automatically
managed on redundant masters; this needs to be taken care of by running
salt\-key on both masters or sharing the
\fI/etc/salt/pki/master/{minions,minions_pre,minions_rejected}\fP directories
between masters.
.IP Note
While sharing the \fI/etc/salt/pki/master\fP directory will work, it is
strongly discouraged, since allowing access to the \fImaster.pem\fP key outside
of Salt creates are \fISERIOUS\fP security risk.
.RE
.SS File_Roots
.sp
The \fIfile_roots\fP contents should be kept consistent between masters. Otherwise
state runs will not always be consistent on minions since instructions managed
by one master will not agree with other masters.
.sp
The recommended way to sync these is to use a fileserver backend like gitfs or
to keep these files on shared storage.
.SS Pillar_Roots
.sp
Pillar roots should be given the same considerations as \fIfile_roots\fP.
.SS Master Configurations
.sp
While reasons may exist to maintain separate master configurations, it is wise
to remember that each master maintains independent control over minions.
Therefore, access controls should be in sync between masters unless a valid
reason otherwise exists to keep them inconsistent.
.sp
These access control options include but are not limited to:
.INDENT 0.0
.IP 1. 3
\fIexternal_auth\fP
.IP 2. 3
\fIclient_acl\fP
.IP 3. 3
\fIpeer\fP
.IP 4. 3
\fIpeer_run\fP
.UNINDENT
.SS Pillar Walkthrough
.IP Note
This walkthrough assumes that the reader has already completed the initial
Salt Stack walkthrough:
.INDENT 0.0
.INDENT 3.5
\fBWalkthrough\fP
.UNINDENT
.UNINDENT
.RE
.sp
The pillar interface inside of Salt is one of the most important components
of a Salt deployment. Pillar is the interface used to generate arbitrary data
for specific minions. The data generated in pillar is made available to almost
every component of Salt and is used for a number of purposes:
.INDENT 0.0
.TP
.B Highly Sensitive Data:
Information transferred via pillar is guaranteed to only be presented to the
minions that are targeted, this makes pillar the engine to use in Salt for
managing security information, such as cryptographic keys and passwords.
.TP
.B Minion Configuration:
Minion modules such as the execution modules, states, and returners can
often be configured via data stored in pillar.
.TP
.B Variables:
Variables which need to be assigned to specific minions or groups of
minions can be defined in pillar and then accessed inside sls formulas
and template files.
.TP
.B Arbitrary Data:
Pillar can contain any basic data structure, so a list of values, or a
key/value store can be defined making it easy to iterate over a group
of values in sls formulas
.UNINDENT
.sp
Pillar is therefore one of the most important systems when using Salt, this
walkthrough is designed to get a simple pillar up and running in a few minutes
and then to dive into the capabilities of pillar and where the data is
available.
.SS Setting Up Pillar
.sp
The pillar is already running in Salt by default. The data in the minion\(aqs
pillars can be seen via the following command:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq pillar.data
.UNINDENT
.UNINDENT
.sp
By default the contents of the master configuration file are loaded into
pillar for all minions, this is to enable the master configuration file to
be used for global configuration of minions.
.sp
The pillar is built in a similar fashion as the state tree, it is comprised
of sls files and has a top file, just like the state tree. The pillar is stored
in a different location on the Salt master than the state tree. The default
location for the pillar is in /srv/pillar.
.IP Note
The pillar location can be configured via the \fIpillar_roots\fP option inside
the master configuration file.
.RE
.sp
To start setting up the pillar, the /srv/pillar directory needs to be present:
.INDENT 0.0
.INDENT 3.5
# mkdir /srv/pillar
.UNINDENT
.UNINDENT
.sp
Now a simple top file, following the same format as the top file used for
states needs to be created:
.sp
\fI/srv/pillar/top.sls\fP
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- data
.ft P
.fi
.sp
This top file associates the data.sls file to all minions. Now the
\fI/srv/pillar/data.sls\fP file needs to be populated:
.sp
\fI/srv/pillar/data.sls\fP
.sp
.nf
.ft C
info: some data
.ft P
.fi
.sp
Now that the file has been saved the minions\(aq pillars will be updated:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq pillar.data
.UNINDENT
.UNINDENT
.sp
The key \fIinfo\fP should now appear in the returned pillar data.
.SS More Complex Data
.sp
Pillar files are sls files, just like states, but unlike states they do not
need to define \fIformulas\fP, the data can be arbitrary, this example for
instance sets up user data with a UID:
.sp
\fI/srv/pillar/users/init.sls\fP
.sp
.nf
.ft C
users:
  thatch: 1000
  shouse: 1001
  utahdave: 1002
  redbeard: 1003
.ft P
.fi
.IP Note
The same directory lookups that exist in states exist in pillar, so the
file users/init.sls can be referenced with \fIusers\fP in the top file
.RE
.sp
The top file will need to be updated to include this sls file:
.sp
\fI/srv/pillar/top.sls\fP
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- data
    \- users
.ft P
.fi
.sp
Now the data will be available to the minions. To use the pillar data in a
state just access the pillar via Jinja:
.sp
\fI/srv/salt/users/init.sls\fP
.sp
.nf
.ft C
{% for user, uid in pillar.get(\(aqusers\(aq, {}).items() %}
{{user}}:
  user.present:
    \- uid: {{uid}}
{% endfor %}
.ft P
.fi
.sp
This approach allows for users to be safely defined in a pillar and then the
user data is applied in an sls file.
.SS Paramaterizing States With Pillar
.sp
One of the most powerful abstractions in pillar is the ability to parameterize
states. Instead of defining macros or functions within the state context the
entire state tree can be freely parameterized relative to the minion\(aqs pillar.
.sp
This approach allows for Salt to be very flexible while staying very
straightforward. It also means that simple sls formulas used in the state tree
can be directly parameterized without needing to refactor the state tree.
.sp
A simple example is to set up a mapping of package names in pillar for
separate Linux distributions:
.sp
\fI/srv/pillar/pkg/init.sls\fP
.sp
.nf
.ft C
pkgs:
  {% if grains[\(aqos_family\(aq] == \(aqRedHat\(aq %}
  apache: httpd
  vim: vim\-enhanced
  {% elif grains[\(aqos_family\(aq] == \(aqDebian\(aq %}
  apache: apache2
  vim: vim
  {% elif grains[\(aqos\(aq] == \(aqArch\(aq %}
  apache: apache
  vim: vim
  {% endif %}
.ft P
.fi
.sp
The new \fIpkg\fP sls needs to be added to the top file:
.sp
\fI/srv/pillar/top.sls\fP
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- data
    \- users
    \- pkg
.ft P
.fi
.sp
Now the minions will auto map values based on respective operating systems
inside of the pillar, so sls files can be safely parameterized:
.sp
\fI/srv/salt/apache/init.sls\fP
.sp
.nf
.ft C
apache:
  pkg.installed:
    \- name: {{ pillar[\(aqpkgs\(aq][\(aqapache\(aq] }}
.ft P
.fi
.sp
Or, if no pillar is available a default can be set as well:
.IP Note
The function \fBpillar.get\fP used in this example was added to Salt in
version 0.14.0
.RE
.sp
\fI/srv/salt/apache/init.sls\fP
.sp
.nf
.ft C
apache:
  pkg.installed:
    \- name: {{ salt[\(aqpillar.get\(aq](\(aqpkgs:apache\(aq, \(aqhttpd\(aq) }}
.ft P
.fi
.sp
In the above example, if the pillar value \fIpillar[\(aqpkgs\(aq][\(aqapache\(aq]\fP is not
set in the minion\(aqs pillar, then the default of \(aqhttpd\(aq will be used.
.SS Pillar Makes Simple States Grow Easily
.sp
One of the design goals of pillar is to make simple sls formulas easily grow
into more flexible formulas without refactoring or complicating the states.
.sp
A simple formula:
.sp
\fI/srv/salt/edit/vim.sls\fP
.sp
.nf
.ft C
vim:
  pkg:
    \- installed

/etc/vimrc:
  file.managed:
    \- source: salt://edit/vimrc
    \- mode: 644
    \- user: root
    \- group: root
    \- require:
      \- pkg: vim
.ft P
.fi
.sp
Can be easily transformed into a powerful, parameterized formula:
.sp
\fI/srv/salt/edit/vim.sls\fP
.sp
.nf
.ft C
vim:
  pkg:
    \- installed
    \- name: {{ pillar[\(aqpkgs\(aq][\(aqvim\(aq] }}

/etc/vimrc:
  file.managed:
    \- source: {{ pillar[\(aqvimrc\(aq] }}
    \- mode: 644
    \- user: root
    \- group: root
    \- require:
      \- pkg: vim
.ft P
.fi
.sp
Where the vimrc source location can now be changed via pillar:
.sp
\fI/srv/pillar/edit/vim.sls\fP
.sp
.nf
.ft C
{% if grain[\(aqid\(aq].startswith(\(aqdev\(aq) %}
vimrc: salt://edit/dev_vimrc
{% elif grain[\(aqid\(aq].startswith(\(aqqa\(aq) %}
vimrc: salt://edit/qa_vimrc
{% else %}
vimrc: salt://edit/vimrc
{% endif %}
.ft P
.fi
.sp
Ensuring that the right vimrc is sent out to the correct minions.
.SS More On Pillar
.sp
The pillar data is generated on the Salt master and securely distributed to
minions. Salt is not restricted to the pillar sls files when defining the
pillar but can retrieve data from external sources. This can be useful when
information about an infrastructure is stored in a separate location.
.sp
Reference information on pillar and the external pillar interface can be found
in the Salt Stack documentation:
.sp
\fBPillar\fP
.SS Preseed Minion with Accepted Key
.sp
In some situations, it is not convenient to wait for a minion to start before
accepting its key on the master. For instance, you may want the minion to
bootstrap itself as soon as it comes online. You may also want to to let your
developers provision new development machines on the fly.
.sp
There is a general four step process to do this:
.INDENT 0.0
.IP 1. 3
Generate the keys on the master:
.sp
.nf
.ft C
root@saltmaster# salt\-key \-\-gen\-keys=[key_name]
.ft P
.fi
.UNINDENT
.sp
Pick a name for the key, such as the minion\(aqs id.
.INDENT 0.0
.IP 2. 3
Add the public key to the accepted minion folder:
.sp
.nf
.ft C
root@saltmaster# cp key_name.pub /etc/salt/pki/master/minions/[minion_id]
.ft P
.fi
.UNINDENT
.sp
It is necessary that the public key file has the same name as your minion id.
This is how Salt matches minions with their keys. Also note that the pki folder
could be in a different location, depending on your OS or if specified in the
master config file.
.INDENT 0.0
.IP 3. 3
Distribute the minion keys.
.UNINDENT
.sp
There is no single method to get the keypair to your minion. If you are
spooling up minions on EC2, you could pass them in using user_data or a
cloud\-init script. If you are handing them off to a team of developers for provisioning dev machines, you will need a secure file transfer.
.IP "Security Warning"
.sp
Since the minion key is already accepted on the master, distributing
the private key poses a potential security risk. A malicious party
will have access to your entire state tree and other sensitive data.
.RE
.INDENT 0.0
.IP 4. 3
Preseed the Minion with the keys
.UNINDENT
.sp
You will want to place the minion keys before starting the salt\-minion daemon:
.sp
.nf
.ft C
/etc/salt/pki/minion/minion.pem
/etc/salt/pki/minion/minion.pub
.ft P
.fi
.sp
Once in place, you should be able to start salt\-minion and run
\fBsalt\-call state.highstate\fP or any other salt commands that require master
authentication.
.SS Salt Masterless Quickstart
.sp
Running a masterless salt\-minion lets you use salt\(aqs configuration management
for a single machine. It is also useful for testing out state trees before
deploying to a production setup.
.sp
The only real difference in using a standalone minion is that instead of issuing
commands with \fBsalt\fP, we use the \fBsalt\-call\fP command, like this:
.sp
.nf
.ft C
salt\-call \-\-local state.highstate
.ft P
.fi
.SS Bootstrap Salt Minion
.sp
First we need to install the salt minion. The \fI\%salt-bootstrap\fP script makes
this incredibly easy for any OS with a Bourne shell. You can use it like this:
.sp
.nf
.ft C
wget \-O \- http://bootstrap.saltstack.org | sudo sh
.ft P
.fi
.sp
Or see the \fI\%salt-bootstrap\fP documentation for other one liners. Additionally,
if you are using \fI\%Vagrant\fP to test out salt, the \fI\%salty-vagrant\fP tool will
provision the VM for you.
.SS Create State Tree
.sp
Now we build an example state tree. This is where the configuration
is defined. For more in depth directions, see the \fI\%tutorial\fP.
.sp
1. Create the top.sls file
.sp
.nf
.ft C
# /srv/salt/top.sls
base:
  \(aq*\(aq:
    \- webserver
.ft P
.fi
.sp
2. Create our webserver state tree
.sp
.nf
.ft C
# /srv/salt/webserver.sls
apache:                 # ID declaration
  pkg:                  # state declaration
    \- installed         # function declaration
.ft P
.fi
.sp
The only thing left is to provision our minion using the highstate command.
Salt\-call also gives us an easy way to give us verbose output:
.sp
.nf
.ft C
salt\-call \-\-local state.highstate \-l debug
.ft P
.fi
.sp
The \fB\-\-local\fP flag tells the salt\-minion to look for the state tree in the local file system.
Normally the minion copies the state tree from the master and executes it from there.
.sp
That\(aqs it, good luck!
.SS Standalone Minion
.sp
Since the Salt minion contains such extensive functionality it can be useful
to run it standalone. A standalone minion can be used to do a number of
things:
.INDENT 0.0
.IP \(bu 2
Stand up a master server via States (Salting a Salt Master)
.IP \(bu 2
Use salt\-call commands on a system without connectivity to a master
.IP \(bu 2
Masterless States, run states entirely from files local to the minion
.UNINDENT
.SS Telling Salt Call to Run Masterless
.sp
The salt\-call command is used to run module functions locally on a minion
instead of executing them from the master. Normally the salt\-call command
checks into the master to retrieve file server and pillar data, but when running
standalone salt\-call needs to be instructed to not check the master for this
data. To instruct the minion to not look for a master when running salt\-call
the \fBfile_client\fP configuration option needs to be set. By default the
\fBfile_client\fP is set to \fBremote\fP so that the minion knows that file server
and pillar data are to be gathered from the master. When setting the
\fBfile_client\fP option to \fBlocal\fP the minion is configured to not gather
this data from the master.
.sp
.nf
.ft C
file_client: local
.ft P
.fi
.sp
Now the salt\-call command will not look for a master and will assume that the
local system has all of the file ad pillar resources.
.SS Running States Masterless
.sp
The state system can be easily run without a Salt master, with all needed files
local to the minion. To do this the minion configuration file needs to be set
up to know how to return file_roots information like the master. The file_roots
setting defaults to /srv/salt for the base environment just like on the master:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt
.ft P
.fi
.sp
Now set up the Salt State Tree, top file, and SLS modules in the same way that
they would be set up on a master. Now, with the \fBfile_client\fP option set to
\fBlocal\fP and an available state tree then calls to functions in the state
module will use the information in the file_roots on the minion instead of
checking in with the master.
.sp
Remember that when creating a state tree on a minion there are no syntax or
path changes needed, SLS modules written to be used from a master do not need
to be modified in any way to work with a minion.
.sp
This makes it easy to "script" deployments with Salt states without having to
set up a master, and allows for these SLS modules to be easily moved into a
Salt master as the deployment grows.
.sp
Now the declared state can now be executed with:
.sp
.nf
.ft C
salt\-call state.highstate
.ft P
.fi
.sp
Or the salt\-call command can be executed with the \fI\-\-local\fP flag, this makes it
unnecessary to change the configuration file:
.sp
.nf
.ft C
salt\-call state.highstate \-\-local
.ft P
.fi
.SS How Do I Use Salt States?
.sp
Simplicity, Simplicity, Simplicity
.sp
Many of the most powerful and useful engineering solutions are founded on
simple principles. The Salt SLS system strives to do just that. K.I.S.S.
(Keep It Stupidly Simple)
.sp
The core of the Salt State system is the SLS, or the SaLt State file. The SLS
is a representation of the state in which a system should be in, and is set up
to contain this data in a simple format. This is often called configuration
management.
.IP Note
This is just the beginning of using states, make sure to read up on pillar
next:
.INDENT 0.0
.INDENT 3.5
\fBPillar Walkthrough\fP
.UNINDENT
.UNINDENT
.RE
.SS It is All Just Data
.sp
Before delving into the particulars, it will help to understand that the SLS
file is just a data structure under the hood. While understanding that the SLS
is just a data structure isn\(aqt critical for understanding and making use of
Salt States, it should help bolster knowledge of where the real power is.
.sp
SLS files are therefore, in reality, just \fI\%dictionaries\fP, \fI\%lists\fP,
\fI\%strings\fP, and \fI\%numbers\fP. By using this approach Salt can be much more
flexible. As one writes more state files, it becomes clearer exactly what is
being written. The result is a system that is easy to understand, yet grows
with the needs of the admin or developer.
.sp
In the section titled "State Data Structures" a reference exists, explaining
in depth how the data is laid out.
.SS Default Data \- YAML
.sp
By default Salt represents the SLS data in what is one of the simplest
serialization formats available \- \fI\%YAML\fP.
.sp
A typical SLS file will often look like this in YAML:
.IP Note
These demos use some generic service and package names, different
distributions often use different names for packages and services. For
instance \fIapache\fP should be replaced with \fIhttpd\fP on a Red Hat system.
Salt uses the name of the init script, systemd name, upstart name etc.
based on what the underlying service management for the platform. To
get a list of the available service names on a platform execute the
service.get_all salt function.
.sp
Information on how to make states work with multiple distributions
is later in the tutorial.
.RE
.sp
.nf
.ft C
 apache:
   pkg:
     \- installed
   service:
     \- running
     \- require:
       \- pkg: apache
.ft P
.fi
.sp
This SLS data will ensure that the package named apache is installed, and
that the apache service is running. The components can be explained in a
simple way.
.sp
The first line is the ID for a set of data, and it is called the ID
Declaration. This ID sets the name of the thing that needs to be manipulated.
.sp
The second and fourth lines are the start of the State Declarations, so they
are using the pkg and service states respectively. The pkg state manages a
software package to be installed via the system\(aqs native package manager,
and the service state manages a system daemon.
.sp
The third and fifth lines are the function to run. This function defines what
state the named package and service should be in. Here, the package is to be
installed, and the service should be running.
.sp
Finally, on line six, is the word \fBrequire\fP. This is called a Requisite
Statement, and it makes sure that the Apache service is only started after
a successful installation of the apache package.
.SS Adding Configs and Users
.sp
When setting up a service like an Apache web server, many more components may
need to be added. The Apache configuration file will most likely be managed,
and a user and group may need to be set up.
.sp
.nf
.ft C
 apache:
   pkg:
     \- installed
   service:
     \- running
     \- watch:
       \- pkg: apache
       \- file: /etc/httpd/conf/httpd.conf
       \- user: apache
   user.present:
     \- uid: 87
     \- gid: 87
     \- home: /var/www/html
     \- shell: /bin/nologin
     \- require:
       \- group: apache
   group.present:
     \- gid: 87
     \- require:
       \- pkg: apache

 /etc/httpd/conf/httpd.conf:
   file.managed:
     \- source: salt://apache/httpd.conf
     \- user: root
     \- group: root
     \- mode: 644
.ft P
.fi
.sp
This SLS data greatly extends the first example, and includes a config file,
a user, a group and new requisite statement: \fBwatch\fP.
.sp
Adding more states is easy, since the new user and group states are under
the Apache ID, the user and group will be the Apache user and group. The
\fBrequire\fP statements will make sure that the user will only be made after
the group, and that the group will be made only after the Apache package is
installed.
.sp
Next,the \fBrequire\fP statement under service was changed to watch, and is
now watching 3 states instead of just one. The watch statement does the same
thing as require, making sure that the other states run before running the
state with a watch, but it adds an extra component. The \fBwatch\fP statement
will run the state\(aqs watcher function for any changes to the watched states.
So if the package was updated, the config file changed, or the user
uid modified, then the service state\(aqs watcher will be run. The service
state\(aqs watcher just restarts the service, so in this case, a change in the
config file will also trigger a restart of the respective service.
.SS Moving Beyond a Single SLS
.sp
When setting up Salt States in a scalable manner, more than one SLS will need
to be used. The above examples were in a single SLS file, but two or more
SLS files can be combined to build out a State Tree. The above example also
references a file with a strange source \- \fBsalt://apache/httpd.conf\fP. That
file will need to be available as well.
.sp
The SLS files are laid out in a directory structure on the Salt master; an
SLS is just a file and files to download are just files.
.sp
The Apache example would be laid out in the root of the Salt file server like
this:
.sp
.nf
.ft C
apache/init.sls
apache/httpd.conf
.ft P
.fi
.sp
So the httpd.conf is just a file in the apache directory, and is referenced
directly.
.sp
But when using more than one single SLS file, more components can be added to
the toolkit. Consider this SSH example:
.sp
\fBssh/init.sls:\fP
.sp
.nf
.ft C
 openssh\-client:
   pkg.installed

 /etc/ssh/ssh_config:
   file.managed:
     \- user: root
     \- group: root
     \- mode: 644
     \- source: salt://ssh/ssh_config
     \- require:
       \- pkg: openssh\-client
.ft P
.fi
.sp
\fBssh/server.sls:\fP
.sp
.nf
.ft C
 include:
   \- ssh

 openssh\-server:
   pkg.installed

 sshd:
   service.running:
     \- require:
       \- pkg: openssh\-client
       \- pkg: openssh\-server
       \- file: /etc/ssh/banner
       \- file: /etc/ssh/sshd_config

 /etc/ssh/sshd_config:
   file.managed:
     \- user: root
     \- group: root
     \- mode: 644
     \- source: salt://ssh/sshd_config
     \- require:
       \- pkg: openssh\-server

 /etc/ssh/banner:
   file:
     \- managed
     \- user: root
     \- group: root
     \- mode: 644
     \- source: salt://ssh/banner
     \- require:
       \- pkg: openssh\-server
.ft P
.fi
.IP Note
Notice that we use two similar ways of denoting that a file
is managed by Salt. In the \fI/etc/ssh/sshd_config\fP state section above,
we use the \fIfile.managed\fP state declaration whereas with the
\fI/etc/ssh/banner\fP state section, we use the \fIfile\fP state declaration
and add a \fImanaged\fP attribute to that state declaration. Both ways
produce an identical result; the first way \-\- using \fIfile.managed\fP \-\-
is merely a shortcut.
.RE
.sp
Now our State Tree looks like this:
.sp
.nf
.ft C
apache/init.sls
apache/httpd.conf
ssh/init.sls
ssh/server.sls
ssh/banner
ssh/ssh_config
ssh/sshd_config
.ft P
.fi
.sp
This example now introduces the \fBinclude\fP statement. The include statement
includes another SLS file so that components found in it can be required,
watched or as will soon be demonstrated \- extended.
.sp
The include statement allows for states to be cross linked. When an SLS
has an include statement it is literally extended to include the contents of
the included SLS files.
.sp
Note that some of the SLS files are called init.sls, while others are not. More
info on what this means can be found in the \fIStates Tutorial\fP.
.SS Extending Included SLS Data
.sp
Sometimes SLS data needs to be extended. Perhaps the apache service needs to
watch additional resources, or under certain circumstances a different file
needs to be placed.
.sp
In these examples, the first will add a custom banner to ssh and the second will
add more watchers to apache to include mod_python.
.sp
\fBssh/custom\-server.sls:\fP
.sp
.nf
.ft C
 include:
   \- ssh.server

 extend:
   /etc/ssh/banner:
     file:
       \- source: salt://ssh/custom\-banner
.ft P
.fi
.sp
\fBpython/mod_python.sls:\fP
.sp
.nf
.ft C
 include:
   \- apache

 extend:
   apache:
     service:
       \- watch:
         \- pkg: mod_python

 mod_python:
   pkg.installed
.ft P
.fi
.sp
The \fBcustom\-server.sls\fP file uses the extend statement to overwrite where the
banner is being downloaded from, and therefore changing what file is being used
to configure the banner.
.sp
In the new mod_python SLS the mod_python package is added, but more importantly
the apache service was extended to also watch the mod_python package.
.IP "Using extend with require or watch"
.sp
The \fBextend\fP statement works differently for \fBrequire\fP or \fBwatch\fP.
It appends to, rather than replacing the requisite component.
.RE
.SS Understanding the Render System
.sp
Since SLS data is simply that (data), it does not need to be represented
with YAML. Salt defaults to YAML because it is very straightforward and easy
to learn and use. But the SLS files can be rendered from almost any imaginable
medium, so long as a renderer module is provided.
.sp
The default rendering system is the \fByaml_jinja\fP renderer. The
\fByaml_jinja\fP renderer will first pass the template through the \fI\%Jinja2\fP
templating system, and then through the YAML parser. The benefit here is that
full programming constructs are available when creating SLS files.
.sp
Other renderers available are \fByaml_mako\fP and \fByaml_wempy\fP which each use
the \fI\%Mako\fP or \fI\%Wempy\fP templating system respectively rather than the jinja
templating system, and more notably, the pure Python or \fBpy\fP and \fBpydsl\fP
renderers.
The \fBpy\fP renderer allows for SLS files to be written in pure Python,
allowing for the utmost level of flexibility and power when preparing SLS
data; while the \fBpydsl\fP renderer
provides a flexible, domain\-specific language for authoring SLS data in Python.
.SS Getting to Know the Default \- yaml_jinja
.sp
The default renderer \- \fByaml_jinja\fP, allows for use of the jinja
templating system. A guide to the Jinja templating system can be found here:
\fI\%http://jinja.pocoo.org/docs\fP
.sp
When working with renderers a few very useful bits of data are passed in. In
the case of templating engine based renderers, three critical components are
available, \fBsalt\fP, \fBgrains\fP, and \fBpillar\fP. The \fBsalt\fP object allows for
any Salt function to be called from within the template, and \fBgrains\fP allows
for the Grains to be accessed from within the template. A few examples:
.sp
\fBapache/init.sls:\fP
.sp
.nf
.ft C
 apache:
   pkg.installed:
     {% if grains[\(aqos\(aq] == \(aqRedHat\(aq%}
     \- name: httpd
     {% endif %}
   service.running:
     {% if grains[\(aqos\(aq] == \(aqRedHat\(aq%}
     \- name: httpd
     {% endif %}
     \- watch:
       \- pkg: apache
       \- file: /etc/httpd/conf/httpd.conf
       \- user: apache
   user.present:
     \- uid: 87
     \- gid: 87
     \- home: /var/www/html
     \- shell: /bin/nologin
     \- require:
       \- group: apache
   group.present:
     \- gid: 87
     \- require:
       \- pkg: apache

 /etc/httpd/conf/httpd.conf:
   file.managed:
     \- source: salt://apache/httpd.conf
     \- user: root
     \- group: root
     \- mode: 644
.ft P
.fi
.sp
This example is simple. If the \fBos\fP grain states that the operating system is
Red Hat, then the name of the Apache package and service needs to be httpd.
.sp
A more aggressive way to use Jinja can be found here, in a module to set up
a MooseFS distributed filesystem chunkserver:
.sp
\fBmoosefs/chunk.sls:\fP
.sp
.nf
.ft C
 include:
   \- moosefs

 {% for mnt in salt[\(aqcmd.run\(aq](\(aqls /dev/data/moose*\(aq).split() %}
 /mnt/moose{{ mnt[\-1] }}:
   mount.mounted:
     \- device: {{ mnt }}
     \- fstype: xfs
     \- mkmnt: True
   file.directory:
     \- user: mfs
     \- group: mfs
     \- require:
       \- user: mfs
       \- group: mfs
 {% endfor %}

 \(aq/etc/mfshdd.cfg\(aq:
   file.managed:
     \- source: salt://moosefs/mfshdd.cfg
     \- user: root
     \- group: root
     \- mode: 644
     \- template: jinja
     \- require:
       \- pkg: mfs\-chunkserver

 \(aq/etc/mfschunkserver.cfg\(aq:
   file.managed:
     \- source: salt://moosefs/mfschunkserver.cfg
     \- user: root
     \- group: root
     \- mode: 644
     \- template: jinja
     \- require:
       \- pkg: mfs\-chunkserver

 mfs\-chunkserver:
   pkg:
     \- installed
 mfschunkserver:
   service:
     \- running
     \- require:
 {% for mnt in salt[\(aqcmd.run\(aq](\(aqls /dev/data/moose*\(aq) %}
       \- mount: /mnt/moose{{ mnt[\-1] }}
       \- file: /mnt/moose{{ mnt[\-1] }}
 {% endfor %}
       \- file: /etc/mfschunkserver.cfg
       \- file: /etc/mfshdd.cfg
       \- file: /var/lib/mfs
.ft P
.fi
.sp
This example shows much more of the available power of Jinja.
Multiple for loops are used to dynamically detect available hard drives
and set them up to be mounted, and the \fBsalt\fP object is used multiple
times to call shell commands to gather data.
.SS Introducing the Python and the PyDSL Renderers
.sp
Sometimes the chosen default renderer might not have enough logical power to
accomplish the needed task. When this happens, the Python renderer can be
used. Normally a YAML renderer should be used for the majority of SLS files,
but an SLS file set to use another renderer can be easily added to the tree.
.sp
This example shows a very basic Python SLS file:
.sp
\fBpython/django.sls:\fP
.sp
.nf
.ft C
 #!py

 def run():
     \(aq\(aq\(aq
     Install the django package
     \(aq\(aq\(aq
     return {\(aqinclude\(aq: [\(aqpython\(aq],
             \(aqdjango\(aq: {\(aqpkg\(aq: [\(aqinstalled\(aq]}}
.ft P
.fi
.sp
This is a very simple example; the first line has an SLS shebang that
tells Salt to not use the default renderer, but to use the \fBpy\fP renderer.
Then the run function is defined, the return value from the run function
must be a Salt friendly data structure, or better known as a Salt
\fBHighState data structure\fP.
.sp
Alternatively, using the \fBpydsl\fP
renderer, the above example can be written more succinctly as:
.sp
\fBpython/django.sls:\fP
.sp
.nf
.ft C
 #!pydsl

 include(\(aqpython\(aq, delayed=True)
 state(\(aqdjango\(aq).pkg.installed()
.ft P
.fi
.sp
This Python examples would look like this if they were written in YAML:
.sp
.nf
.ft C
 include:
   \- python

 django:
   pkg.installed
.ft P
.fi
.sp
This example clearly illustrates that; one, using the YAML renderer by default
is a wise decision and two, unbridled power can be obtained where needed by
using a pure Python SLS.
.SS Running and debugging salt states.
.sp
Once the rules in an SLS are ready, they should be tested to ensure they
work properly. To invoke these rules, simply execute
\fBsalt \(aq*\(aq state.highstate\fP on the command line. If you get back only
hostnames with a \fI\(aq:\(aq\fP after, but no return, chances are there is a problem with
one or more of the sls files. On the minion, use the \fBsalt\-call\fP command:
\fBsalt\-call state.highstate \-l debug\fP to examine the output for errors.
This should help troubleshoot the issue. The minions can also be started in
the foreground in debug mode: \fBsalt\-minion \-l debug\fP.
.SS Next Reading
.sp
With an understanding of states, the next recommendation is to become familiar
with Salt\(aqs pillar interface:
.INDENT 0.0
.INDENT 3.5
\fBPillar Walkthrough\fP
.UNINDENT
.UNINDENT
.SS States tutorial, part 1
.sp
The purpose of this tutorial is to demonstrate how quickly you can configure a
system to be managed by Salt States. For detailed information about the state
system please refer to the full \fBstates reference\fP.
.sp
This tutorial will walk you through using Salt to configure a minion to run the
Apache HTTP server and to ensure the server is running.
.sp
\fBBefore continuing\fP make sure you have a working Salt installation by
following the \fBinstallation\fP and the \fBconfiguration\fP instructions.
.IP "Stuck?"
.sp
There are many ways to \fBget help from the Salt community\fP including our
\fI\%mailing list\fP
and our \fI\%IRC channel\fP #salt.
.RE
.SS Setting up the Salt State Tree
.sp
States are stored in text files on the master and transferred to the minions on
demand via the master\(aqs File Server. The collection of state files make up the
\fIState Tree\fP.
.sp
To start using a central state system in Salt, the Salt File Server must first
be set up. Edit the master config file (\fBfile_roots\fP) and
uncomment the following lines:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt
.ft P
.fi
.IP Note
If you are deploying on FreeBSD via ports, the \fBfile_roots\fP path defaults
to \fB/usr/local/etc/salt/states\fP.
.RE
.sp
Restart the Salt master in order to pick up this change:
.sp
.nf
.ft C
% pkill salt\-master
% salt\-master \-d
.ft P
.fi
.SS Preparing the Top File
.sp
On the master, in the directory uncommented in the previous step,
(\fB/srv/salt\fP by default), create a new file called
\fBtop.sls\fP and add the following:
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- webserver
.ft P
.fi
.sp
The \fItop file\fP is separated into environments (discussed later). The
default environment is \fBbase\fP. Under the \fBbase\fP environment a collection of
minion matches is defined; for now simply specify all hosts (\fB*\fP).
.IP "Targeting minions"
.sp
The expressions can use any of the targeting mechanisms used by Salt â€”
minions can be matched by glob, PCRE regular expression, or by \fBgrains\fP. For example:
.sp
.nf
.ft C
base:
  \(aqos:Fedora\(aq:
    \- match: grain
    \- webserver
.ft P
.fi
.RE
.SS Create an \fBsls\fP module
.sp
In the same directory as the \fItop file\fP, create an empty file, called an
\fISLS module\fP, named \fBwebserver.sls\fP. Type the following and save the
file:
.sp
.nf
.ft C
apache:                 # ID declaration
  pkg:                  # state declaration
    \- installed         # function declaration
.ft P
.fi
.sp
The first line, called the \fIID declaration\fP, is an arbitrary identifier.
In this case it defines the name of the package to be installed. \fBNOTE:\fP the
package name for the Apache httpd web server may differ depending on OS or
distro â€” for example, on Fedora it is \fBhttpd\fP but on Debian/Ubuntu it
is \fBapache2\fP.
.sp
The second line, called the \fIstate declaration\fP, defines which of the
Salt States we are using. In this example, we are using the \fBpkg state\fP to ensure that a given package is installed.
.sp
The third line, called the \fIfunction declaration\fP, defines which function
in the \fBpkg state\fP module to call.
.IP "Renderers"
.sp
States \fIsls\fP files can be written in many formats. Salt requires only
a simple data structure and is not concerned with how that data structure
is built. Templating languages and \fI\%DSLs\fP are a dime\-a\-dozen and everyone
has a favorite.
.sp
Building the expected data structure is the job of Salt \fBrenderers\fP and they are dead\-simple to write.
.sp
In this tutorial we will be using YAML in Jinja2 templates, which is the
default format. The default can be changed by editing
\fBrenderer\fP in the master configuration file.
.RE
.SS Install the package
.sp
Next, let\(aqs run the state we created. Open a terminal on the master and run:
.sp
.nf
.ft C
% salt \(aq*\(aq state.highstate
.ft P
.fi
.sp
Our master is instructing all targeted minions to run \fBstate.highstate\fP. When a minion executes a highstate call it
will download the \fItop file\fP and attempt to match the expressions. When
it does match an expression the modules listed for it will be downloaded,
compiled, and executed.
.sp
Once completed, the minion will report back with a summary of all actions taken
and all changes made.
.IP "SLS File Namespace"
.sp
Note that in the \fIexample\fP above, the SLS file
\fBwebserver.sls\fP was referred to simply as \fBwebserver\fP. The namespace
for SLS files follows a few simple rules:
.INDENT 0.0
.IP 1. 3
The \fB.sls\fP is discarded (i.e. \fBwebserver.sls\fP becomes
\fBwebserver\fP).
.IP 2. 3
.INDENT 3.0
.TP
.B Subdirectories can be used for better organization.
.INDENT 7.0
.IP a. 3
Each subdirectory is represented by a dot.
.IP b. 3
\fBwebserver/dev.sls\fP is referred to as \fBwebserver.dev\fP.
.UNINDENT
.UNINDENT
.IP 3. 3
A file called \fBinit.sls\fP in a subdirectory is referred to by the path
of the directory. So, \fBwebserver/init.sls\fP is referred to as
\fBwebserver\fP.
.IP 4. 3
If both \fBwebserver.sls\fP and \fBwebserver/init.sls\fP happen to exist,
\fBwebserver/init.sls\fP will be ignored and \fBwebserver.sls\fP will be the
file referred to as \fBwebserver\fP.
.UNINDENT
.RE
.IP "Troubleshooting Salt"
.sp
If the expected output isn\(aqt seen, the following tips can help to
narrow down the problem.
.INDENT 0.0
.TP
.B Turn up logging
Salt can be quite chatty when you change the logging setting to
\fBdebug\fP:
.sp
.nf
.ft C
salt\-minion \-l debug
.ft P
.fi
.TP
.B Run the minion in the foreground
By not starting the minion in daemon mode (\fI\-d\fP) one can view any output from the minion as it works:
.sp
.nf
.ft C
salt\-minion &
.ft P
.fi
.UNINDENT
.sp
Increase the default timeout value when running \fBsalt\fP. For
example, to change the default timeout to 60 seconds:
.sp
.nf
.ft C
salt \-t 60
.ft P
.fi
.sp
For best results, combine all three:
.sp
.nf
.ft C
salt\-minion \-l debug &          # On the minion
salt \(aq*\(aq state.highstate \-t 60  # On the master
.ft P
.fi
.RE
.SS Next steps
.sp
This tutorial focused on getting a simple Salt States configuration working.
\fBPart 2\fP will build on this example to cover more advanced
\fIsls\fP syntax and will explore more of the states that ship with Salt.
.SS States tutorial, part 2
.IP Note
This tutorial builds on the topic covered in \fBpart 1\fP.
It is recommended that you begin there.
.RE
.sp
In the \fBlast part\fP of the Salt States tutorial we covered
the basics of installing a package. We will now modify our \fBwebserver.sls\fP
file to have requirements, and use even more Salt States.
.SS Call multiple States
.sp
You can specify multiple \fIstate declarations\fP under
an \fIID declaration\fP. For example, a quick modification to our
\fBwebserver.sls\fP to also start Apache if it is not running:
.sp
Try stopping Apache before running \fBstate.highstate\fP once again and observe
the output.
.SS Expand the SLS module
.sp
As you have seen, SLS modules are appended with the file extension \fB.sls\fP and
are referenced by name starting at the root of the state tree. An SLS module
can be also defined as a directory. Demonstrate that now by creating a
directory named \fBwebserver\fP and moving and renaming \fBwebserver.sls\fP to
\fBwebserver/init.sls\fP. Your state directory should now resemble:
.sp
.nf
.ft C
|\- top.sls
\(ga\- webserver/
   \(ga\- init.sls
.ft P
.fi
.IP "Organizing SLS modules"
.sp
You can place additional \fB.sls\fP files in a state file directory. This
affords much cleaner organization of your state tree on the filesystem. For
example, if we created a \fBwebserver/django.sls\fP file that module would be
referenced as \fBwebserver.django\fP.
.sp
In addition, States provide powerful includes and extending functionality
which we will cover in \fBPart 3\fP.
.RE
.SS Require other states
.sp
We now have a working installation of Apache so let\(aqs add an HTML file to
customize our website. It isn\(aqt exactly useful to have a website without a
webserver so we don\(aqt want Salt to install our HTML file until Apache is
installed and running. Include the following at the bottom of your
\fBwebserver/init.sls\fP file:
.sp
\fBline 9\fP is the \fIID declaration\fP. In this example it is the
location we want to install our custom HTML file. (\fBNote:\fP the default
location that Apache serves may differ from the above on your OS or distro.
\fB/srv/www\fP could also be a likely place to look.)
.sp
\fBLine 10\fP the \fIstate declaration\fP. This example uses the Salt \fBfile
state\fP.
.sp
\fBLine 11\fP is the \fIfunction declaration\fP. The \fBmanaged function\fP will download a file from the master and install it
in the location specified.
.sp
\fBLine 12\fP is a \fIfunction arg declaration\fP which, in this example, passes
the \fBsource\fP argument to the \fBmanaged function\fP.
.sp
\fBLine 13\fP is a \fIrequisite declaration\fP.
.sp
\fBLine 14\fP is a \fIrequisite reference\fP which refers to a state and an ID.
In this example, it is referring to the \fBID declaration\fP from our example in
\fBpart 1\fP. This declaration tells Salt not to install the HTML
file until Apache is installed.
.sp
Next, create the \fBindex.html\fP file and save it in the \fBwebserver\fP
directory:
.sp
.nf
.ft C
<html>
    <head><title>Salt rocks</title></head>
    <body>
        <h1>This file brought to you by Salt</h1>
    </body>
</html>
.ft P
.fi
.sp
Last, call \fBstate.highstate\fP again and the
minion will fetch and execute the highstate as well as our HTML file from the
master using Salt\(aqs File Server:
.sp
.nf
.ft C
salt \(aq*\(aq state.highstate
.ft P
.fi
.sp
Verify that Apache is now serving your custom HTML.
.IP "\fBrequire\fP vs. \fBwatch\fP"
.sp
There are two \fIrequisite declarations\fP,
â€œrequireâ€ and â€œwatchâ€. Not every state supports â€œwatchâ€. The \fBservice
state\fP does support â€œwatchâ€ and will restart a
service based on the watch condition.
.sp
For example, if you use Salt to install an Apache virtual host
configuration file and want to restart Apache whenever that file is changed
you could modify our Apache example from earlier as follows:
.sp
If the pkg and service names differ on your OS or distro of choice you can
specify each one separately using a \fIname declaration\fP which
explained in \fBPart 3\fP.
.RE
.SS Next steps
.sp
In \fBpart 3\fP we will discuss how to use includes, extends and
templating to make a more complete State Tree configuration.
.SS States tutorial, part 3
.IP Note
This tutorial builds on the topic covered in \fBpart1\fP and
\fBpart 2\fP. It is recommended that you begin there.
.RE
.sp
This part of the tutorial will cover more advanced templating and
configuration techniques for \fBsls\fP files.
.SS Templating SLS modules
.sp
SLS modules may require programming logic or inline execution. This is
accomplished with module templating. The default module templating system used
is \fI\%Jinja2\fP  and may be configured by changing the \fBrenderer\fP
value in the master config.
.sp
All states are passed through a templating system when they are initially read.
To make use of the templating system, simply add some templating markup.
An example of an sls module with templating markup may look like this:
.sp
.nf
.ft C
{% for usr in \(aqmoe\(aq,\(aqlarry\(aq,\(aqcurly\(aq %}
{{ usr }}:
  user.present
{% endfor %}
.ft P
.fi
.sp
This templated sls file once generated will look like this:
.sp
.nf
.ft C
moe:
  user.present
larry:
  user.present
curly:
  user.present
.ft P
.fi
.SS Using Grains in SLS modules
.sp
Often times a state will need to behave differently on different systems.
\fBSalt grains\fP objects are made available
in the template context. The \fIgrains\fP can be used from within sls modules:
.sp
.nf
.ft C
apache:
  pkg.installed:
    {% if grains[\(aqos\(aq] == \(aqRedHat\(aq %}
    \- name: httpd
    {% elif grains[\(aqos\(aq] == \(aqUbuntu\(aq %}
    \- name: apache2
    {% endif %}
.ft P
.fi
.SS Calling Salt modules from templates
.sp
All of the Salt modules loaded by the minion are available within the
templating system. This allows data to be gathered in real time on the target
system. It also allows for shell commands to be run easily from within the sls
modules.
.sp
The Salt module functions are also made available in the template context as
\fBsalt\fP:
.sp
.nf
.ft C
{% for usr in \(aqmoe\(aq,\(aqlarry\(aq,\(aqcurly\(aq %}
{{ usr }}:
  group:
    \- present
  user:
    \- present
    \- gid: {{ salt[\(aqfile.group_to_gid\(aq](usr) }}
    \- require:
      \- group: {{ usr }}
{% endfor %}
.ft P
.fi
.sp
Below is an example that uses the \fBnetwork.hwaddr\fP function to retrieve the
MAC address for eth0:
.sp
.nf
.ft C
salt[\(aqnetwork.hwaddr\(aq](\(aqeth0\(aq)
.ft P
.fi
.SS Advanced SLS module syntax
.sp
Lastly, we will cover some incredibly useful techniques for more complex State
trees.
.SS \fIInclude declaration\fP
.sp
A previous example showed how to spread a Salt tree across several files.
Similarly, \fIrequisite references\fP span multiple
files by using an \fIinclude declaration\fP. For example:
.sp
\fBpython/python\-libs.sls\fP:
.sp
.nf
.ft C
python\-dateutil:
  pkg.installed
.ft P
.fi
.sp
\fBpython/django.sls\fP:
.sp
.nf
.ft C
include:
  \- python.python\-libs

django:
  pkg.installed:
    \- require:
      \- pkg: python\-dateutil
.ft P
.fi
.SS \fIExtend declaration\fP
.sp
You can modify previous declarations by using an \fIextend declaration\fP. For
example the following modifies the Apache tree to also restart Apache when the
vhosts file is changed:
.sp
\fBapache/apache.sls\fP:
.sp
.nf
.ft C
apache:
  pkg.installed
.ft P
.fi
.sp
\fBapache/mywebsite.sls\fP:
.sp
.nf
.ft C
include:
  \- apache.apache

extend:
  apache:
    service:
      \- running
      \- watch:
        \- file: /etc/httpd/extra/httpd\-vhosts.conf

/etc/httpd/extra/httpd\-vhosts.conf:
  file.managed:
    \- source: salt://apache/httpd\-vhosts.conf
.ft P
.fi
.IP "Using extend with require or watch"
.sp
The \fBextend\fP statement works differently for \fBrequire\fP or \fBwatch\fP.
It appends to, rather than replacing the requisite component.
.RE
.SS \fIName declaration\fP
.sp
You can override the \fIID declaration\fP by using a \fIname
declaration\fP. For example, the previous example is a bit more maintainable if
rewritten as follows:
.sp
\fBapache/mywebsite.sls\fP:
.SS \fINames declaration\fP
.sp
Even more powerful is using a \fInames declaration\fP to override the
\fIID declaration\fP for multiple states at once. This often can remove the
need for looping in a template. For example, the first example in this tutorial
can be rewritten without the loop:
.sp
.nf
.ft C
stooges:
  user.present:
    \- names:
      \- moe
      \- larry
      \- curly
.ft P
.fi
.SS Continue learning
.sp
The best way to continue learning about Salt States is to read through the
\fBreference documentation\fP and to look through examples
of existing \fIstate trees\fP. You can find examples in the
\fI\%salt-states repository\fP and please send a pull\-request on GitHub with any
state trees that you build and want to share!
.sp
If you have any questions, suggestions, or just want to chat with other people
who are using Salt we have an \fBactive community\fP.
.SS Salt Stack Walkthrough
.SS Welcome!
.sp
Welcome to Salt Stack! I am excited that you are interested in Salt and
starting down the path to better infrastructure management. I developed
(and am continuing to develop) Salt with the goal of making the best
software available to manage computers of almost any kind. I hope you enjoy
working with Salt and that the software can solve your real world needs!
.INDENT 0.0
.IP \(bu 2
Thomas S Hatch
.IP \(bu 2
Salt creator and chief developer
.IP \(bu 2
CTO of Salt Stack, Inc.
.UNINDENT
.IP Note
This is the first of a series of walkthroughs and serves as the best entry
point for people new to Salt, after this be sure to read up on pillar and
more on states:
.INDENT 0.0
.INDENT 3.5
\fBStarting States\fP
.sp
\fBPillar Walkthrough\fP
.UNINDENT
.UNINDENT
.RE
.SS Getting Started
.SS What is Salt?
.sp
Salt is a different approach to infrastructure management, it is founded on
the idea that high speed communication with large numbers of systems can open
up new capabilities. This approach makes Salt a powerful multitasking system
that can solve many specific problems in an infrastructure. The backbone of
Salt is the remote execution engine, which creates a high speed, secure and
bi\-directional communication net for groups of systems. On top of this
communication system Salt provides an extremely fast, flexible and easy to use
configuration management system called \fBSalt States\fP.
.sp
This unique approach to management makes for a transparent control system that
is not only amazingly easy to set up and use, but also capable of solving very
complex problems in infrastructures; as will be explored in this walk through.
.sp
Salt is being used today by some of the largest infrastructures in the world
and has a proven ability to scale to astounding proportions without
modification. With the proven ability to scale out well beyond many tens of
thousands of servers, Salt has also proven to be an excellent choice for small
deployments as well, lowering compute and management overhead for
infrastructures as small as just a few systems.
.SS Installing Salt
.sp
Salt Stack has been made to be very easy to install and get started. Setting
up Salt should be as easy as installing Salt via distribution packages on Linux
or via the Windows installer. The installation documents cover specific platform
installation in depth:
.sp
\fBInstallation\fP
.SS Starting Salt
.sp
Salt functions on a master/minion topology. A master server acts as a
central control bus for the clients (called minions), and the minions connect
back to the master.
.SS Setting Up the Salt Master
.sp
Turning on the Salt Master is easy, just turn it on! The default configuration
is suitable for the vast majority of installations. The Salt master can be
controlled by the local Linux/Unix service manager:
.sp
On Systemd based platforms (OpenSuse, Fedora):
.INDENT 0.0
.INDENT 3.5
# systemctl start salt\-master
.UNINDENT
.UNINDENT
.sp
On Upstart based systems (Ubuntu, older Fedora/RHEL):
.INDENT 0.0
.INDENT 3.5
# service salt\-master start
.UNINDENT
.UNINDENT
.sp
On SysV Init systems (Debian, Gentoo etc.):
.INDENT 0.0
.INDENT 3.5
# /etc/init.d/salt\-master start
.UNINDENT
.UNINDENT
.sp
Or the master can be started directly on the command line:
.INDENT 0.0
.INDENT 3.5
# salt\-master \-d
.UNINDENT
.UNINDENT
.sp
The Salt Master can also be started in the foreground in debug mode, thus
greatly increasing the command output:
.INDENT 0.0
.INDENT 3.5
# salt\-master \-l debug
.UNINDENT
.UNINDENT
.sp
The Salt Master needs to bind to 2 TCP network ports on the system, these ports
are 4505 and 4506. For more in depth information on fire walling these ports
the firewall tutorial is available:
.INDENT 0.0
.INDENT 3.5
\fBFirewalling the Salt Master\fP
.UNINDENT
.UNINDENT
.SS Setting up a Salt Minion
.IP Note
The Salt Minion can operate with or without a Salt Master. This walkthrough
assumes that the minion will be connected to the master, for information on
how to run a master\-less minion please see the masterless quickstart guide:
.INDENT 0.0
.INDENT 3.5
\fBMasterless Minion Quickstart\fP
.UNINDENT
.UNINDENT
.RE
.sp
The Salt Minion only needs to be aware of one piece of information to run, the
network location of the master. By default the minion will look for the DNS
name \fIsalt\fP for the master, making the easiest approach to set internal DNS to
resolve the name \fIsalt\fP back to the Salt Master IP. Otherwise the minion
configuration file will need to be edited, edit the configuration option
\fBmaster\fP to point to the DNS name or the IP of the Salt Master:
.IP Note
The default location of the configuration files is /etc/salt, most
platforms adhere to this convention, but platforms such as FreeBSD and
Microsoft Windows place this file in different locations.
.RE
.sp
\fI/etc/salt/minion:\fP
.sp
.nf
.ft C
master: saltmaster.example.com
.ft P
.fi
.sp
Now that the master can be found, start the minion in the same way as the
master; with the platform init system, or via the command line directly:
.sp
As a daemon:
.INDENT 0.0
.INDENT 3.5
# salt\-minion \-d
.UNINDENT
.UNINDENT
.sp
In the foreground in debug mode:
.INDENT 0.0
.INDENT 3.5
# salt\-minion \-l debug
.UNINDENT
.UNINDENT
.sp
Now that the minion is started it will generate cryptographic keys and attempt
to connect to the master. The next step is to venture back to the master server
and accept the new minion\(aqs public key.
.SS Using Salt Key
.sp
Salt authenticates minions using public key encryption and authentication. For
a minion to start accepting commands from the master the minion keys need to be
accepted. The \fBsalt\-key\fP command is used to manage all of the keys on the
master. To list the keys that are on the master run a salt\-key list command:
.INDENT 0.0
.INDENT 3.5
# salt\-key \-L
.UNINDENT
.UNINDENT
.sp
The keys that have been rejected, accepted and pending acceptance are listed.
The easiest way to accept the minion key is to accept all pending keys:
.INDENT 0.0
.INDENT 3.5
# salt\-key \-A
.UNINDENT
.UNINDENT
.IP Note
Keys should be verified!! The secure thing to do is to run salt\-key \-P to
verify that the keys on the master match the generated keys on the
minions.
.RE
.SS Sending the First Commands
.sp
Now that the minion is connected to the master and authenticated, the master
can start to command the minion. Salt commands allow for a vast set of
functions to be executed and for specific minions and groups of minions to be
targeted for execution. This makes the \fBsalt\fP command very powerful, but
the command is also very usable, and easy to understand.
.sp
The \fBsalt\fP command is comprised of command options, target specification,
the function to execute, and arguments to the function. A simple command to
start with looks like this:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq test.ping
.UNINDENT
.UNINDENT
.sp
The \fB*\fP is the target, which specifies all minions, and \fItest.ping\fP tells the
minion to run the test.ping function. This \fBsalt\fP command will tell all of
the minions to execute the \fItest.ping\fP in parallel and return the result.
.IP Note
All of the minions register themselves with a unique minion \fIid\fP, these
ids default to the minion hostname, but can be explicitly defined in the
minion config as well.
.RE
.SS Getting to Know the Functions
.sp
Salt comes with a vast library of functions available for execution, and Salt
functions are self documenting. To see what functions are available on the
minions execute the \fIsys.doc\fP function:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq sys.doc
.UNINDENT
.UNINDENT
.sp
This will display a very large list of available functions and documentation
on them, this documentation is also available online:
.INDENT 0.0
.INDENT 3.5
\fBFull List of Execution Modules\fP
.UNINDENT
.UNINDENT
.sp
These functions cover everything from shelling out to package management to
manipulating database servers. These functions comprise a powerful system
management API which is the backbone to Salt configuration management and many
other aspects of Salt.
.IP Note
Salt comes with many plugin systems, the functions that are available
via the salt command are called \fIExecution Modules\fP.
.RE
.SS Some Functions to Know
.sp
Some functions to be familiar with are around basic system management. Functions
to shell out on minions such as \fBcmd.run\fP and \fBcmd.run_all\fP:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq cmd.run \(aqls \-l /etc\(aq
.UNINDENT
.UNINDENT
.sp
The pkg functions will automatically map local system package managers to the
same salt functions. This means that \fBpkg.install\fP will wrap to installing
packages via yum on Red Hat based systems and apt on Debian systems etc.
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq pkg.install vim
.UNINDENT
.UNINDENT
.SS Grains
.sp
Salt uses a system called \fIGrains\fP to build up static data about minions. This
data includes information about the operating system that is running, CPU
architecture and much more. The grains system is used throughout Salt to
deliver platform data to many components and to users.
.sp
Grains can also be statically set, this makes it easy to assign values to
minions for grouping and managing. A common practice is to assign grains to
minions to specify what the role or roles a minion might be. These static
grains can be set in the minion configuration file or via the \fBgrains.set\fP
function.
.SS Targeting
.sp
Salt allows for minions to be targeted based on a wide range of criteria.
The default targeting system uses globular expressions to match minions, hence
if there are minions named \fIlarry1\fP, \fIlarry2\fP, \fIcurly1\fP and \fIcurly2\fP, a glob
of \fIlarry*\fP will match \fIlarry1\fP and \fIlarry2\fP, and a glob of \fI*1\fP will match
\fIlarry1\fP and \fIcurly1\fP.
.sp
Many other targeting systems can be used other than globs, these systems
include:
.INDENT 0.0
.TP
.B Regular Expressions
Target using PCRE compliant regular expressions:
\fBTargeting with Regular Expressions\fP
.TP
.B Grains
Target based on grains data:
\fBTargeting with Grains\fP
.TP
.B Pillar
Target based on pillar data:
\fBTargeting with Pillar\fP
.TP
.B IP
Target based on IP addr/subnet/range:
\fBTargeting with ipcidr\fP
.TP
.B Compound
Create logic to target based on multiple targets:
\fBTargeting with Compound\fP
.TP
.B Nodegroup
Target with nodegroups:
\fBTargeting with Nodegroup\fP
.UNINDENT
.sp
The concepts of targets are used on the command line with salt, but also
function in many other areas as well, including the state system and the
systems used for ACLs and user permissions.
.SS Passing in Arguments
.sp
Many of the functions available accept arguments, these arguments can be
passed in on the command line:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq pkg.install vim
.UNINDENT
.UNINDENT
.sp
This example passes the argument \fIvim\fP to the pkg.install function, since many
functions can accept more complex input then just a string the arguments are
parsed through YAML, allowing for more complex data to be sent on the command
line:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq test.echo \(aqfoo: bar\(aq
.UNINDENT
.UNINDENT
.sp
In this case Salt translates the string \(aqfoo: bar\(aq into the dictionary
"{\(aqfoo\(aq: \(aqbar\(aq}"
.IP Note
Any line that contains a newline will not be parsed by yaml.
.RE
.SS Salt States
.sp
Now that the basics are covered the time has come to evaluate \fIStates\fP.
Salt \fIStates\fP, or the \fIState System\fP is the component of Salt made for
configuration management. The State system is a fully functional configuration
management system which has been designed to be exceptionally powerful while
still being simple to use, fast, lightweight, deterministic and with salty
levels of flexibility.
.sp
The state system is already available with a basic salt setup, no additional
configuration is required, states can be set up immediately.
.IP Note
Before diving into the state system, a brief overview of how states are
constructed will make many of the concepts clearer. Salt states are based
on data modeling, and build on a low level data structure that is used to
execute each state function. Then more logical layers are built on top of
each other. The high layers of the state system which this tutorial will
cover consists of everything that needs to be known to use states, the two
high layers covered here are the \fIsls\fP layer and the highest layer
\fIhighstate\fP.
.sp
Again, knowing that there are many layers of data management, will help with
understanding states, but they never need to be used. Just as understanding
how a compiler functions when learning a programming language,
understanding what is going on under the hood of a configuration management
system will also prove to be a valuable asset.
.RE
.SS The First SLS Formula
.sp
The state system is built on sls formulas, these formulas are built out in
files on Salt\(aqs file server. To make a very basic sls formula open up a file
under /srv/salt named vim.sls and get vim installed:
.sp
\fI/srv/salt/vim.sls\fP
.sp
.nf
.ft C
vim:
  pkg.installed
.ft P
.fi
.sp
Now install vim on the minions by calling the sls directly:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq state.sls vim
.UNINDENT
.UNINDENT
.sp
This command will invoke the state system and run the named sls which was just
created "vim".
.sp
Now to beef up the vim sls formula a vimrc can be added:
.sp
\fI/srv/salt/vim.sls\fP
.sp
.nf
.ft C
vim:
  pkg.installed

/etc/vimrc:
  file.managed:
    \- source: salt://vimrc
    \- mode: 644
    \- user: root
    \- group: root
.ft P
.fi
.sp
Now the desired vimrc needs to be copied into the Salt file server to
/srv/salt/vimrc, in Salt everything is a file, so no path redirection needs
to be accounted for. The vimrc file is placed right next to the vim.sls file.
The same command as above can be executed to all the vim sls formulas and now
include managing the file.
.IP Note
Salt does not need to be restarted/reloaded or have the master manipulated
in any way when changing sls formulas, they are instantly available.
.RE
.SS Adding Some Depth
.sp
Obviously maintaining sls formulas right in the root of the file server will
not scale out to reasonably sized deployments. This is why more depth is
required. Start by making an nginx formula a better way, make an nginx
subdirectory and add an init.sls file:
.sp
\fI/srv/salt/nginx/init.sls\fP
.sp
.nf
.ft C
nginx:
  pkg:
    \- installed
  service:
    \- running
    \- require:
      \- pkg: nginx
.ft P
.fi
.sp
A few things are introduced in this sls formula, first is the service statement
which ensures that the nginx service is running, but the nginx service can\(aqt be
started unless the package is installed, hence the \fIrequire\fP. The \fIrequire\fP
statement makes sure that the required component is executed before and that
it results in success.
.IP Note
The \fIrequire\fP option belongs to a family of options called \fIrequisites\fP.
Requisites are a powerful component of Salt States, for more information
on how requisites work and what is available see:
\fBRequisites\fP
Also evaluation ordering is available in Salt as well:
\fBOrdering States\fP
.RE
.sp
Now this new sls formula has a special name, \fIinit.sls\fP, when an sls formula is
named \fIinit.sls\fP it inherits the name of the directory path that contains it,
so this formula can be referenced via the following command:
.INDENT 0.0
.INDENT 3.5
# salt \(aq*\(aq  state.sls nginx
.UNINDENT
.UNINDENT
.sp
Now that subdirectories can be used the vim.sls formula can be cleaned up, but
to make things more flexible (and to illustrate another point of course), move
the vim.sls and vimrc into a new subdirectory called \fIedit\fP and change the
vim.sls file to reflect the change:
.sp
\fI/srv/salt/edit/vim.sls\fP
.sp
.nf
.ft C
vim:
  pkg.installed

/etc/vimrc:
  file.managed:
    \- source: salt://edit/vimrc
    \- mode: 644
    \- user: root
    \- group: root
.ft P
.fi
.sp
The only change in the file is fixing the source path for the vimrc file. Now
the formula is referenced as \fIedit.vim\fP because it resides in the edit
subdirectory. Now the edit subdirectory can contain formulas for emacs, nano,
joe or any other editor that may need to be deployed.
.SS Next Reading
.sp
Two walkthroughs are specifically recommended at this point, first a deeper run
through states:
.INDENT 0.0
.INDENT 3.5
\fBStarting States\fP
.UNINDENT
.UNINDENT
.sp
Next an understanding of pillar is critical to using States:
.INDENT 0.0
.INDENT 3.5
\fBPillar Walkthrough\fP
.UNINDENT
.UNINDENT
.SS Getting Deeper Into States
.sp
Two more in depth states tutorials exist which move much more deeply into states
functionality, Thomas\(aq original states tutorial covers much more to get off the
ground with States:
.INDENT 0.0
.INDENT 3.5
\fBHow Do I Use Salt States\fP
.UNINDENT
.UNINDENT
.sp
The States Tutorial also provides a fantastic introduction to states:
.INDENT 0.0
.INDENT 3.5
\fBStates Tutorial\fP
.UNINDENT
.UNINDENT
.sp
These tutorials include much more in depth information including templating
sls formulas etc.
.SS So Much More!
.sp
This concludes the initial Salt walkthrough, but there are many more things to
learn still! These documents will cover important core aspects of Salt:
.INDENT 0.0
.TP
.B Pillar
Parameters and minion private data (pillar is a core component of states):
\fBStates Tutorial\fP
\fBPillar\fP
.TP
.B Job Management
Information on how Salt manages jobs:
\fBJob Management\fP
.UNINDENT
.sp
A few more tutorials are also available:
.INDENT 0.0
.TP
.B Remote Execution Tutorial
\fBRemote Execution Tutorial\fP
.TP
.B Standalone Minion
\fBStandalone Minion\fP
.UNINDENT
.sp
This still is only scratching the surface, many components such as the reactor
and event systems, extending Salt, modular components and more are not covered
here. For an overview of all Salt features and documentation look at the table
of contents:
.INDENT 0.0
.INDENT 3.5
\fBTable Of Contents\fP
.UNINDENT
.UNINDENT
.SH ACCESS CONTROL SYSTEM
.sp
New in version 0.10.4.
.sp
Salt maintains a standard system used to open granular control to non
administrative users to execute Salt commands. The access control system
has been applied to all systems used to configure access to non administrative
control interfaces in Salt.These interfaces include, the \fBpeer\fP system, the
\fBexternal auth\fP system and the \fBclient acl\fP system.
.sp
The access control system mandated a standard configuration syntax used in
all of the three aforementioned systems. While this adds functionality to the
configuration in 0.10.4, it does not negate the old configuration.
.sp
Now specific functions can be opened up to specific minions from specific users
in the case of external auth and client ACLs, and for specific minions in the
case of the peer system.
.sp
The access controls are manifested using matchers in these configurations:
.sp
.nf
.ft C
client_acl:
  fred:
    \- web\e*:
      \- pkg.list_pkgs
      \- test.*
      \- apache.*
.ft P
.fi
.sp
In the above example, fred is able to send commands only to minions which match
the specified glob target. This can be expanded to include other functions for
other minions based on standard targets.
.sp
.nf
.ft C
external_auth:
  pam:
    dave:
      \- test.ping
      \- mongo\e*:
        \- network.*
      \- log\e*:
        \- network.*
        \- pkg.*
      \- \(aqG@os:RedHat\(aq:
        \- kmod.*
    steve:
      \- .*
.ft P
.fi
.sp
The above allows for all minions to be hit by test.ping by dave, and adds a
few functions that dave can execute on other minions. It also allows steve
unrestricted access to salt commands.
.SH EXTERNAL AUTHENTICATION SYSTEM
.sp
Salt 0.10.4 comes with a fantastic new way to open up running Salt commands
to users. This system allows for Salt itself to pass through authentication to
any authentication system (The Unix PAM system was the first) to determine
if a user has permission to execute a Salt command.
.sp
The external authentication system allows for specific users to be granted
access to execute specific functions on specific minions. Access is configured
in the master configuration file, and uses the new access control system:
.sp
.nf
.ft C
external_auth:
  pam:
    thatch:
      \- \(aqweb*\(aq:
        \- test.*
        \- network.*
    steve:
      \- .*
.ft P
.fi
.sp
So, the above allows the user thatch to execute functions in the test and
network modules on the minions that match the web* target. User steve is
given unrestricted access to minion commands.
.sp
The external authentication system can then be used from the command line by
any user on the same system as the master with the \fI\-a\fP option:
.sp
.nf
.ft C
$ salt \-a pam web\e* test.ping
.ft P
.fi
.sp
The system will ask the user for the credentials required by the
authentication system and then publish the command.
.SS Tokens
.sp
With external authentication alone the authentication credentials will be
required with every call to Salt. This can be alleviated with Salt tokens.
.sp
The tokens are short term authorizations and can be easily created by just
adding a \fB\-T\fP option when authenticating:
.sp
.nf
.ft C
$ salt \-T \-a pam web\e* test.ping
.ft P
.fi
.sp
Now a token will be created that has a expiration of, by default, 12 hours.
This token is stored in a file named \fB.salt_token\fP in the active user\(aqs home
directory. Once the token is created, it is sent with all subsequent communications.
The user authentication does not need to be entered again until the token expires. The
token expiration time can be set in the Salt master config file.
.SH PILLAR OF SALT
.sp
Pillar is an interface for Salt designed to offer global values that can be
distributed to all minions. Pillar data is managed in a similar way as
the Salt State Tree.
.sp
Pillar was added to Salt in version 0.9.8
.IP Note
Storing sensitive data
.sp
Unlike state tree, pillar data is only available for the targeted
minion specified by the matcher type.  This makes it useful for
storing sensitive data specific to a particular minion.
.RE
.SS Declaring the Master Pillar
.sp
The Salt Master server maintains a pillar_roots setup that matches the
structure of the file_roots used in the Salt file server. Like the
Salt file server the \fBpillar_roots\fP option in the master config is based
on environments mapping to directories. The pillar data is then mapped to
minions based on matchers in a top file which is laid out in the same way
as the state top file. Salt pillars can use the same matcher types as the
standard top file.
.sp
The configuration for the \fBpillar_roots\fP in the master config is identical in
behavior and function as the \fBfile_roots\fP configuration:
.sp
.nf
.ft C
pillar_roots:
  base:
    \- /srv/pillar
.ft P
.fi
.sp
This example configuration declares that the base environment will be located
in the \fB/srv/pillar\fP directory. The top file used matches the name of the top
file used for States, and has the same structure:
.sp
\fB/srv/pillar/top.sls\fP
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- packages
.ft P
.fi
.sp
This further example shows how to use other standard top matching types (grain
matching is used in this example) to deliver specific salt pillar data to minions
with different \(aqos\(aq grains:
.sp
.nf
.ft C
dev:
  \(aqos:Debian\(aq:
    \- match: grain
    \- servers
.ft P
.fi
.sp
\fB/srv/pillar/packages.sls\fP
.sp
.nf
.ft C
{% if grains[\(aqos\(aq] == \(aqRedHat\(aq %}
apache: httpd
git: git
{% elif grains[\(aqos\(aq] == \(aqDebian\(aq %}
apache: apache2
git: git\-core
{% endif %}
.ft P
.fi
.sp
Now this data can be used from within modules, renderers, State SLS files, and
more via the shared pillar \fI\%dict\fP:
.sp
.nf
.ft C
apache:
  pkg:
    \- installed
    \- name: {{ pillar[\(aqapache\(aq] }}
.ft P
.fi
.sp
.nf
.ft C
git:
  pkg:
    \- installed
    \- name: {{ pillar[\(aqgit\(aq] }}
.ft P
.fi
.sp
Note that you cannot just list key/value\-information in \fBtop.sls\fP.
.SS Including Other Pillars
.sp
Pillar SLS files may include other pillar files, similar to State files.
Two syntaxes are available for this purpose. The simple form simply includes
the additional pillar as if it were part of the same file:
.sp
.nf
.ft C
include:
  \- users
.ft P
.fi
.sp
The full include form allows two additional options \-\- passing default values
to the templating engine for the included pillar file as well as an optional
key under which to nest the results of the included pillar:
.sp
.nf
.ft C
include:
  \- users:
      defaults:
        \- sudo: [\(aqbob\(aq, \(aqpaul\(aq]
      key: users
.ft P
.fi
.sp
With this form, the included file (users.sls) will be nested within the \(aqusers\(aq
key of the compiled pillar. Additionally, the \(aqsudo\(aq value will be available
as a template variable to users.sls.
.SS Viewing Minion Pillar
.sp
Once the pillar is set up the data can be viewed on the minion via the
\fBpillar\fP module, the pillar module comes with two functions,
\fBpillar.data\fP and and \fBpillar.raw\fP.  \fBpillar.data\fP will
return a freshly reloaded pillar and \fBpillar.raw\fP will return the current pillar without a refresh:
.sp
.nf
.ft C
# salt \(aq*\(aq pillar.data
.ft P
.fi
.SS Pillar "get" Function
.sp
New in version 0.14.0.
.sp
The \fBpillar.get\fP function works much in the same
way as the \fBget\fP method in a python dict, but with an enhancement: nested
dict components can be extracted using a \fI:\fP delimiter.
.sp
If a structure like this is in pillar:
.sp
.nf
.ft C
foo:
  bar:
    baz: qux
.ft P
.fi
.sp
Extracting it from the raw pillar in an sls formula or file template is done
this way:
.sp
.nf
.ft C
{{ pillar[\(aqfoo\(aq][\(aqbar\(aq][\(aqbaz\(aq] }}
.ft P
.fi
.sp
Now, with the new \fBpillar.get\fP function the data
can be safely gathered and a default can be set, allowing the template to fall
back if the value is not available:
.sp
.nf
.ft C
{{ salt[\(aqpillar.get\(aq](\(aqfoo:bar:baz\(aq, \(aqqux\(aq) }}
.ft P
.fi
.sp
This makes handling nested structures much easier.
.SS Refreshing Pillar Data
.sp
When pillar data is changed on the master the minions need to refresh the data
locally. This is done with the \fBsaltutil.refresh_pillar\fP function.
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.refresh_pillar
.ft P
.fi
.sp
This function triggers the minion to refresh the pillar and will always return
\fBTrue\fP
.SS Targeting with Pillar
.sp
Pillar data can be used when targeting minions. This allows for ultimate
control and flexibility when targeting minions.
.sp
.nf
.ft C
salt \-I \(aqsomekey:specialvalue\(aq test.ping
.ft P
.fi
.sp
Like with \fBGrains\fP, it is possible to use globbing
as well as match nested values in Pillar, by adding colons for each level that
is being traversed. The below example would match minions with a pillar named
\fBfoo\fP, which is a dict containing a key \fBbar\fP, with a value beginning with
\fBbaz\fP:
.sp
.nf
.ft C
salt \-I \(aqfoo:bar:baz*\(aq
.ft P
.fi
.SS Master Config In Pillar
.sp
For convenience the data stored in the master configuration file is made
available in all minion\(aqs pillars. This makes global configuration of services
and systems very easy but may not be desired if sensitive data is stored in the
master configuration.
.sp
To disable the master config from being added to the pillar set \fIpillar_opts\fP
to \fIFalse\fP:
.sp
.nf
.ft C
pillar_opts: False
.ft P
.fi
.SH MASTER TOPS SYSTEM
.sp
In 0.10.4 the \fIexternal_nodes\fP system was upgraded to allow for modular
subsystems to be used to generate the top file data for a highstate run on
the master.
.sp
The old \fIexternal_nodes\fP option still works, but will be removed in the
future in favor of the new \fImaster_tops\fP option which uses the modular
system instead. The master tops system contains a number of subsystems that
are loaded via the Salt loader interfaces like modules, states, returners,
runners, etc.
.sp
Using the new \fImaster_tops\fP option is simple:
.sp
.nf
.ft C
master_tops:
  ext_nodes: cobbler\-external\-nodes
.ft P
.fi
.sp
or:
.sp
.nf
.ft C
master_tops:
  reclass:
    inventory_base_uri: /etc/reclass
    classes_uri: roles
.ft P
.fi
.SH JOB MANAGEMENT
.sp
New in version 0.9.7.
.sp
Since Salt executes jobs running on many systems, Salt needs to be able to
manage jobs running on many systems. As of Salt 0.9.7, the capability was
added for more advanced job management.
.SS The Minion proc System
.sp
The Salt Minions now maintain a \fIproc\fP directory in the Salt cachedir, the \fIproc\fP
directory maintains files named after the executed job ID. These files contain
the information about the current running jobs on the minion and allow for
jobs to be looked up. This is located in the \fIproc\fP directory under the
cachedir, with a default configuration it is under \fI/var/cache/salt/proc\fP.
.SS Functions in the saltutil Module
.sp
Salt 0.9.7 introduced a few new functions to the
\fBsaltutil\fP module for managing
jobs. These functions are:
.INDENT 0.0
.IP 1. 3
\fBrunning\fP
Returns the data of all running jobs that are found in the \fIproc\fP directory.
.IP 2. 3
\fBfind_job\fP
Returns specific data about a certain job based on job id.
.IP 3. 3
\fBsignal_job\fP
Allows for a given jid to be sent a signal.
.IP 4. 3
\fBterm_job\fP
Sends a termination signal (SIGTERM, 15) to the process controlling the
specified job.
.IP 5. 3
\fBkill_job\fP
Sends a kill signal (SIGKILL, 9) to the process controlling the
specified job.
.UNINDENT
.sp
These functions make up the core of the back end used to manage jobs at the
minion level.
.SS The jobs Runner
.sp
A convenience runner front end and reporting system has been added as well.
The jobs runner contains functions to make viewing data easier and cleaner.
.sp
The jobs runner contains a number of functions...
.SS active
.sp
The active function runs saltutil.running on all minions and formats the
return data about all running jobs in a much more usable and compact format.
The active function will also compare jobs that have returned and jobs that
are still running, making it easier to see what systems have completed a job
and what systems are still being waited on.
.sp
.nf
.ft C
# salt\-run jobs.active
.ft P
.fi
.SS lookup_jid
.sp
When jobs are executed the return data is sent back to the master and cached.
By default is is cached for 24 hours, but this can be configured via the
\fBkeep_jobs\fP option in the master configuration.
Using the lookup_jid runner will display the same return data that the initial
job invocation with the salt command would display.
.sp
.nf
.ft C
# salt\-run jobs.lookup_jid <job id number>
.ft P
.fi
.SS list_jobs
.sp
Before finding a historic job, it may be required to find the job id. list_jobs
will parse the cached execution data and display all of the job data for jobs
that have already, or partially returned.
.sp
.nf
.ft C
# salt\-run jobs.list_jobs
.ft P
.fi
.SH SALT SCHEDULING
.sp
In Salt versions greater than 0.12.0, the scheduling system allows incremental
executions on minions or the master. The schedule system exposes the execution
of any execution function on minions or any runner on the master.
.sp
To set up the scheduler on the master add the schedule option to the master
config file.
.sp
To set up the scheduler on the minion add the schedule option to
the minion config file or to the minion\(aqs pillar.
.IP Note
The scheduler executes different functions on the master and minions. When
running on the master the functions reference runner functions, when
running on the minion the functions specify execution functions.
.RE
.sp
The schedule option defines jobs which execute at certain intervals. To set up a highstate
to run on a minion every 60 minutes set this in the minion config or pillar:
.sp
.nf
.ft C
schedule:
  highstate:
    function: state.highstate
    minutes: 60
.ft P
.fi
.sp
Time intervals can be specified as seconds, minutes, hours, or days. Runner
executions can also be specified on the master within the master configuration
file:
.sp
.nf
.ft C
schedule:
  overstate:
    function: state.over
    seconds: 35
    minutes: 30
    hours: 3
.ft P
.fi
.sp
The above configuration will execute the state.over runner every 3 hours,
30 minutes and 35 seconds, or every 12,635 seconds.
.SS Scheduler With Returner
.sp
The scheduler is also useful for tasks like gathering monitoring data about
a minion, this schedule option will gather status data and send it to a mysql
returner database:
.sp
.nf
.ft C
schedule:
  uptime:
    function: status.uptime
    seconds: 60
    returner: mysql
  meminfo:
    function: status.meminfo
    minutes: 5
    returner: mysql
.ft P
.fi
.sp
Since specifying the returner repeatedly can be tiresome, the
\fIschedule_returner\fP option is available to specify one or a list of global
returners to be used by the minions when scheduling.
.SH RUNNING THE SALT MASTER AS UNPRIVILEGED USER
.sp
While the default setup runs the Salt Master as the root user, it is generally
wise to run servers as an unprivileged user. In Salt 0.9.10 the management
of the running user was greatly improved, the only change needed is to alter
the option \fBuser\fP in the master configuration file and all salt system
components will be updated to function under the new user when the master
is started.
.sp
If running a version older that 0.9.10 then a number of files need to be
owned by the user intended to run the master:
.sp
.nf
.ft C
# chown \-R <user> /var/cache/salt
# chown \-R <user> /var/log/salt
# chown \-R <user> /etc/salt/pki
.ft P
.fi
.SH TROUBLESHOOTING
.sp
The intent of the troubleshooting section is to introduce solutions to a
number of common issues encountered by users and the tools that are available
to aid in developing States and Salt code.
.SS Running in the Foreground
.sp
A great deal of information is available via the debug logging system, if you
are having issues with minions connecting or not starting run the minion and/or
master in the foreground:
.sp
.nf
.ft C
# salt\-master \-l debug
# salt\-minion \-l debug
.ft P
.fi
.sp
Anyone wanting to run Salt daemons via a process supervisor such as \fI\%monit\fP,
\fI\%runit\fP, or \fI\%supervisord\fP, should omit the \fB\-d\fP argument to the daemons and
run them in the foreground.
.SS What Ports do the Master and Minion Need Open?
.sp
No ports need to be opened up on each minion. For the master, TCP ports 4505
and 4506 need to be open. If you\(aqve put both your Salt master and minion in
debug mode and don\(aqt see an acknowledgment that your minion has connected,
it could very well be a firewall.
.sp
You can check port connectivity from the minion with the nc command:
.sp
.nf
.ft C
# nc \-v \-z salt.master.ip 4505
# nc \-v \-z salt.master.ip 4506
.ft P
.fi
.sp
There is also a \fBfirewall configuration\fP
document that might help as well.
.sp
If you\(aqve enabled the right TCP ports on your operating system or Linux
distribution\(aqs firewall and still aren\(aqt seeing connections, check that no
additional access control system such as \fI\%SELinux\fP or \fI\%AppArmor\fP is blocking
Salt.
.SS Using salt\-call
.sp
The \fBsalt\-call\fP command was originally developed for aiding in the development
of new Salt modules. Since then, many applications have been developed for
running any Salt module locally on a minion. These range from the original
intent of salt\-call, development assistance, to gathering more verbose output
from calls like \fBstate.highstate\fP.
.sp
When developing the State Tree it is generally recommended to invoke
state.highstate with salt\-call. This displays far more information
about the highstate execution than calling it remotely. For even more
verbosity, increase the loglevel with the same argument as \fBsalt\-minion\fP:
.sp
.nf
.ft C
salt\-call \-l debug state.highstate
.ft P
.fi
.SS Too many open files
.sp
The salt\-master needs at least 2 sockets per host that connects to it, one for
the Publisher and one for response port. Thus, large installations may, upon
scaling up the number of minions accessing a given master, encounter:
.sp
.nf
.ft C
12:45:29,289 [salt.master    ][INFO    ] Starting Salt worker process 38
Too many open files
sock != \-1 (tcp_listener.cpp:335)
.ft P
.fi
.sp
The solution to this would be to check the number of files allowed to be
opened by the user running salt\-master (root by default):
.sp
.nf
.ft C
[root@salt\-master ~]# ulimit \-n
1024
.ft P
.fi
.sp
And modify that value to be at least equal to the number of minions x 2.
This setting can be changed in limits.conf as the nofile value(s),
and activated upon new a login of the specified user.
.sp
So, an environment with 1800 minions, would need 1800 x 2 = 3600 as a minimum.
.SS Salt Master Stops Responding
.sp
There are known bugs with ZeroMQ versions less than 2.1.11 which can cause the
Salt master to not respond properly. If you\(aqre running a ZeroMQ version greater
than or equal to 2.1.9, you can work around the bug by setting the sysctls
\fBnet.core.rmem_max\fP and \fBnet.core.wmem_max\fP to 16777216. Next, set the third
field in \fBnet.ipv4.tcp_rmem\fP and \fBnet.ipv4.tcp_wmem\fP to at least 16777216.
.sp
You can do it manually with something like:
.sp
.nf
.ft C
# echo 16777216 > /proc/sys/net/core/rmem_max
# echo 16777216 > /proc/sys/net/core/wmem_max
# echo "4096 87380 16777216" > /proc/sys/net/ipv4/tcp_rmem
# echo "4096 87380 16777216" > /proc/sys/net/ipv4/tcp_wmem
.ft P
.fi
.sp
Or with the following Salt state:
.sp
.nf
.ft C
net.core.rmem_max:
  sysctl:
    \- present
    \- value: 16777216

net.core.wmem_max:
  sysctl:
    \- present
    \- value: 16777216

net.ipv4.tcp_rmem:
  sysctl:
    \- present
    \- value: 4096 87380 16777216

net.ipv4.tcp_wmem:
  sysctl:
    \- present
    \- value: 4096 87380 16777216
.ft P
.fi
.SS Salt and SELinux
.sp
Currently there are no SELinux policies for Salt. For the most part Salt runs
without issue when SELinux is running in Enforcing mode. This is because when
the minion executes as a daemon the type context is changed to \fBinitrc_t\fP.
The problem with SELinux arises when using salt\-call or running the minion in
the foreground, since the type context stays \fBunconfined_t\fP.
.sp
This problem is generally manifest in the rpm install scripts when using the
pkg module. Until a full SELinux Policy is available for Salt the solution
to this issue is to set the execution context of \fBsalt\-call\fP and
\fBsalt\-minion\fP to rpm_exec_t:
.sp
.nf
.ft C
# chcon \-t system_u:system_r:rpm_exec_t:s0 /usr/bin/salt\-minion
# chcon \-t system_u:system_r:rpm_exec_t:s0 /usr/bin/salt\-call
.ft P
.fi
.sp
This works well, because the \fBrpm_exec_t\fP context has very broad control over
other types.
.SS Red Hat Enterprise Linux 5
.sp
Salt requires Python 2.6 or 2.7. Red Hat Enterprise Linux 5 and its variants
come with Python 2.4 installed by default. When installing on RHEL 5 from the
\fI\%EPEL repository\fP this is handled for you. But, if you run Salt from git, be
advised that its dependencies need to be installed from EPEL and that Salt
needs to be run with the \fBpython26\fP executable.
.SS Common YAML Gotchas
.sp
An extensive list of
\fBYAML idiosyncrasies\fP
has been compiled.
.SS Live Python Debug Output
.sp
If the minion or master seems to be unresponsive, a SIGUSR1 can be passed to
the processes to display where in the code they are running. If encountering a
situation like this, this debug information can be invaluable. First make
sure the master of minion are running in the foreground:
.sp
.nf
.ft C
# salt\-master \-l debug
# salt\-minion \-l debug
.ft P
.fi
.sp
The pass the signal to the master or minion when it seems to be unresponsive:
.sp
.nf
.ft C
killall \-SIGUSR1 salt\-master
killall \-SIGUSR1 salt\-minion
.ft P
.fi
.sp
When filing an issue or sending questions to the mailing list for a problem
with an unresponsive daemon this information can be invaluable.
.SH YAML IDIOSYNCRASIES
.sp
One of Salt\(aqs strengths, the use of existing serialization systems for
representing SLS data, can also backfire. \fI\%YAML\fP is a general purpose system
and there are a number of things that would seem to make sense in an sls
file that cause YAML issues. It is wise to be aware of these issues. While
reports or running into them are generally rare they can still crop up at
unexpected times.
.SS Spaces vs Tabs
.sp
\fI\%YAML uses spaces\fP, period. Do not use tabs in your SLS files! If strange
errors are coming up in rendering SLS files, make sure to check that
no tabs have crept in! In Vim, after enabling search highlighting
with: \fB:set hlsearch\fP,  you can check with the following key sequence in
normal mode(you can hit \fIESC\fP twice to be sure): \fB/\fP, \fICtrl\-v\fP, \fITab\fP, then
hit \fIEnter\fP. Also, you can convert tabs to 2 spaces by these commands in Vim:
\fB:set tabstop=2 expandtab\fP and then \fB:retab\fP.
.SS Indentation
.sp
The suggested syntax for YAML files is to use 2 spaces for indentation,
but YAML will follow whatever indentation system that the individual file
uses. Indentation of two spaces works very well for SLS files given the
fact that the data is uniform and not deeply nested.
.SS Nested Dicts (key=value)
.sp
When \fI\%dicts\fP: are more deeply nested, they no longer follow the same
indentation logic. This is rarely something that comes up in Salt,
since deeply nested options like these are discouraged when making State
modules, but some do exist. A good example is the context and default options
in the \fBfile.managed\fP state:
.sp
.nf
.ft C
/etc/http/conf/http.conf:
  file:
    \- managed
    \- source: salt://apache/http.conf
    \- user: root
    \- group: root
    \- mode: 644
    \- template: jinja
    \- context:
        custom_var: "override"
    \- defaults:
        custom_var: "default value"
        other_var: 123
.ft P
.fi
.sp
Notice that the spacing used is 2 spaces, and that when defining the context
and defaults options there is a 4 space indent. If only a 2 space indent is
used then the information will not be loaded correctly. If using double spacing
is not desirable, then a deeply nested dict can be declared with curly braces:
.sp
.nf
.ft C
/etc/http/conf/http.conf:
  file:
    \- managed
    \- source: salt://apache/http.conf
    \- user: root
    \- group: root
    \- mode: 644
    \- template: jinja
    \- context: {
      custom_var: "override" }
    \- defaults: {
      custom_var: "default value",
      other_var: 123 }
.ft P
.fi
.SS True/False, Yes/No, On/Off
.sp
PyYAML will load these values as boolean \fBTrue\fP or \fBFalse\fP. Un\-capitalized
versions will also be loaded as booleans (\fBtrue\fP, \fBfalse\fP, \fByes\fP, \fBno\fP,
\fBon\fP, and \fBoff\fP). This can be especially problematic when constructing
Pillar data. Make sure that your Pillars which need to use the string versions
of these values are enclosed in quotes.
.SS Integers are Parsed as Integers
.sp
NOTE: This has been fixed in salt 0.10.0, as of this release passing an
integer that is preceded by a 0 will be correctly parsed
.sp
When passing \fI\%integers\fP into an SLS file, they are passed as integers. This means
that if a state accepts a string value and an integer is passed, that an
integer will be sent. The solution here is to send the integer as a string.
.sp
This is best explained when setting the mode for a file:
.sp
.nf
.ft C
/etc/vimrc:
  file:
    \- managed
    \- source: salt://edit/vimrc
    \- user: root
    \- group: root
    \- mode: 644
.ft P
.fi
.sp
Salt manages this well, since the mode is passed as 644, but if the mode is
zero padded as 0644, then it is read by YAML as an integer and evaluated as
an octal value, 0644 becomes 420. Therefore, if the file mode is
preceded by a 0 then it needs to be passed as a string:
.sp
.nf
.ft C
/etc/vimrc:
  file:
    \- managed
    \- source: salt://edit/vimrc
    \- user: root
    \- group: root
    \- mode: \(aq0644\(aq
.ft P
.fi
.SS YAML does not like "Double Short Decs"
.sp
If I can find a way to make YAML accept "Double Short Decs" then I will, since
I think that double short decs would be awesome. So what is a "Double Short
Dec"? It is when you declare a multiple short decs in one ID. Here is a
standard short dec, it works great:
.sp
.nf
.ft C
vim:
  pkg.installed
.ft P
.fi
.sp
The short dec means that there are no arguments to pass, so it is not required
to add any arguments, and it can save space.
.sp
YAML though, gets upset when declaring multiple short decs, for the record...
.sp
THIS DOES NOT WORK:
.sp
.nf
.ft C
vim:
  pkg.installed
  user.present
.ft P
.fi
.sp
Similarly declaring a short dec in the same ID dec as a standard dec does not
work either...
.sp
ALSO DOES NOT WORK:
.sp
.nf
.ft C
fred:
  user.present
  ssh_auth.present:
    \- name: AAAAB3NzaC...
    \- user: fred
    \- enc: ssh\-dss
    \- require:
      \- user: fred
.ft P
.fi
.sp
The correct way is to define them like this:
.sp
.nf
.ft C
vim:
  pkg.installed: []
  user.present: []

fred:
  user.present: []
  ssh_auth.present:
    \- name: AAAAB3NzaC...
    \- user: fred
    \- enc: ssh\-dss
    \- require:
      \- user: fred
.ft P
.fi
.sp
Alternatively,  they can be defined the "old way",  or with multiple
"full decs":
.sp
.nf
.ft C
vim:
  pkg:
    \- installed
  user:
    \- present

fred:
  user:
    \- present
  ssh_auth:
    \- present
    \- name: AAAAB3NzaC...
    \- user: fred
    \- enc: ssh\-dss
    \- require:
      \- user: fred
.ft P
.fi
.SS YAML support only plain ASCII
.sp
According to YAML specification, only ASCII characters can be used.
.sp
Within double\-quotes, special characters may be represented with C\-style
escape sequences starting with a backslash ( \e ).
.sp
Examples:
.sp
.nf
.ft C
\- micro: "\eu00b5"
\- copyright: "\eu00A9"
\- A: "\ex41"
\- alpha: "\eu0251"
\- Alef: "\eu05d0"
.ft P
.fi
.sp
List of usable \fI\%Unicode characters\fP  will help you to identify correct numbers.
.sp
Python can also be used to discover the Unicode number for a character:
.sp
.nf
.ft C
repr(u"Text with wrong characters i need to figure out")
.ft P
.fi
.sp
This shell command can find wrong characters in your SLS files:
.sp
.nf
.ft C
find . \-name \(aq*.sls\(aq  \-exec  grep \-\-color=\(aqauto\(aq \-P \-n \(aq[^\ex00\-\ex7F]\(aq \e{} \e;
.ft P
.fi
.SH COMMUNITY
.sp
Join the Salt!
.sp
There are many ways to participate in and communicate with the Salt community.
.sp
Salt has an active IRC channel and a mailing list.
.SS Mailing List
.sp
Join the \fI\%salt-users mailing list\fP. It is the best place to ask questions
about Salt and see whats going on with Salt development! The Salt mailing list
is hosted by Google Groups. It is open to new members.
.sp
\fI\%https://groups.google.com/forum/#!forum/salt-users\fP
.SS IRC
.sp
The \fB#salt\fP IRC channel is hosted on the popular \fI\%Freenode\fP network. You
can use the \fI\%Freenode webchat client\fP right from your browser.
.sp
\fI\%Logs of the IRC channel activity\fP are being collected courtesy of Moritz Lenz.
.SS Salt development
.sp
If you wish to discuss the development of Salt itself join us in
\fB#salt\-devel\fP.
.SS Follow on Github
.sp
The Salt code is developed via Github. Follow Salt for constant updates on what
is happening in Salt development:
.sp
\fI\%https://github.com/saltstack/salt\fP
.SS The Red45 Blog
.sp
News and thoughts on Salt and related projects is often posted on Thomas\(aq blog
\fI\%The Red45\fP:
.sp
\fI\%http://red45.wordpress.com/\fP
.SS Example Salt States
.sp
The official \fBsalt\-states\fP repository is:
\fI\%https://github.com/saltstack/salt-states\fP
.sp
A few examples of salt states from the community:
.INDENT 0.0
.IP \(bu 2
\fI\%https://github.com/blast-hardcheese/blast-salt-states\fP
.IP \(bu 2
\fI\%https://github.com/kevingranade/kevingranade-salt-state\fP
.IP \(bu 2
\fI\%https://github.com/uggedal/states\fP
.IP \(bu 2
\fI\%https://github.com/mattmcclean/salt-openstack/tree/master/salt\fP
.IP \(bu 2
\fI\%https://github.com/rentalita/ubuntu-setup/\fP
.IP \(bu 2
\fI\%https://github.com/brutasse/states\fP
.IP \(bu 2
\fI\%https://github.com/bclermont/states\fP
.IP \(bu 2
\fI\%https://github.com/pcrews/salt-data\fP
.UNINDENT
.SS Follow on ohloh
.sp
\fI\%https://www.ohloh.net/p/salt\fP
.SS Other community links
.INDENT 0.0
.IP \(bu 2
\fI\%Salt Stack Inc.\fP
.IP \(bu 2
\fI\%Subreddit\fP
.IP \(bu 2
\fI\%Google+\fP
.IP \(bu 2
\fI\%YouTube\fP
.IP \(bu 2
\fI\%Facebook\fP
.IP \(bu 2
\fI\%Twitter\fP
.IP \(bu 2
\fI\%Wikipedia page\fP
.UNINDENT
.SS Developing Salt
.sp
There is a great need for contributions to salt and patches are welcome! The goal
here is to make contributions clear, make sure there is a trail for where the code
has come from, and most importantly, to give credit where credit is due!
.sp
There are a number of ways to contribute to salt development.
.SS Sending a Github pull request
.sp
This is the preferred method for contributions. Simply create a Github
fork, commit changes to the fork, and then open up a pull request.
.sp
The following is an example (from \fI\%Open Comparison Contributing Docs\fP )
of an efficient workflow for forking, cloning, branching, committing, and
sending a pull request for a github repository.
.sp
First, make a local clone of your github fork of the salt github repo and make
edits and changes locally.
.sp
Then, create a new branch on your clone by entering the following commands:
.sp
.nf
.ft C
git checkout \-b fixed\-broken\-thing

Switched to a new branch \(aqfixed\-broken\-thing\(aq
.ft P
.fi
.sp
Choose a name for your branch that describes its purpose.
.sp
Now commit your changes to this new branch with the following command:
.sp
.nf
.ft C
#add and commit all changes at once
git commit \-a \-m \(aqdescription of my fixes for the broken thing\(aq
.ft P
.fi
.sp
And then push your locally committed changes back up to GitHub:
.sp
.nf
.ft C
git push \-\-set\-upstream origin fixed\-broken\-thing
.ft P
.fi
.sp
Now go look at your fork of the salt repo on the GitHub website. The new
branch will now be listed under the "Source" tab where it says "Switch Branches".
Select the new branch from this list, and then click the "Pull request" button.
.sp
Put in a descriptive comment, and include links to any project issues related to the pull request.
.sp
The repo managers will be notified of your pull request and it will
be reviewed. If a reviewer asks for changes, just make the changes locally in the
same local feature branch, push them to GitHub, then add a comment to the
discussion section of the pull request.
.IP Note
Travis\-CI
.sp
To make reviewing pull requests easier for the maintainers, please enable Travis\-CI on
the fork. Salt is already configured, so simply follow the first
2 steps on the Travis\-CI \fI\%Getting Started Doc\fP.
.RE
.SS Keeping Salt Forks in Sync
.sp
Salt is advancing quickly. It is therefore critical to pull upstream changes from master into forks on a regular basis. Nothing is worse than putting in a days of hard work into a pull request only to have it rejected because it has diverged too far from master.
.sp
To pull in upstream changes:
.sp
.nf
.ft C
# For ssh github
git remote add upstream git@github.com:saltstack/salt.git
git fetch upstream

# For https github
git remote add upstream https://github.com/saltstack/salt.git
git fetch upstream
.ft P
.fi
.sp
To check the log to be sure that you actually want the changes, run this before merging:
.sp
.nf
.ft C
git log upstream/develop
.ft P
.fi
.sp
Then to accept the changes and merge into the current branch:
.sp
.nf
.ft C
git merge upstream/develop
.ft P
.fi
.sp
For more info, see \fI\%Github Fork a Repo Guide\fP or \fI\%Open Comparison Contributing Docs\fP
.SS Posting patches to the mailing list
.sp
Patches will also be accepted by email. Format patches using \fI\%git format-patch\fP
and send them to the Salt users mailing list. The contributor will then get credit
for the patch, and the Salt community will have an archive of the patch and a place for discussion.
.SS Installing Salt for development
.sp
Clone the repository using:
.sp
.nf
.ft C
git clone https://github.com/saltstack/salt
.ft P
.fi
.IP Note
tags
.sp
Just cloning the repository is enough to work with Salt and make
contributions. However, fetching additional tags from git is required to
have Salt report the correct version for itself. To do this, first
add the git repository as an upstream source:
.sp
.nf
.ft C
git remote add upstream http://github.com/saltstack/salt
.ft P
.fi
.sp
Fetching tags is done with the git \(aqfetch\(aq utility:
.sp
.nf
.ft C
git fetch \-\-tags upstream
.ft P
.fi
.RE
.sp
Create a new \fI\%virtualenv\fP:
.sp
.nf
.ft C
virtualenv /path/to/your/virtualenv
.ft P
.fi
.sp
On Arch Linux, where Python 3 is the default installation of Python, use the
\fBvirtualenv2\fP command instead of \fBvirtualenv\fP.
.IP Note
Using system Python modules in the virtualenv
.sp
To use already\-installed python modules in virtualenv (instead of having pip
download and compile new ones), run \fBvirtualenv \-\-system\-site\-packages\fP
Using this method eliminates the requirement to install the salt dependencies
again, although it does assume that the listed modules are all installed in the
system PYTHONPATH at the time of virtualenv creation.
.RE
.sp
Activate the virtualenv:
.sp
.nf
.ft C
source /path/to/your/virtualenv/bin/activate
.ft P
.fi
.sp
Install Salt (and dependencies) into the virtualenv:
.sp
.nf
.ft C
pip install M2Crypto    # Don\(aqt install on Debian/Ubuntu (see below)
pip install pyzmq PyYAML pycrypto msgpack\-python jinja2 psutil
pip install \-e ./salt   # the path to the salt git clone from above
.ft P
.fi
.IP Note
Installing M2Crypto
.sp
\fBswig\fP and \fBlibssl\-dev\fP are required to build M2Crypto. To fix
the error \fBcommand \(aqswig\(aq failed with exit status 1\fP while installing M2Crypto,
try installing it with the following command:
.sp
.nf
.ft C
env SWIG_FEATURES="\-cpperraswarn \-includeall \-D__\(gauname \-m\(ga__ \-I/usr/include/openssl" pip install M2Crypto
.ft P
.fi
.sp
Debian and Ubuntu systems have modified openssl libraries and mandate that
a patched version of M2Crypto be installed. This means that M2Crypto
needs to be installed via apt:
.sp
.nf
.ft C
apt\-get install python\-m2crypto
.ft P
.fi
.sp
This also means that pulling in the M2Crypto installed using apt requires using
\fB\-\-system\-site\-packages\fP when creating the virtualenv.
.RE
.IP Note
Installing psutil
.sp
Python header files are required to build this module, otherwise the pip
install will fail. If your distribution separates binaries and headers into
separate packages, make sure that you have the headers installed. In most
Linux distributions which split the headers into their own package, this
can be done by installing the \fBpython\-dev\fP or \fBpython\-devel\fP package.
For other platforms, the package will likely be similarly named.
.RE
.IP Note
Important note for those developing using RedHat variants
.sp
For developers using a RedHat variant, be advised that the package
provider for newer Redhat\-based systems (\fByumpkg.py\fP) relies on RedHat\(aqs python
interface for yum. The variants that use this module to provide package
support include the following:
.INDENT 0.0
.IP \(bu 2
\fI\%RHEL\fP and \fI\%CentOS\fP releases 6 and later
.IP \(bu 2
\fI\%Fedora Linux\fP releases 11 and later
.IP \(bu 2
\fI\%Amazon Linux\fP
.UNINDENT
.sp
Developers using one of these systems should create the salt virtualenv using the
\fB\-\-system\-site\-packages\fP option to ensure that the correct modules are available.
.RE
.IP Note
Installing dependencies on OS X.
.sp
You can install needed dependencies on OS X using homebrew or macports.
See \fBOS X Installation\fP
.RE
.SS Running a self\-contained development version
.sp
During development it is easiest to be able to run the Salt master and minion
that are installed in the virtualenv you created above, and also to have all
the configuration, log, and cache files contained in the virtualenv as well.
.sp
Copy the master and minion config files into your virtualenv:
.sp
.nf
.ft C
mkdir \-p /path/to/your/virtualenv/etc/salt
cp ./salt/conf/master /path/to/your/virtualenv/etc/salt/master
cp ./salt/conf/minion /path/to/your/virtualenv/etc/salt/minion
.ft P
.fi
.sp
Edit the master config file:
.INDENT 0.0
.IP 1. 3
Uncomment and change the \fBuser: root\fP value to your own user.
.IP 2. 3
Uncomment and change the \fBroot_dir: /\fP value to point to
\fB/path/to/your/virtualenv\fP.
.IP 3. 3
If you are running version 0.11.1 or older, uncomment and change the
\fBpidfile: /var/run/salt\-master.pid\fP value to point to
\fB/path/to/your/virtualenv/salt\-master.pid\fP.
.IP 4. 3
If you are also running a non\-development version of Salt you will have to
change the \fBpublish_port\fP and \fBret_port\fP values as well.
.UNINDENT
.sp
Edit the minion config file:
.INDENT 0.0
.IP 1. 3
Repeat the edits you made in the master config for the \fBuser\fP and
\fBroot_dir\fP values as well as any port changes.
.IP 2. 3
If you are running version 0.11.1 or older, uncomment and change the
\fBpidfile: /var/run/salt\-minion.pid\fP value to point to
\fB/path/to/your/virtualenv/salt\-minion.pid\fP.
.IP 3. 3
Uncomment and change the \fBmaster: salt\fP value to point at \fBlocalhost\fP.
.IP 4. 3
Uncomment and change the \fBid:\fP value to something descriptive like
"saltdev". This isn\(aqt strictly necessary but it will serve as a reminder of
which Salt installation you are working with.
.UNINDENT
.IP Note
Using \fIsalt\-call\fP with a \fBStandalone Minion\fP
.sp
If you plan to run \fIsalt\-call\fP with this self\-contained development
environment in a masterless setup, you should invoke \fIsalt\-call\fP with
\fB\-c /path/to/your/virtualenv/etc/salt\fP so that salt can find the minion
config file. Without the \fB\-c\fP option, Salt finds its config files in
\fI/etc/salt\fP.
.RE
.sp
Start the master and minion, accept the minion\(aqs key, and verify your local Salt
installation is working:
.sp
.nf
.ft C
cd /path/to/your/virtualenv
salt\-master \-c ./etc/salt \-d
salt\-minion \-c ./etc/salt \-d
salt\-key \-c ./etc/salt \-L
salt\-key \-c ./etc/salt \-A
salt \-c ./etc/salt \(aq*\(aq test.ping
.ft P
.fi
.sp
Running the master and minion in debug mode can be helpful when developing. To
do this, add \fB\-l debug\fP to the calls to \fBsalt\-master\fP and \fBsalt\-minion\fP.
If you would like to log to the console instead of to the log file, remove the
\fB\-d\fP.
.sp
Once the minion starts, you may see an error like the following:
.sp
.nf
.ft C
zmq.core.error.ZMQError: ipc path "/path/to/your/virtualenv/var/run/salt/minion/minion_event_7824dcbcfd7a8f6755939af70b96249f_pub.ipc" is longer than 107 characters (sizeof(sockaddr_un.sun_path)).
.ft P
.fi
.sp
This means the the path to the socket the minion is using is too long. This is
a system limitation, so the only workaround is to reduce the length of this
path. This can be done in a couple different ways:
.INDENT 0.0
.IP 1. 3
Create your virtualenv in a path that is short enough.
.IP 2. 3
Edit the \fBsock_dir\fP minion config variable and reduce its
length. Remember that this path is relative to the value you set in
\fBroot_dir\fP.
.UNINDENT
.sp
\fBNOTE:\fP The socket path is limited to 107 characters on Solaris and Linux,
and 103 characters on BSD\-based systems.
.IP Note
File descriptor limits
.sp
Ensure that the system open file limit is raised to at least 2047:
.sp
.nf
.ft C
# check your current limit
ulimit \-n

# raise the limit. persists only until reboot
# use \(aqlimit descriptors 2047\(aq for c\-shell
ulimit \-n 2047
.ft P
.fi
.sp
To set file descriptors on OSX, refer to the \fBOS X Installation\fP instructions.
.RE
.SS Using easy_install to Install Salt
.sp
If you are installing using \fBeasy_install\fP, you will need to define a
\fBUSE_SETUPTOOLS\fP environment variable, otherwise dependencies will not
be installed.
.INDENT 0.0
.INDENT 3.5
$ USE_SETUPTOOLS=1 easy_install salt
.UNINDENT
.UNINDENT
.SS Running the tests
.sp
You will need \fBmock\fP to run the tests:
.sp
.nf
.ft C
pip install mock
.ft P
.fi
.sp
If you are on Python < 2.7 then you will also need unittest2:
.sp
.nf
.ft C
pip install unittest2
.ft P
.fi
.sp
Finally you use setup.py to run the tests with the following command:
.sp
.nf
.ft C
\&./setup.py test
.ft P
.fi
.sp
For greater control while running the tests, please try:
.sp
.nf
.ft C
\&./tests/runtests.py \-h
.ft P
.fi
.SS Editing and previewing the documention
.sp
You need \fBsphinx\-build\fP command to build the docs. In Debian/Ubuntu this is
provided in the \fBpython\-sphinx\fP package. Sphinx can also be installed
to a virtualenv using pip:
.sp
.nf
.ft C
pip install Sphinx
.ft P
.fi
.sp
Change to salt documention directory, then:
.sp
.nf
.ft C
cd doc; make html
.ft P
.fi
.INDENT 0.0
.IP \(bu 2
This will build the HTML docs. Run \fBmake\fP without any arguments to see the
available make targets, which include \fBhtml\fP, \fBman\fP, and
\fBtext\fP.
.IP \(bu 2
The docs then are built within the \fBdocs/_build/\fP folder. To update
the docs after making changes, run \fBmake\fP again.
.IP \(bu 2
The docs use \fI\%reStructuredText\fP for markup.
See a live demo at \fI\%http://rst.ninjs.org/\fP.
.IP \(bu 2
The help information on each module or state is culled from the python code
that runs for that piece. Find them in \fBsalt/modules/\fP or \fBsalt/states/\fP.
.IP \(bu 2
To build the docs on Arch Linux, the \fBpython2\-sphinx\fP package is
required. Additionally, it is necessary to tell \fBmake\fP where to find
the proper \fBsphinx\-build\fP binary, like so:
.sp
.nf
.ft C
make SPHINXBUILD=sphinx\-build2 html
.ft P
.fi
.IP \(bu 2
To build the docs on RHEL/CentOS 6, the \fBpython\-sphinx10\fP package
must be installed from EPEL, and the following make command must be used:
.sp
.nf
.ft C
make SPHINXBUILD=sphinx\-1.0\-build html
.ft P
.fi
.UNINDENT
.SH SALT BASED PROJECTS
.sp
A number of unofficial open source projects, based on Salt, or written to
enhance Salt have been created.
.SS Salt Sandbox
.sp
Created by Aaron Bull Schaefer, aka "elasticdog".
.sp
\fI\%https://github.com/elasticdog/salt-sandbox\fP
.sp
Salt Sandbox is a multi\-VM Vagrant\-based Salt development environment used
for creating and testing new Salt state modules outside of your production
environment. It\(aqs also a great way to learn firsthand about Salt and its
remote execution capabilities.
.sp
Salt Sandbox will set up three separate virtual machines:
.INDENT 0.0
.IP \(bu 2
salt.example.com \- the Salt master server
.IP \(bu 2
minion1.example.com \- the first Salt minion machine
.IP \(bu 2
minion2.example.com \- the second Salt minion machine
.UNINDENT
.sp
These VMs can be used in conjunction to segregate and test your modules based
on node groups, top file environments, grain values, etc. You can even test
modules on different Linux distributions or release versions to better match
your production infrastructure.
.SH SALT EVENT SYSTEM
.sp
Salt 0.9.10 introduced the Salt Event System. This system is used to fire
off events enabling third party applications or external processes to react
to behavior within Salt.
.sp
The event system is comprised of a few components, the event sockets which
publish events, and the event library which can listen to events and send
events into the salt system.
.SS Listening for Events
.sp
The event system is accessed via the event library and can only be accessed
by the same system user that Salt is running as. To listen to events a
SaltEvent object needs to be created and then the get_event function needs to
be run. The SaltEvent object needs to know the location that the Salt Unix
sockets are kept. In the configuration this is the \fBsock_dir\fP option. The
\fBsock_dir\fP option defaults to "/var/run/salt/master" on most systems.
.sp
The following code will check for a single event:
.sp
.nf
.ft C
import salt.utils.event

event = salt.utils.event.MasterEvent(\(aq/var/run/salt/master\(aq)

data = event.get_event()
.ft P
.fi
.sp
Events will also use a "tag". A "tag" allows for events to be filtered. By
default all events will be returned, but if only authentication events are
desired, then pass the tag "auth". Also, the get_event method has a default
poll time assigned of 5 seconds, to change this time set the "wait" option.
This example will only listen for auth events and will wait for 10 seconds
instead of the default 5.
.sp
.nf
.ft C
import salt.utils.event

event = salt.utils.event.MasterEvent(\(aq/var/run/salt/master\(aq)

data = event.get_event(wait=10, tag=\(aqauth\(aq)
.ft P
.fi
.sp
Instead of looking for a single event, the iter_events method can be used to
make a generator which will continually yield salt events. The iter_events
method also accepts a tag, but not a wait time:
.sp
.nf
.ft C
import salt.utils.event

event = salt.utils.event.MasterEvent(\(aq/var/run/salt/master\(aq)

for data in event.iter_events(tag=\(aqauth\(aq):
    print(data)
.ft P
.fi
.SH THE SALT MINE
.sp
Granted, it took a while for this name to be used in Salt, but version 0.15.0
introduces a new system to Salt called the Salt Mine.
.sp
The Salt Mine is used to bridge the gap between setting static variables and
gathering live data. The Salt mine is used to collect arbitrary data from
minions and store it on the master. This data is then made available to
all minions via the \fBmine\fP module.
.sp
The data is gathered on the minion and sent back to the master where only
the most recent data is maintained (if long term data is required use
returners or the external job cache).
.SS Mine Functions
.sp
To enable the Salt Mine the \fImine_functions\fP option needs to be applied to a
minion. This option can be applied via the minion\(aqs configuration file, or the
minion\(aqs pillar. The \fImine_functions\fP option dictates what functions are being
executed and allows for arguments to be passed in:
.sp
.nf
.ft C
mine_functions:
  network.interfaces: []
  test.ping: []
.ft P
.fi
.SS Mine Interval
.sp
The Salt Mine functions are executed when the minion starts and at a given
interval by the scheduler. The default interval is every 60 minutes and can
be adjusted for the minion via the \fImine_interval\fP option:
.sp
.nf
.ft C
mine_interval: 60
.ft P
.fi
.SH SALT VIRT - THE SALT STACK CLOUD CONTROLLER
.sp
The Salt Virt cloud controller capability was initial added to Salt in version
0.14.0 as an alpha technology.
.sp
The initial Salt Virt system supports core cloud operations:
.INDENT 0.0
.IP \(bu 2
Virtual machine deployment
.IP \(bu 2
Inspection of deployed VMs
.IP \(bu 2
Virtual machine migration
.IP \(bu 2
Network profiling
.IP \(bu 2
Automatic VM integration with all aspects of Salt
.IP \(bu 2
Image Pre\-seeding
.UNINDENT
.sp
Many features are currently under development to enhance the capabilities of
the Salt Virt systems.
.IP Note
It is noteworthy that Salt was originally developed with the intent of
using the Salt communication system as the backbone to a cloud
controller. This means that the Salt Virt system is not an
afterthought, simply a system that took the back seat to other
development. The original attempt to develop the cloud control aspects
of Salt was a project called butter. This project never took off, but
was functional and proves the early viability of Salt to be a cloud
controller.
.RE
.SS Salt Virt Tutorial
.sp
A tutorial about how to get Salt Virt up and running has been added to the
tutorial section:
.sp
\fBCloud Controller Tutorial\fP
.SS The Salt Virt Runner
.sp
The point of interaction with the cloud controller is the \fIvirt\fP runner. The
\fIvirt\fP runner comes with routines to execute specific virtual machine
routines.
.sp
Reference documentation for the virt runner is available with the runner
module documentation:
.sp
\fBVirt Runner Reference\fP
.SS Based on Live State Data
.sp
The Salt Virt system is based on using Salt to query live data about
hypervisors and then using the data gathered to make decisions about cloud
operations. This means that no external resources are required to run Salt
Virt, and that the information gathered about the cloud is live and accurate.
.SH VIRTUAL MACHINE NETWORK PROFILES
.sp
Salt Virt allows for the network devices created for deployed virtual machines
to be finely configured. The configuration is a simple data structure which is
read from the \fBconfig.option\fP function, meaning that the configuration can be
stored in the minion config file, the master config file, or the minion\(aqs
pillar.
.sp
This configuration option is called \fIvirt.nic\fP. By default the \fIvirt.nic\fP
option is empty but defaults to a data structure which looks like this:
.sp
.nf
.ft C
virt.nic:
  default:
    eth0:
      bridge: br0
      model: virtio
.ft P
.fi
.IP Note
The model does not need to be defined, Salt will default to the optimal
model used by the underlying hypervisor, in the case of kvm this model
is \fIvirtio\fP
.RE
.sp
This configuration sets up a network profile called default. The default
profile creates a single Ethernet device on the virtual machine that is
bridged to the hypervisor\(aqs \fIbr0\fP interface. This default setup does not
require setting up the \fIvirt.nic\fP configuration, and is the reason why
a default install only requires setting up the \fIbr0\fP bridge device on the
hypervisor.
.SS Define More Profiles
.sp
Many environments will require more complex network profiles and may require
more than one profile, this can be easily accomplished:
.sp
.nf
.ft C
virt.nic:
  dual:
    eth0:
      bridge: service_br
    eth1:
      bridge: storage_br
  single:
    eth0:
      bridge: service_br
  triple:
    eth0:
      bridge: service_br
    eth1:
      bridge: storage_br
    eth2:
      bridge: dmz_br
  all:
    eth0:
      bridge: service_br
    eth1:
      bridge: storage_br
    eth2:
      bridge: dmz_br
    eth3:
      bridge: database_br
  dmz:
    eth0:
      bridge: service_br
    eth1:
      bridge: dmz_br
  database:
    eth0:
      bridge: service_br
    eth1:
      bridge: database_br
.ft P
.fi
.sp
This configuration allows for one of six profiles to be selected, allowing
virtual machines to be created which attach to different network depending
on the needs of the deployed vm.
.SH RUNNING THE TESTS
.sp
To run the tests, use \fBtests/runtests.py\fP, see \fB\-\-help\fP for more info.
.sp
Examples:
.INDENT 0.0
.IP \(bu 2
To run all tests: \fBsudo ./tests/runtests.py\fP
.IP \(bu 2
Run unit tests only: \fBsudo ./tests/runtests.py \-\-unit\-tests\fP
.UNINDENT
.sp
You will need \(aqmock\(aq (\fI\%https://pypi.python.org/pypi/mock\fP) in addition to salt requirements in order to run the tests.
.SS Writing Tests
.sp
Salt uses a test platform to verify functionality of components in a simple
way. Two testing systems exist to enable testing salt functions in somewhat
real environments. The two subsystems available are integration tests and
unit tests.
.sp
Salt uses the python standard library unittest2 system for testing.
.SH INTEGRATION TESTS
.sp
The integration tests start up a number of salt daemons to test functionality
in a live environment. These daemons include 2 salt masters, 1 syndic and 2
minions. This allows for the syndic interface to be tested and master/minion
communication to be verified. All of the integration tests are executed as
live salt commands sent through the started daemons.
.INDENT 0.0
.IP \(bu 2
\fBWriting integration tests\fP
.UNINDENT
.sp
Integration tests are particularly good at testing modules, states and shell
commands.
.SH UNIT TESTS
.sp
Direct unit tests are also available, these tests are good for internal
functions.
.SH INTEGRATION TESTS
.sp
The Salt integration tests come with a number of classes and methods which
allow for components to be easily tested. These classes are generally inherited
from and provide specific methods for hooking into the running integration test
environment created by the integration tests.
.sp
It is noteworthy that since integration tests validate against a running
environment that they are generally the preferred means to write tests.
.sp
The integration system is all located under tests/integration in the Salt
source tree.
.SS Integration Classes
.sp
The integration classes are located in tests/integration/__init__.py and
can be extended therein. There are three classes available to extend:
.SS ModuleCase
.sp
Used to define executions run via the master to minions and to call
single modules and states.
.sp
The available methods are as follows:
.INDENT 0.0
.TP
.B run_function:
Run a single salt function and condition the return down to match the
behavior of the raw function call. This will run the command and only
return the results from a single minion to verify.
.TP
.B state_result:
Return the result data from a single state return
.TP
.B run_state:
Run the state.single command and return the state return structure
.UNINDENT
.SS SyndicCase
.sp
Used to execute remote commands via a syndic, only used to verify the
capabilities of the Syndic.
.sp
The available methods are as follows:
.INDENT 0.0
.TP
.B run_function:
Run a single salt function and condition the return down to match the
behavior of the raw function call. This will run the command and only
return the results from a single minion to verify.
.UNINDENT
.SS ShellCase
.sp
Shell out to the scripts which ship with Salt.
.sp
The available methods are as follows:
.INDENT 0.0
.TP
.B run_script:
Execute a salt script with the given argument string
.TP
.B run_salt:
Execute the salt command, pass in the argument string as it would be
passed on the command line.
.TP
.B run_run:
Execute the salt\-run command, pass in the argument string as it would be
passed on the command line.
.TP
.B run_run_plus:
Execute Salt run and the salt run function and return the data from
each in a dict
.TP
.B run_key:
Execute the salt\-key command, pass in the argument string as it would be
passed on the command line.
.TP
.B run_cp:
Execute salt\-cp, pass in the argument string as it would be
passed on the command line.
.TP
.B run_call:
Execute salt\-call, pass in the argument string as it would be
passed on the command line.
.UNINDENT
.SS Examples
.SS Module Example via ModuleCase Class
.sp
Import the integration module, this module is already added to the python path
by the test execution. Inherit from the \fBintegration.ModuleCase\fP class. The
tests that execute against salt modules should be placed in the
\fItests/integration/modules\fP directory so that they will be detected by the test
system.
.sp
Now the workhorse method \fBrun_function\fP can be used to test a module:
.sp
.nf
.ft C
import os
import integration


class TestModuleTest(integration.ModuleCase):
    \(aq\(aq\(aq
    Validate the test module
    \(aq\(aq\(aq
    def test_ping(self):
        \(aq\(aq\(aq
        test.ping
        \(aq\(aq\(aq
        self.assertTrue(self.run_function(\(aqtest.ping\(aq))

    def test_echo(self):
        \(aq\(aq\(aq
        test.echo
        \(aq\(aq\(aq
        self.assertEqual(self.run_function(\(aqtest.echo\(aq, [\(aqtext\(aq]), \(aqtext\(aq)
.ft P
.fi
.sp
ModuleCase can also be used to test states, when testing states place the test
module in the \fItests/integration/states\fP directory. The \fBstate_result\fP and
the \fBrun_state\fP methods are the workhorse here:
.sp
.nf
.ft C
import os
import shutil
import integration

HFILE = os.path.join(integration.TMP, \(aqhosts\(aq)

class HostTest(integration.ModuleCase):
    \(aq\(aq\(aq
    Validate the host state
    \(aq\(aq\(aq

    def setUp(self):
        shutil.copyfile(os.path.join(integration.FILES, \(aqhosts\(aq), HFILE)
        super(HostTest, self).setUp()

    def tearDown(self):
        if os.path.exists(HFILE):
            os.remove(HFILE)
        super(HostTest, self).tearDown()

    def test_present(self):
        \(aq\(aq\(aq
        host.present
        \(aq\(aq\(aq
        name = \(aqspam.bacon\(aq
        ip = \(aq10.10.10.10\(aq
        ret = self.run_state(\(aqhost.present\(aq, name=name, ip=ip)
        result = self.state_result(ret)
        self.assertTrue(result)
        with open(HFILE) as fp_:
            output = fp_.read()
            self.assertIn(\(aq{0}\et\et{1}\(aq.format(ip, name), output)
.ft P
.fi
.sp
The above example also demonstrates using the integration files and the
integration state tree. The variable \fIintegration.FILES\fP will point to the
directory used to store files that can be used or added to to help enable tests
that require files. The location \fIintegration.TMP\fP can also be used to store
temporary files that the test system will clean up when the execution finishes.
.sp
The integration state tree can be found at \fItests/integration/files/file/base\fP.
This is where the referenced \fIhost.present\fP sls file resides.
.SS Shell Example via ShellCase
.sp
Validating the shell commands can be done via shell tests. Here are some
examples:
.sp
.nf
.ft C
import sys
import shutil
import tempfile

import integration

class KeyTest(integration.ShellCase):
    \(aq\(aq\(aq
    Test salt\-key script
    \(aq\(aq\(aq

    _call_binary_ = \(aqsalt\-key\(aq

    def test_list(self):
        \(aq\(aq\(aq
        test salt\-key \-L
        \(aq\(aq\(aq
        data = self.run_key(\(aq\-L\(aq)
        expect = [
                \(aqUnaccepted Keys:\(aq,
                \(aqAccepted Keys:\(aq,
                \(aqminion\(aq,
                \(aqsub_minion\(aq,
                \(aqRejected:\(aq, \(aq\(aq]
        self.assertEqual(data, expect)
.ft P
.fi
.sp
This example verifies that the \fBsalt\-key\fP command executes and returns as
expected by making use of the \fBrun_key\fP method.
.sp
All shell tests should be placed in the \fItests/integraion/shell\fP directory.
.SH REACTOR SYSTEM
.sp
Salt version 0.11.0 introduced the reactor system. The premise behind the
reactor system is that with Salt\(aqs events and the ability to execute commands a
logic engine could be put in place to allow events to trigger actions, or more
accurately, reactions.
.sp
This system binds sls files to event tags on the master. These sls files then
define reactions. This means that the reactor system has two parts. First, the
reactor option needs to be set in the master configuration file.  The reactor
option allows for event tags to be associated with sls reaction files. Second,
these reaction files use highdata (like the state system) to define reactions
to be executed.
.SS Event System
.sp
A basic understanding of the event system is required to understand reactors.
The event system is a local ZeroMQ PUB interface which fires salt events. This
event bus is an open system used for sending information notifying Salt and
other systems about operations.
.sp
The event system fires events with a very specific criteria. Every event has a
\fItag\fP which is comprised of a maximum of 20 characters. Event tags allow for
fast top level filtering of events. In addition to the tag, an event has a data
structure. This data structure is a dict containing information about the
event.
.SS Mapping Events to Reactor SLS Files
.sp
The event tag and data are both critical when working with the reactor system.
In the master configuration file under the reactor option, tags are associated
with lists of reactor sls formulas (globs can be used for matching):
.sp
.nf
.ft C
reactor:
  \- \(aqauth\(aq:
    \- /srv/reactor/authreact1.sls
    \- /srv/reactor/authreact2.sls
  \- \(aqminion_start\(aq:
    \- /srv/reactor/start.sls
.ft P
.fi
.sp
When an event with a tag of auth is fired the reactor will catch the event and
render the two listed files. The rendered files are standard sls files, so by
default they are yaml + Jinja. The Jinja is packed with a few data structures
similar to state and pillar sls files. The data available is found in the \fItag\fP
and \fIdata\fP variables. The \fItag\fP variable is just the tag in the fired event
and the \fIdata\fP variable is the event\(aqs data dict. Here is a simple reactor sls:
.sp
.nf
.ft C
{% if data[\(aqid\(aq] == \(aqmysql1\(aq %}
highstate_run:
  cmd.state.highstate:
    \- tgt: mysql1
{% endif %}
.ft P
.fi
.sp
This simple reactor file uses Jinja to further refine the reaction to be made.
If the \fIid\fP in the event data is mysql1 (if the name of the minion is mysql1) then
the following reaction is defined. The same data structure and compiler used
for the state system is used for the reactor system. The only difference is that the
data is matched up to the salt command API and the runner system. In this
example a command is published to the mysql1 minion with a function of
state.highstate. Similarly, a runner can be called:
.sp
.nf
.ft C
{% if data[\(aqdata\(aq][\(aqoverstate\(aq] == \(aqrefresh\(aq %}
overstate_run:
  runner.state.over
{% endif %}
.ft P
.fi
.sp
This example will execute the state.overstate runner and initiate an overstate
execution.
.SS Understanding the Structure of Reactor Formulas
.sp
While the reactor system uses the same data structure as the state system, this
data does not translate the same way to operations. In state formulas
information is mapped to the state functions, but in the reactor system
information is mapped to a number of available subsystems on the master. These
systems are the \fILocalClient\fP and the \fIRunners\fP. The \fIstate declaration\fP field
takes a reference to the function to call in each interface. So to trigger a
salt\-run call the \fIstate declaration\fP field will start with \fIrunner\fP, followed
by the runner function to call. This means that a call to what would be on the
command line \fIsalt\-run manage.up\fP will be \fIrunner.manage.up\fP. An example of
this in a reactor formula would look like this:
.sp
.nf
.ft C
manage_up:
  runner.manage.up
.ft P
.fi
.sp
If the runner takes arguments then they can be specified as well:
.sp
.nf
.ft C
overstate_dev_env:
  runner.state.over:
    \- env: dev
.ft P
.fi
.sp
Executing remote commands maps to the \fILocalClient\fP interface which is used by
the \fIsalt\fP command. This interface more specifically maps to the \fIcmd_async\fP
method inside of the \fILocalClient\fP class. This means that the arguments passed
are being passed to the \fIcmd_async\fP method, not the remote method. The field
starts with \fIcmd\fP to use the \fILocalClient\fP subsystem. The result is that to
execute a remote command it looks like this:
.sp
.nf
.ft C
clean_tmp:
  cmd.cmd.run:
    \- tgt: \(aq*\(aq
    \- arg:
      \- rm \-rf /tmp/*
.ft P
.fi
.sp
The \fIarg\fP option takes a list of arguments as they would be presented on the
command line, so the above declaration is the same as running this salt
command:
.sp
.nf
.ft C
salt \e* cmd.run \(aqrm \-rf /tmp/*\(aq
.ft P
.fi
.SH SALT CONVENTIONS
.SS Salt Release Process
.sp
The goal for Salt projects is to cut a new feature release every four to six
weeks.  This document outlines the process for these releases, and the
subsequent bug fix releases which follow.
.SS Feature Release Process
.sp
When a new release is ready to be cut, the person responsible for cutting the
release will follow the following steps (written using the 0.16 release as an
example):
.INDENT 0.0
.IP 1. 3
All open issues on the release milestone should be moved to the next release
milestone. (e.g. from the \fB0.16\fP milestone to the \fB0.17\fP milestone)
.IP 2. 3
Release notes should be created documenting the major new features and
bugfixes in the release.
.IP 3. 3
Create an annotated tag with only the major and minor version numbers,
preceded by the letter \fBv\fP.  (e.g. \fBv0.16\fP)  This tag will reside on the
\fBdevelop\fP branch.
.IP 4. 3
Create a branch for the new release, using only the major and minor version
numbers.  (e.g. \fB0.16\fP)
.IP 5. 3
On this new branch, create an annotated tag for the first revision release,
which is generally a release candidate.  It should be preceded by the letter
\fBv\fP.  (e.g. \fBv0.16.0RC\fP)
.IP 6. 3
The release should be packaged from this annotated tag and uploaded to PyPI.
.IP 7. 3
The packagers should be notified on the \fBsalt\-packagers\fP mailing list so
they can create packages for all the major operating systems.  (note that
release candidates should go in the testing repositories)
.IP 8. 3
After the packagers have been given a few days to compile the packages, the
release is announced on the \fBsalt\-users\fP mailing list.
.UNINDENT
.SS Maintenance and Bugfix Releases
.sp
Once a release has been cut, regular cherry\-picking sessions should begin to
cherry\-pick any bugfixes from the \fBdevelop\fP branch to the release branch
(e.g. \fB0.16\fP).  Once major bugs have been fixes and cherry\-picked, a bugfix
release can be cut:
.INDENT 0.0
.IP 1. 3
On the release branch (i.e. \fB0.16\fP), create an annotated tag for the
revision release.  It should be preceded by the letter \fBv\fP.  (e.g.
\fBv0.16.1\fP)  Release candidates are unnecessary for bugfix releases.
.IP 2. 3
The release should be packaged from this annotated tag and uploaded to PyPI.
.IP 3. 3
The packagers should be notified on the \fBsalt\-packagers\fP mailing list so
they can create packages for all the major operating systems.
.IP 4. 3
After the packagers have been given a few days to compile the packages, the
release is announced on the \fBsalt\-users\fP mailing list.
.UNINDENT
.SS Salt Coding Style
.sp
Salt is developed with a certain coding style, while the style is dominantly
PEP 8 it is not completely PEP 8. It is also noteworthy that a few
development techniques are also employed which should be adhered to. In the
end, the code is made to be "Salty".
.sp
Most importantly though, we will accept code that violates the coding style and
KINDLY ask the contributor to fix it, or go ahead and fix the code on behalf of
the contributor. Coding style is NEVER grounds to reject code contributions,
and is never grounds to talk down to another member of the community (There are
no grounds to treat others without respect, especially people working to
improve Salt)!!
.SS Strings
.sp
Salt follows a few rules when formatting strings:
.SS Single Quotes
.sp
In Salt, all strings use single quotes unless there is a good reason not to.
This means that docstrings use single quotes, standard strings use single
quotes etc.:
.sp
.nf
.ft C
def foo():
    \(aq\(aq\(aq
    A function that does things
    \(aq\(aq\(aq
    name = \(aqA name\(aq
    return name
.ft P
.fi
.SS Formatting Strings
.sp
All strings which require formatting should use the \fI.format\fP string method:
.sp
.nf
.ft C
data = \(aqsome text\(aq
more = \(aq{0} and then some\(aq.format(data)
.ft P
.fi
.sp
Make sure to use indices or identifiers in the format brackets, since empty
brackets are not supported by python 2.6.
.sp
Please do NOT use printf formatting.
.SS Docstring Conventions
.sp
Docstrings should always add a newline, docutils takes care of the new line and
it makes the code cleaner and more vertical:
.sp
\fIGOOD\fP:
.sp
.nf
.ft C
def bar():
    \(aq\(aq\(aq
    Here lies a docstring with a newline after the quotes and is the salty
    way to handle it! Vertical code is the way to go!
    \(aq\(aq\(aq
    return
.ft P
.fi
.sp
\fIBAD\fP:
.sp
.nf
.ft C
def baz():
    \(aq\(aq\(aqThis is not ok!\(aq\(aq\(aq
    return
.ft P
.fi
.SS Imports
.sp
Salt code prefers importing modules and not explicit functions. This is both a
style and functional preference. The functional preference originates around
the fact that the module import system used by pluggable modules will include
callable objects (functions) that exist in the direct module namespace. This
is not only messy, but may unintentionally expose code python libs to the Salt
interface and pose a security problem.
.sp
To say this more directly with an example, this is \fIGOOD\fP:
.sp
.nf
.ft C
import os

def minion_path():
    path = os.path.join(self.opts[\(aqcachedir\(aq], \(aqminions\(aq)
    return path
.ft P
.fi
.sp
This on the other hand is \fIDISCOURAGED\fP:
.sp
.nf
.ft C
from os.path import join

def minion_path():
path = join(self.opts[\(aqcachedir\(aq], \(aqminions\(aq)
return path
.ft P
.fi
.sp
The time when this is changed is for importing exceptions, generally directly
importing exceptions is preferred:
.sp
This is a good way to import exceptions:
.sp
.nf
.ft C
from salt.exceptions import CommandExecutionError
.ft P
.fi
.SS Vertical is Better
.sp
When writing Salt code, vertical code is generally preferred. This is not a hard
rule but more of a guideline. As PEP 8 specifies, Salt code should not exceed 79
characters on a line, but it is preferred to separate code out into more
newlines in some cases for better readability:
.sp
.nf
.ft C
import os

os.chmod(
        os.path.join(self.opts[\(aqsock_dir\(aq],
            \(aqminion_event_pub.ipc\(aq),
        448
        )
.ft P
.fi
.sp
Where there are more line breaks, this is also apparent when constructing a
function with many arguments, something very common in state functions for
instance:
.sp
.nf
.ft C
def managed(name,
        source=None,
        source_hash=\(aq\(aq,
        user=None,
        group=None,
        mode=None,
        template=None,
        makedirs=False,
        context=None,
        replace=True,
        defaults=None,
        env=None,
        backup=\(aq\(aq,
        **kwargs):
.ft P
.fi
.SS Indenting
.sp
Some confusion exists in the python world about indenting things like function
calls, the above examples use 8 spaces when indenting comma\-delimited
constructs.
.sp
The confusion arises because the pep8 program INCORRECTLY flags this as wrong,
where PEP 8, the document, cites only using 4 spaces here as wrong, as it
doesn\(aqt differentiate from a new indent level.
.sp
Right:
.sp
.nf
.ft C
def managed(name,
        source=None,
        source_hash=\(aq\(aq,
        user=None)
.ft P
.fi
.sp
WRONG:
.sp
.nf
.ft C
def managed(name,
    source=None,
    source_hash=\(aq\(aq,
    user=None)
.ft P
.fi
.sp
Lining up the indent is also correct:
.sp
.nf
.ft C
def managed(name,
            source=None,
            source_hash=\(aq\(aq,
            user=None)
.ft P
.fi
.sp
This also applies to function calls and other hanging indents.
.sp
pep8 and Flake8 (and, by extension, the vim plugin Syntastic) will complain
about the double indent for hanging indents.  This is a \fI\%known conflict\fP between
pep8 (the script) and the actual PEP 8 standard.  It is recommended that this
particular warning be ignored with the following lines in
\fB~/.config/flake8\fP:
.sp
.nf
.ft C
[flake8]
ignore = E226,E241,E242,E126
.ft P
.fi
.sp
Make sure your Flake8/pep8 are up to date.  The first three errors are ignored
by default and are present here to keep the behavior the same.  This will also
work for pep8 without the Flake8 wrapper \-\- just replace all instances of
\(aqflake8\(aq with \(aqpep8\(aq, including the filename.
.SS Code Churn
.sp
Many pull requests have been submitted that only churn code in the name of
PEP 8. Code churn is a leading source of bugs and is strongly discouraged.
While style fixes are encouraged they should be isolated to a single file per
commit, and the changes should be legitimate, if there are any questions about
whether a style change is legitimate please reference this document and the
official PEP 8 (\fI\%http://www.python.org/dev/peps/pep-0008/\fP) document before
changing code. Many claims that a change is PEP 8 have been invalid, please
double check before committing fixes.
.SH SALT RELEASE PROCESS
.sp
The goal for Salt projects is to cut a new feature release every four to six
weeks.  This document outlines the process for these releases, and the
subsequent bug fix releases which follow.
.SS Feature Release Process
.sp
When a new release is ready to be cut, the person responsible for cutting the
release will follow the following steps (written using the 0.16 release as an
example):
.INDENT 0.0
.IP 1. 3
All open issues on the release milestone should be moved to the next release
milestone. (e.g. from the \fB0.16\fP milestone to the \fB0.17\fP milestone)
.IP 2. 3
Release notes should be created documenting the major new features and
bugfixes in the release.
.IP 3. 3
Create an annotated tag with only the major and minor version numbers,
preceded by the letter \fBv\fP.  (e.g. \fBv0.16\fP)  This tag will reside on the
\fBdevelop\fP branch.
.IP 4. 3
Create a branch for the new release, using only the major and minor version
numbers.  (e.g. \fB0.16\fP)
.IP 5. 3
On this new branch, create an annotated tag for the first revision release,
which is generally a release candidate.  It should be preceded by the letter
\fBv\fP.  (e.g. \fBv0.16.0RC\fP)
.IP 6. 3
The release should be packaged from this annotated tag and uploaded to PyPI.
.IP 7. 3
The packagers should be notified on the \fBsalt\-packagers\fP mailing list so
they can create packages for all the major operating systems.  (note that
release candidates should go in the testing repositories)
.IP 8. 3
After the packagers have been given a few days to compile the packages, the
release is announced on the \fBsalt\-users\fP mailing list.
.UNINDENT
.SS Maintenance and Bugfix Releases
.sp
Once a release has been cut, regular cherry\-picking sessions should begin to
cherry\-pick any bugfixes from the \fBdevelop\fP branch to the release branch
(e.g. \fB0.16\fP).  Once major bugs have been fixes and cherry\-picked, a bugfix
release can be cut:
.INDENT 0.0
.IP 1. 3
On the release branch (i.e. \fB0.16\fP), create an annotated tag for the
revision release.  It should be preceded by the letter \fBv\fP.  (e.g.
\fBv0.16.1\fP)  Release candidates are unnecessary for bugfix releases.
.IP 2. 3
The release should be packaged from this annotated tag and uploaded to PyPI.
.IP 3. 3
The packagers should be notified on the \fBsalt\-packagers\fP mailing list so
they can create packages for all the major operating systems.
.IP 4. 3
After the packagers have been given a few days to compile the packages, the
release is announced on the \fBsalt\-users\fP mailing list.
.UNINDENT
.SH SALT CODING STYLE
.sp
Salt is developed with a certain coding style, while the style is dominantly
PEP 8 it is not completely PEP 8. It is also noteworthy that a few
development techniques are also employed which should be adhered to. In the
end, the code is made to be "Salty".
.sp
Most importantly though, we will accept code that violates the coding style and
KINDLY ask the contributor to fix it, or go ahead and fix the code on behalf of
the contributor. Coding style is NEVER grounds to reject code contributions,
and is never grounds to talk down to another member of the community (There are
no grounds to treat others without respect, especially people working to
improve Salt)!!
.SS Strings
.sp
Salt follows a few rules when formatting strings:
.SS Single Quotes
.sp
In Salt, all strings use single quotes unless there is a good reason not to.
This means that docstrings use single quotes, standard strings use single
quotes etc.:
.sp
.nf
.ft C
def foo():
    \(aq\(aq\(aq
    A function that does things
    \(aq\(aq\(aq
    name = \(aqA name\(aq
    return name
.ft P
.fi
.SS Formatting Strings
.sp
All strings which require formatting should use the \fI.format\fP string method:
.sp
.nf
.ft C
data = \(aqsome text\(aq
more = \(aq{0} and then some\(aq.format(data)
.ft P
.fi
.sp
Make sure to use indices or identifiers in the format brackets, since empty
brackets are not supported by python 2.6.
.sp
Please do NOT use printf formatting.
.SS Docstring Conventions
.sp
Docstrings should always add a newline, docutils takes care of the new line and
it makes the code cleaner and more vertical:
.sp
\fIGOOD\fP:
.sp
.nf
.ft C
def bar():
    \(aq\(aq\(aq
    Here lies a docstring with a newline after the quotes and is the salty
    way to handle it! Vertical code is the way to go!
    \(aq\(aq\(aq
    return
.ft P
.fi
.sp
\fIBAD\fP:
.sp
.nf
.ft C
def baz():
    \(aq\(aq\(aqThis is not ok!\(aq\(aq\(aq
    return
.ft P
.fi
.SS Imports
.sp
Salt code prefers importing modules and not explicit functions. This is both a
style and functional preference. The functional preference originates around
the fact that the module import system used by pluggable modules will include
callable objects (functions) that exist in the direct module namespace. This
is not only messy, but may unintentionally expose code python libs to the Salt
interface and pose a security problem.
.sp
To say this more directly with an example, this is \fIGOOD\fP:
.sp
.nf
.ft C
import os

def minion_path():
    path = os.path.join(self.opts[\(aqcachedir\(aq], \(aqminions\(aq)
    return path
.ft P
.fi
.sp
This on the other hand is \fIDISCOURAGED\fP:
.sp
.nf
.ft C
from os.path import join

def minion_path():
path = join(self.opts[\(aqcachedir\(aq], \(aqminions\(aq)
return path
.ft P
.fi
.sp
The time when this is changed is for importing exceptions, generally directly
importing exceptions is preferred:
.sp
This is a good way to import exceptions:
.sp
.nf
.ft C
from salt.exceptions import CommandExecutionError
.ft P
.fi
.SS Vertical is Better
.sp
When writing Salt code, vertical code is generally preferred. This is not a hard
rule but more of a guideline. As PEP 8 specifies, Salt code should not exceed 79
characters on a line, but it is preferred to separate code out into more
newlines in some cases for better readability:
.sp
.nf
.ft C
import os

os.chmod(
        os.path.join(self.opts[\(aqsock_dir\(aq],
            \(aqminion_event_pub.ipc\(aq),
        448
        )
.ft P
.fi
.sp
Where there are more line breaks, this is also apparent when constructing a
function with many arguments, something very common in state functions for
instance:
.sp
.nf
.ft C
def managed(name,
        source=None,
        source_hash=\(aq\(aq,
        user=None,
        group=None,
        mode=None,
        template=None,
        makedirs=False,
        context=None,
        replace=True,
        defaults=None,
        env=None,
        backup=\(aq\(aq,
        **kwargs):
.ft P
.fi
.SS Indenting
.sp
Some confusion exists in the python world about indenting things like function
calls, the above examples use 8 spaces when indenting comma\-delimited
constructs.
.sp
The confusion arises because the pep8 program INCORRECTLY flags this as wrong,
where PEP 8, the document, cites only using 4 spaces here as wrong, as it
doesn\(aqt differentiate from a new indent level.
.sp
Right:
.sp
.nf
.ft C
def managed(name,
        source=None,
        source_hash=\(aq\(aq,
        user=None)
.ft P
.fi
.sp
WRONG:
.sp
.nf
.ft C
def managed(name,
    source=None,
    source_hash=\(aq\(aq,
    user=None)
.ft P
.fi
.sp
Lining up the indent is also correct:
.sp
.nf
.ft C
def managed(name,
            source=None,
            source_hash=\(aq\(aq,
            user=None)
.ft P
.fi
.sp
This also applies to function calls and other hanging indents.
.sp
pep8 and Flake8 (and, by extension, the vim plugin Syntastic) will complain
about the double indent for hanging indents.  This is a \fI\%known conflict\fP between
pep8 (the script) and the actual PEP 8 standard.  It is recommended that this
particular warning be ignored with the following lines in
\fB~/.config/flake8\fP:
.sp
.nf
.ft C
[flake8]
ignore = E226,E241,E242,E126
.ft P
.fi
.sp
Make sure your Flake8/pep8 are up to date.  The first three errors are ignored
by default and are present here to keep the behavior the same.  This will also
work for pep8 without the Flake8 wrapper \-\- just replace all instances of
\(aqflake8\(aq with \(aqpep8\(aq, including the filename.
.SS Code Churn
.sp
Many pull requests have been submitted that only churn code in the name of
PEP 8. Code churn is a leading source of bugs and is strongly discouraged.
While style fixes are encouraged they should be isolated to a single file per
commit, and the changes should be legitimate, if there are any questions about
whether a style change is legitimate please reference this document and the
official PEP 8 (\fI\%http://www.python.org/dev/peps/pep-0008/\fP) document before
changing code. Many claims that a change is PEP 8 have been invalid, please
double check before committing fixes.
.SH SALT STACK GIT POLICY
.sp
The Salt Stack team follows a git policy to maintain stability and consistency
with the repository. The git policy has been developed to encourage
contributions and make contributing to Salt as easy as possible. Code
contributors to Salt Stack projects DO NOT NEED TO READ THIS DOCUMENT, because
all contributions come into Salt Stack via a single gateway to make it as
easy as possible for contributors to give us code.
.sp
The primary rule of git management in Salt Stack is to make life easy on
contributors and developers to send in code. Simplicity is always a goal!
.SS New Code Entry
.sp
All new Salt Stack code is posted to the \fIdevelop\fP branch, this is the single
point of entry. The only exception here is when a bugfix to develop cannot be
cleanly merged into a release branch and the bugfix needs to be rewritten for
the release branch.
.SS Release Branching
.sp
Salt Stack maintains two types of releases, \fIFeature Releases\fP and
\fIPoint Releases\fP. A feature release is managed by incrementing the first or
second release point number, so 0.10.5 \-> 0.11.0 signifies a feature release
and 0.11.0 \-> 0.11.1 signifies a point release, also a hypothetical
0.42.7 \-> 1.0.0 would also signify a feature release.
.SS Feature Release Branching
.sp
Each feature release is maintained in a dedicated git branch derived from the
last applicable release commit on develop. All file changes relevant to the
feature release will be completed in the develop branch prior to the creation
of the feature release branch. The feature release branch will be named after
the relevant numbers to the feature release, which constitute the first two
numbers. This means that the release branch for the 0.11.0 series is named
0.11.
.sp
A feature release branch is created with the following command:
.sp
.nf
.ft C
# git checkout \-b 0.11 # From the develop branch
# git push origin 0.11
.ft P
.fi
.SS Point Releases
.sp
Each point release is derived from its parent release branch. Constructing point
releases is a critical aspect of Salt development and is managed by members of
the core development team. Point releases comprise bug and security fixes which
are cherry picked from develop onto the aforementioned release branch. At the
time when a core developer accepts a pull request a determination needs to be
made if the commits in the pull request need to be backported to the release
branch. Some simple criteria are used to make this determination:
.INDENT 0.0
.IP \(bu 2
Is this commit fixing a bug?
Backport
.IP \(bu 2
Does this commit change or add new features in any way?
Don\(aqt backport
.IP \(bu 2
Is this a PEP8 or code cleanup commit?
Don\(aqt backport
.IP \(bu 2
Does this commit fix a security issue?
Backport
.UNINDENT
.sp
Determining when a point release is going to be made is up to the project
leader (Thomas Hatch). Generally point releases are made every 1\-2 weeks or
if there is a security fix they can be made sooner.
.sp
The point release is only designated by tagging the commit on the release
branch with release number using the existing convention (version 0.11.1 is
tagged with v0.11.1). From the tag point a new source tarball is generated
and published to PyPI, and a release announcement is made.
.SH SALT DEVELOPMENT GUIDELINES
.SS Dunder Dictionaries
.sp
Salt provides several special "dunder" dictionaries as a convenience for Salt
development.  These include \fB__opts__\fP, \fB__context__\fP, \fB__salt__\fP, and
others. This document will describe each dictionary and detail where they exist
and what information and/or functionality they provide.
.SS __context__
.sp
\fB__context__\fP exists in state modules and execution modules.
.sp
During a state run the \fB__context__\fP dictionary persists across all states
that are run and then is destroyed when the state ends.
.sp
When running an execution module \fB__context__\fP persists across all module
executions until the modules are refreshed; such as when \fBsaltutils.sync_all\fP
or \fBstate.highstate\fP are executed.
.sp
A great place to see how to use \fB__context__\fP is in the cp.py module in
salt/modules/cp.py. The fileclient authenticates with the master when it is
instantiated and then is used to copy files to the minion. Rather than create a
new fileclient for each file that is to be copied down, one instance of the
fileclient is instantiated in the \fB__context__\fP dictionary and is reused for
each file. Here is an example from salt/modules/cp.py:
.sp
.nf
.ft C
if not \(aqcp.fileclient\(aq in __context__:
    __context__[\(aqcp.fileclient\(aq] = salt.fileclient.get_file_client(__opts__)
.ft P
.fi
.IP Note
Because __context__ may or may not have been destroyed, always be
sure to check for the existence of the key in __context__ and
generate the key before using it.
.RE
.SS External Pillars
.sp
Salt provides a mechanism for generating pillar data by calling external
pillar interfaces. This document will describe an outline of an ext_pillar
module.
.SS Location
.sp
Salt expects to find your \fBext_pillar\fP module in the same location where it
looks for other python modules. If the \fBextension_modules\fP option in your
Salt master configuration is set, Salt will look for a \fBpillar\fP directory
under there and load all the modules it finds. Otherwise, it will look in
your Python site\-packages \fBsalt/pillar\fP directory.
.SS Configuration
.sp
The external pillars that are called when a minion refreshes its pillars is
controlled by the \fBext_pillar\fP option in the Salt master configuration. You
can pass a single argument, a list of arguments or a dictionary of arguments
to your pillar:
.sp
.nf
.ft C
ext_pillar:
  \- example_a: some argument
  \- example_b:
    \- argumentA
    \- argumentB
  \- example_c:
      keyA: valueA
      keyB: valueB
.ft P
.fi
.SS The Module
.SS Imports and Logging
.sp
Import modules your external pillar module needs. You should first include
generic modules that come with stock Python:
.sp
.nf
.ft C
import logging
.ft P
.fi
.sp
And then start logging. This is an idiomatic way of setting up logging in Salt:
.sp
.nf
.ft C
log = logging.getLogger(__name__)
.ft P
.fi
.sp
Finally, load modules that are specific to what you are doing. You should catch
import errors and set a flag that the the \fB__virtual__\fP function can use later.
.sp
.nf
.ft C
try:
    import weird_thing
    example_a_loaded = True
except ImportError:
    example_a_loaded = False
.ft P
.fi
.SS Options
.sp
If you define an \fB__opts__\fP dictionary, it will be merged into the
\fB__opts__\fP dictionary handed to the \fBext_pillar\fP function later. This is a
good place to put default configuration items. The convention is to name
things \fBmodulename.option\fP.
.sp
.nf
.ft C
__opts__ = { \(aqexample_a.someconfig\(aq: 137 }
.ft P
.fi
.SS Initialization
.sp
If you define an \fB__init__\fP function, it will be called with the following
signature:
.sp
.nf
.ft C
def __init__( __opts__ ):
    # Do init work here
.ft P
.fi
.sp
\fBNote\fP: The \fB__init__\fP function is ran every time a particular minion causes
the external pillar to be called, so don\(aqt put heavy initialization code here.
The \fB__init__\fP functionality is a side\-effect of the Salt loader, so it may
not be as useful in pillars as it is in other Salt items.
.SS __virtual__
.sp
If you define a \fB__virtual__\fP function, you can control whether or not this
module is visible. If it returns \fBFalse\fP then Salt ignores this module. If
it returns a string, then that string will be how Salt identifies this external
pillar in its \fBext_pillar\fP configuration. If this function does not exist,
then the name Salt\(aqs \fBext_pillar\fP will use to identify this module is its
conventional name in Python.
.sp
This is useful to write modules that can be installed on all Salt masters, but
will only be visible if a particular piece of software your module requires is
installed.
.sp
.nf
.ft C
# This external pillar will be known as \(gaexample_a\(ga
def __virtual__():
    if example_a_loaded:
        return \(aqexample_a\(aq
    else:
        return False
.ft P
.fi
.sp
.nf
.ft C
# This external pillar will be known as \(gasomething_else\(ga
def __virtual__():
    if example_a_loaded:
        return \(aqsomething_else\(aq
    else:
        return False
.ft P
.fi
.SS ext_pillar
.sp
This is where the real work of an external pillar is done. If this module is
active and has a function called \fBext_pillar\fP, whenever a minion updates its
pillar this function is called.
.sp
How it is called depends on how it is configured in the Salt master
configuration. The first argument is always the current pillar dictionary, this
contains pillar items that have already been added, starting with the data from
\fBpillar_roots\fP, and then from any already\-ran external pillars.
.sp
Using our example above:
.sp
.nf
.ft C
ext_pillar( pillar, \(aqsome argument\(aq )                   # example_a
ext_pillar( pillar, \(aqargumentA\(aq, \(aqargumentB\(aq )          # example_b
ext_pillar( pillar, keyA=\(aqvalueA\(aq, keyB=\(aqvalueB\(aq } )    # example_c
.ft P
.fi
.sp
In the \fBexample_a\fP case, \fBpillar\fP will contain the items from the
\fBpillar_roots\fP, in \fBexample_b\fP \fBpillar\fP  will contain that plus the items
added by \fBexample_a\fP, and in \fBexample_c\fP \fBpillar\fP will contain that plus
the items added by \fBexample_b\fP.
.sp
This function should return a dictionary, the contents of which are merged in
with all of the other pillars and returned to the minion. \fBNote\fP: this function
is called once for each minion that fetches its pillar data.
.sp
.nf
.ft C
def ext_pillar( pillar, *args, **kwargs ):

    my_pillar = {}

    # Do stuff

    return my_pillar
.ft P
.fi
.sp
You shouldn\(aqt just add items to \fBpillar\fP and return that, since that will
cause Salt to merge data that already exists. Rather, just return the items
you are adding or changing. You could, however, use \fBpillar\fP in your module
to make some decision based on pillar data that already exists.
.sp
This function has access to some useful globals:
.INDENT 0.0
.TP
.B __opts__
A dictionary of mostly Salt configuration options. If you had an
\fB__opts__\fP dictionary defined in your module, those values will be
included. Also included and most useful is \fB__opts__[\(aqid\(aq]\fP, which
is the minion id of the minion asking for pillar data.
.TP
.B __salt__
A dictionary of Salt module functions, useful so you don\(aqt have to
duplicate functions that already exist. E.g.
\fB__salt__[\(aqcmd.run\(aq]( \(aqls \-l\(aq )\fP \fBNote\fP, runs on the \fImaster\fP
.TP
.B __grains__
A dictionary of the grains of the minion making this pillar call.
.UNINDENT
.SS Example configuration
.sp
As an example, if you wanted to add external pillar via the \fBcmd_json\fP
external pillar, add something like this to your master config:
.sp
.nf
.ft C
ext_pillar:
  \- cmd_json: "echo {\(aqarg\(aq:\(aqvalue\(aq}"
.ft P
.fi
.SS Modular Systems
.sp
When first working with Salt, it is not always clear where all of the modular
components are and what they do. Salt comes loaded with more modular systems
than many users are aware of, making Salt very easy to extend in many places.
.sp
The most commonly used modular systems are execution modules and states. But
the modular systems extend well beyond the more easily exposed components
and are often added to Salt to make the complete system more flexible.
.SS Execution Modules
.sp
Execution modules make up the core of the functionality used by Salt to
interact with client systems. The execution modules create the core system
management library used by all Salt systems, including states, which
interact with minion systems.
.sp
Execution modules are completely open ended in their execution. They can
be used to do anything required on a minion, from installing packages to
detecting information about the system. The only restraint in execution
modules is that the defined functions always return a JSON serializable
object.
.sp
For a list of all built in execution modules:
.sp
\fBFull List of built in execution modules\fP
.sp
For information on writing execution modules, see this document:
.sp
\fBExecution module development\fP
.SS State Modules
.sp
State modules are used to define the state interfaces used by Salt States.
These modules are restrictive in that they must follow a number of rules to
function properly.
.IP Note
State modules define the available routines in sls files. If calling
an execution module directly is desired, take a look at the \fImodule\fP
state.
.RE
.SS Auth
.sp
The auth module system allows for external authentication routines to be easily
added into Salt. The \fIauth\fP function needs to be implemented to satisfy the
requirements of an auth module. Use the \fBpam\fP module as an example.
.SS Fileserver
.sp
The fileserver module system is used to create fileserver backends used by the
Salt Master. These modules need to implement the functions used in the
fileserver subsystem. Use the \fBgitfs\fP module as an example.
.SS Grains
.sp
Grain modules define extra routines to populate grains data. All defined
public functions will be executed and MUST return a Python dict object. The
dict keys will be added to the grains made available to the minion.
.SS Output
.sp
The output modules supply the outputter system with routines to display data
in the terminal. These modules are very simple and only require the \fIoutput\fP
function to execute. The default system outputter is the \fBnested\fP module.
.SS Pillar
.sp
Used to define optional external pillar systems. The pillar generated via
the filesystem pillar is passed into external pillars. This is commonly used
as a bridge to database data for pillar, but is also the backend to the libvirt
state used to generate and sign libvirt certificates on the fly.
.SS Renderers
.sp
Renderers are the system used to render sls files into salt highdata for the
state compiler. They can be as simple as the \fBpy\fP renderer and as complex as
\fBstateconf\fP and \fBpydsl\fP.
.SS Returners
.sp
Returners are used to send data from minions to external sources, commonly
databases. A full returner will implement all routines to be supported as an
external job cache. Use the \fBredis\fP returner as an example.
.SS Runners
.sp
Runners are purely master\-side execution sequences. These range from simple
reporting to orchestration engines like the overstate.
.SS Tops
.sp
Tops modules are used to convert external data sources into top file data for
the state system.
.SS Wheel
.sp
The wheel system is used to manage master side management routines. These
routines are primarily intended for the API to enable master configuration.
.SS Package Providers
.sp
This page contains guidelines for writing package providers.
.SS Package Functions
.sp
One of the most important features of Salt is package management. There is no
shortage of package managers, so in the interest of providing a consistent
experience in \fBpkg\fP states, there are certain functions
that should be present in a package provider. Note that these are subject to
change as new features are added or existing features are enhanced.
.SS list_pkgs
.sp
This function should declare an empty dict, and then add packages to it by
calling \fBpkg_resource.add_pkg\fP, like
so:
.sp
.nf
.ft C
__salt__[\(aqpkg_resource.add_pkg\(aq](ret, name, version)
.ft P
.fi
.sp
The last thing that should be done before returning is to execute
\fBpkg_resource.sort_pkglist\fP. This
function does not presently do anything to the return dict, but will be used in
future versions of Salt.
.sp
.nf
.ft C
__salt__[\(aqpkg_resource.sort_pkglist\(aq](ret)
.ft P
.fi
.sp
\fBlist_pkgs\fP returns a dictionary of installed packages, with the keys being
the package names and the values being the version installed. Example return
data:
.sp
.nf
.ft C
{\(aqfoo\(aq: \(aq1.2.3\-4\(aq,
 \(aqbar\(aq: \(aq5.6.7\-8\(aq}
.ft P
.fi
.SS latest_version
.sp
Accepts an arbitrary number of arguments. Each argument is a package name. The
return value for a package will be an empty string if the package is not found
or if the package is up\-to\-date. The only case in which a non\-empty string is
returned is if the package is available for new installation (i.e. not already
installed) or if there is an upgrade available.
.sp
If only one argument was passed, this function return a string, otherwise a
dict of name/version pairs is returned.
.sp
This function must also accept \fB**kwargs\fP, in order to receive the
\fBfromrepo\fP and \fBrepo\fP keyword arguments from pkg states. Where supported,
these arguments should be used to find the install/upgrade candidate in the
specified repository. The \fBfromrepo\fP kwarg takes precedence over \fBrepo\fP, so
if both of those kwargs are present, the repository specified in \fBfromrepo\fP
should be used. However, if \fBrepo\fP is used instead of \fBfromrepo\fP, it should
still work, to preserve backwards compatibility with older versions of Salt.
.SS version
.sp
Like \fBlatest_version\fP, accepts an arbitrary number of arguments and
returns a string if a single package name was passed, or a dict of name/value
pairs if more than one was passed. The only difference is that the return
values are the currently\-installed versions of whatever packages are passed. If
the package is not installed, an empty string is returned for that package.
.SS upgrade_available
.sp
Deprecated and destined to be removed. For now, should just do the following:
.sp
.nf
.ft C
return __salt__[\(aqpkg.latest_version\(aq](name) != \(aq\(aq
.ft P
.fi
.SS install
.sp
The following arguments are required and should default to \fBNone\fP:
.INDENT 0.0
.IP 1. 3
name (for single\-package pkg states)
.IP 2. 3
pkgs (for multiple\-package pkg states)
.IP 3. 3
sources (for binary package file installation)
.UNINDENT
.sp
The first thing that this function should do is call
\fBpkg_resource.parse_targets\fP
(see below). This function will convert the SLS input into a more easily parsed
data structure.
\fBpkg_resource.parse_targets\fP may
need to be modified to support your new package provider, as it does things
like parsing package metadata which cannot be done for every package management
system.
.sp
.nf
.ft C
pkg_params, pkg_type = __salt__[\(aqpkg_resource.parse_targets\(aq](name,
                                                              pkgs,
                                                              sources)
.ft P
.fi
.sp
Two values will be returned to the \fBinstall\fP function. The first of
them will be a dictionary. The keys of this dictionary will be package names,
though the values will differ depending on what kind of installation is being
done:
.INDENT 0.0
.IP \(bu 2
If \fBname\fP was provided (and \fBpkgs\fP was not), then there will
be a single key in the dictionary, and its value will be \fBNone\fP. Once the
data has been returned, if the \fBversion\fP keyword argument was
provided, then it should replace the \fBNone\fP value in the dictionary.
.IP \(bu 2
If \fBpkgs\fP was provided, then \fBname\fP is ignored, and the
dictionary will contain one entry for each package in the \fBpkgs\fP
list. The values in the dictionary will be \fBNone\fP if a version was not
specified for the package, and the desired version if specified. See the
\fBMultiple Package Installation Options\fP section of the
\fBpkg.installed\fP state for more info.
.IP \(bu 2
If \fBsources\fP was provided, then \fBname\fP is ignored, and the
dictionary values will be the path/URI for the package.
.UNINDENT
.sp
The second return value will be a string with two possible values:
\fBrepository\fP or \fBfile\fP. The \fBinstall\fP function can use this value
(if necessary) to build the proper command to install the targeted package(s).
.sp
Both before and after the installing the target(s), you should run
\fBlist_pkgs\fP to obtain a list of the installed packages. You should then
return the output of
\fBpkg_resource.find_changes\fP:
.sp
.nf
.ft C
return __salt__[\(aqpkg_resource.find_changes\(aq](old, new)
.ft P
.fi
.SS remove
.sp
Removes the passed package and return a list of the packages removed.
.SS Package Repo Functions
.sp
There are some functions provided by \fBpkg\fP which are specific to package
repositories, and not to packages themselves. When writing modules for new
package managers, these functions should be made available as stated below, in
order to provide compatibility with the \fBpkgrepo\fP state.
.sp
All repo functions should accept a basedir option, which defines which
directory repository configuration should be found in. The default for this
is dictated by the repo manager that is being used, and rarely needs to be
changed.
.sp
.nf
.ft C
basedir = \(aq/etc/yum.repos.d\(aq
__salt__[\(aqpkg.list_repos\(aq](basedir)
.ft P
.fi
.SS list_repos
.sp
Lists the repositories that are currently configured on this system.
.sp
.nf
.ft C
__salt__[\(aqpkg.list_repos\(aq]()
.ft P
.fi
.sp
Returns a dictionary, in the following format:
.sp
.nf
.ft C
{\(aqreponame\(aq: \(aqconfig_key_1\(aq: \(aqconfig value 1\(aq,
             \(aqconfig_key_2\(aq: \(aqconfig value 2\(aq,
             \(aqconfig_key_3\(aq: [\(aqlist item 1 (when appropriate)\(aq,
                              \(aqlist item 2 (when appropriate)]}
.ft P
.fi
.SS get_repo
.sp
Displays all local configuration for a specific repository.
.sp
.nf
.ft C
__salt__[\(aqpkg.get_repo\(aq](repo=\(aqmyrepo\(aq)
.ft P
.fi
.sp
The information is formatted in much the same way as list_repos, but is
specific to only one repo.
.sp
.nf
.ft C
{\(aqconfig_key_1\(aq: \(aqconfig value 1\(aq,
 \(aqconfig_key_2\(aq: \(aqconfig value 2\(aq,
 \(aqconfig_key_3\(aq: [\(aqlist item 1 (when appropriate)\(aq,
                  \(aqlist item 2 (when appropriate)]}
.ft P
.fi
.SS del_repo
.sp
Removes the local configuration for a specific repository. Requires a \fIrepo\fP
argument, which must match the locally configured name. This function returns
a string, which informs the user as to whether or not the operation was a
success.
.sp
.nf
.ft C
__salt__[\(aqpkg.del_repo\(aq](repo=\(aqmyrepo\(aq)
.ft P
.fi
.SS mod_repo
.sp
Modify the local configuration for one or more option for a configured repo.
This is also the way to create new repository configuration on the local
system; if a repo is specified which does not yet exist, it will be created.
.sp
The options specified for this function are specific to the system; please
refer to the documentation for your specific repo manager for specifics.
.sp
.nf
.ft C
__salt__[\(aqpkg.mod_repo\(aq](repo=\(aqmyrepo\(aq, url=\(aqhttp://myurl.com/repo\(aq)
.ft P
.fi
.SS Low\-Package Functions
.sp
In general, the standard package functions as describes above will meet your
needs. These functions use the system\(aqs native repo manager (for instance,
yum or the apt tools). In most cases, the repo manager is actually separate
from the package manager. For instance, yum is usually a front\-end for rpm, and
apt is usually a front\-end for dpkg. When possible, the package functions that
use those package managers directly should do so through the low package
functions.
.sp
It is normal and sane for \fBpkg\fP to make calls to \fBlowpkgs\fP, but \fBlowpkg\fP
must never make calls to \fBpkg\fP. This is affects functions which are required
by both \fBpkg\fP and \fBlowpkg\fP, but the technique in \fBpkg\fP is more performant
than what is available to \fBlowpkg\fP. When this is the case, the \fBlowpkg\fP
function that requires that technique must still use the \fBlowpkg\fP version.
.SS list_pkgs
.sp
Returns a dict of packages installed, including the package name and version.
Can accept a list of packages; if none are specified, then all installed
packages will be listed.
.sp
.nf
.ft C
installed = __salt__[\(aqlowpkg.list_pkgs\(aq](\(aqfoo\(aq, \(aqbar\(aq)
.ft P
.fi
.sp
Example output:
.sp
.nf
.ft C
{\(aqfoo\(aq: \(aq1.2.3\-4\(aq,
 \(aqbar\(aq: \(aq5.6.7\-8\(aq}
.ft P
.fi
.SS verify
.sp
Many (but not all) package management systems provide a way to verify that the
files installed by the package manager have or have not changed. This function
accepts a list of packages; if none are specified, all packages will be
included.
.sp
.nf
.ft C
installed = __salt__[\(aqlowpkg.verify\(aq](\(aqhttpd\(aq)
.ft P
.fi
.sp
Example output:
.sp
.nf
.ft C
{\(aq/etc/httpd/conf/httpd.conf\(aq: {\(aqmismatch\(aq: [\(aqsize\(aq, \(aqmd5sum\(aq, \(aqmtime\(aq],
                                \(aqtype\(aq: \(aqconfig\(aq}}
.ft P
.fi
.SS file_list
.sp
Lists all of the files installed by all packages specified. If not packages are
specified, then all files for all known packages are returned.
.sp
.nf
.ft C
installed = __salt__[\(aqlowpkg.file_list\(aq](\(aqhttpd\(aq, \(aqapache\(aq)
.ft P
.fi
.sp
This function does not return which files belong to which packages; all files
are returned as one giant list (hence the \fIfile_list\fP function name. However,
This information is still returned inside of a dict, so that it can provide
any errors to the user in a sane manner.
.sp
.nf
.ft C
{\(aqerrors\(aq: [\(aqpackage apache is not installed\(aq],
  \(aqfiles\(aq: [\(aq/etc/httpd\(aq,
            \(aq/etc/httpd/conf\(aq,
            \(aq/etc/httpd/conf.d\(aq,
            \(aq...SNIP...\(aq]}
.ft P
.fi
.SS file_dict
.sp
Lists all of the files installed by all packages specified. If not packages are
specified, then all files for all known packages are returned.
.sp
.nf
.ft C
installed = __salt__[\(aqlowpkg.file_dict\(aq](\(aqhttpd\(aq, \(aqapache\(aq, \(aqkernel\(aq)
.ft P
.fi
.sp
Unlike \fIfile_list\fP, this function will break down which files belong to which
packages. It will also return errors in the same manner as \fIfile_list\fP.
.sp
.nf
.ft C
{\(aqerrors\(aq: [\(aqpackage apache is not installed\(aq],
 \(aqpackages\(aq: {\(aqhttpd\(aq: [\(aq/etc/httpd\(aq,
                        \(aq/etc/httpd/conf\(aq,
                        \(aq...SNIP...\(aq],
              \(aqkernel\(aq: [\(aq/boot/.vmlinuz\-2.6.32\-279.el6.x86_64.hmac\(aq,
                         \(aq/boot/System.map\-2.6.32\-279.el6.x86_64\(aq,
                         \(aq...SNIP...\(aq]}}
.ft P
.fi
.SH INTRODUCTION TO EXTENDING SALT
.sp
Salt is made to be used, and made to be extended. The primary goal of Salt is
to provide a foundation which can be used to solve problems. And the goal of
Salt is to not assume what those problems might be.
.sp
One of the greatest benefit of developing Salt has been the vast array of ways
in which people have wanted to use it, while the original intention was as a
communication layer for a cloud controller Salt has been extended to facilitate
so much more.
.SS Client API
.sp
The primary interface used to extend Salt, is to simply use it. Salt executions
can be called via the Salt client API, making programming master side solutions
with Salt is easy.
.SS Adding Loadable Plugins
.sp
Salt is comprised of a core platform that loads many types of easy to write
plugins. The idea is to enable all of the breaking points in the Salt processes
to have a point of pluggable interaction. This means that all of the main
features of Salt can be extended, modified or used.
.sp
The breaking points and helping interfaces span from convenience master side
executions to manipulating the flow of how data is handled by Salt.
.SS Minion Execution Modules
.sp
The minion execution modules or just \fBmodules\fP are the core to what Salt is
and does. These modules are found in:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules\fP
.sp
These modules are what is called by the Salt command line and the salt client
API. Adding modules is done by simply adding additional Python modules to the
\fImodules\fP directory and restarting the minion.
.SS Grains
.sp
Salt grains, or "grains of truth" are bits of static information that are
generated when the minion starts. This information is useful when determining
what package manager to default to, or where certain configuration files are
stored on the minion.
.sp
The Salt grains are the interface used for auto detection and dynamic assignment
of execution modules and types to specific Salt minions.
.sp
The code used to generate the Salt grains can be found here:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/grains\fP
.SS States
.sp
Salt supports state enforcement, this makes Salt a high speed and very efficient
solution for system configuration management.
.sp
States can be easily added to Salt by dropping a new state module in:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/states\fP
.SS Renderers
.sp
Salt states are controlled by simple data structures, these structures can be
abstracted in a number of ways. While the default is to be in a YAML file
wrapped in a jinja template, any abstraction can be used. This means that any
format that can be dreamed is possible, so long as a renderer is written for
it.
.sp
The existing renderers can be found here:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/renderers\fP
.SS Returners
.sp
The Salt commands all produce a return value, that return value is sent to the
Salt master by default, but it can be sent anywhere. The returner interface
makes it programmatically possible for the information to be sent to anything
from an SQL or NoSQL database, to a custom application made to use Salt.
.sp
The existing returners can be found here:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/returners\fP
.SS Runners
.sp
Sometimes a certain application can be made to execute and run from the
existing Salt command line. This is where the Salt runners come into play.
The Salt Runners what is called by the Salt\-run command and are meant to
act as a generic interface for encapsulating master side executions.
.sp
Existing Salt runners are located here:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/runners\fP
.SH MODULES
.sp
Salt modules are the functions called by the \fBsalt\fP command.
.IP "See also"
.sp
\fIFull list of builtin modules\fP
.sp
Salt ships with many modules that cover a wide variety of tasks.
.RE
.SS Modules Are Easy to Write!
.sp
Salt modules are amazingly simple to write. Just write a regular Python module
or a regular \fI\%Cython\fP module and place it in the \fBsalt/modules\fP directory.
You can also place them in a directory called \fB_modules/\fP within the
\fBfile_roots\fP specified by the master config file, and they will be
synced to the minions when \fBstate.highstate\fP is run, or by executing the
\fBsaltutil.sync_modules\fP or
\fBsaltutil.sync_all\fP functions.
.sp
Since Salt modules are just Python/Cython modules, there are no restraints on
what you can put inside of a Salt module. If a Salt module has errors and
cannot be imported, the Salt minion will continue to load without issue and the
module with errors will simply be omitted.
.sp
If adding a Cython module the file must be named \fB<modulename>.pyx\fP so that
the loader knows that the module needs to be imported as a Cython module. The
compilation of the Cython module is automatic and happens when the minion
starts, so only the \fB*.pyx\fP file is required.
.SS Cross Calling Modules
.sp
All of the Salt modules are available to each other, and can be "cross called".
This means that, when creating a module, functions in modules that already exist
can be called.
.sp
The variable \fB__salt__\fP is packed into the modules after they are loaded into
the Salt minion. This variable is a \fI\%Python dictionary\fP of all of the Salt
functions, laid out in the same way that they are made available to the Salt
command.
.sp
Salt modules can be cross called by accessing the value in the \fB__salt__\fP
dict:
.sp
.nf
.ft C
def foo(bar):
    return __salt__[\(aqcmd.run\(aq](bar)
.ft P
.fi
.sp
This code will call the Salt cmd module\(aqs \fBrun\fP function and pass the argument
\fBbar\fP.
.SS Preloaded Modules Data
.sp
When interacting with modules often it is nice to be able to read information
dynamically about the minion, or load in configuration parameters for a module.
Salt allows for different types of data to be loaded into the modules by the
minion, as of this writing Salt loads information gathered from the Salt Grains
system and from the minion configuration file.
.SS Grains Data
.sp
The Salt minion detects information about the system when started. This allows
for modules to be written dynamically with respect to the underlying hardware
and operating system. This information is referred to as Salt Grains, or
"grains of salt". The Grains system was introduced to replace Facter, since
relying on a Ruby application from a Python application was both slow and
inefficient. Grains support replaces Facter in all Salt releases after 0.8
.sp
The values detected by the Salt Grains on the minion are available in a \fI\%dict\fP
named \fB__grains__\fP and can be accessed from within callable objects in
the Python modules.
.sp
To see the contents of the grains dict for a given system in your deployment
run the \fBgrains.items()\fP function:
.sp
.nf
.ft C
salt \(aqhostname\(aq grains.items
.ft P
.fi
.sp
To use the \fB__grains__\fP dict simply call it as a Python dict from within your
code, an excellent example is available in the Grains module:
\fBsalt.modules.grains\fP.
.SS Module Configuration
.sp
Since parameters for configuring a module may be desired, Salt allows for
configuration information stored in the main minion config file to be passed to
the modules.
.sp
Since the minion configuration file is a YAML document, arbitrary configuration
data can be passed in the minion config that is read by the modules. It is
\fBstrongly\fP recommended that the values passed in the configuration file match
the module. This means that a value intended for the \fBtest\fP module should be
named \fBtest.<value>\fP.
.sp
Configuration also requires that default configuration parameters need to be
loaded as well. This can be done simply by adding the \fB__opts__\fP dict to the
top level of the module.
.sp
The test module contains usage of the module configuration, and the default
configuration file for the minion contains the information and format used to
pass data to the modules. \fBsalt.modules.test\fP, \fBconf/minion\fP.
.SS Printout Configuration
.sp
Since module functions can return different data, and the way the data is
printed can greatly change the presentation, Salt has a printout
configuration.
.sp
When writing a module the \fB__outputter__\fP dict can be declared in the module.
The \fB__outputter__\fP dict contains a mapping of function name to Salt
Outputter.
.sp
.nf
.ft C
__outputter__ = {
                \(aqrun\(aq: \(aqtxt\(aq
                }
.ft P
.fi
.sp
This will ensure that the text outputter is used.
.SS Virtual Modules
.sp
Sometimes a module should be presented in a generic way. A good example of this
can be found in the package manager modules. The package manager changes from
one operating system to another, but the Salt module that interfaces with the
package manager can be presented in a generic way.
.sp
The Salt modules for package managers all contain a \fB__virtual__\fP function
which is called to define what systems the module should be loaded on.
.sp
The \fB__virtual__\fP function is used to return either a \fI\%string\fP or \fI\%False\fP. If
False is returned then the module is not loaded, if a string is returned then
the module is loaded with the name of the string.
.sp
This means that the package manager modules can be presented as the \fBpkg\fP module
regardless of what the actual module is named.
.sp
The package manager modules are the best example of using the \fB__virtual__\fP
function:
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules/pacman.py\fP
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules/yumpkg.py\fP
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules/apt.py\fP
.SS Documentation
.sp
Salt modules are self documenting, the \fBsys.doc()\fP function will return the
documentation for all available modules:
.sp
.nf
.ft C
salt \(aq*\(aq sys.doc
.ft P
.fi
.sp
This function simple prints out the docstrings found in the modules, when
writing Salt modules, please follow the formatting conventions for docstrings as
they appear in the other modules.
.SS Adding Documentation to Salt Modules
.sp
Since life is much better with documentation, it is strongly suggested that
all Salt modules have documentation added. Any Salt modules submitted for
inclusion in the main distribution of Salt will be required to have
documentation.
.sp
Documenting Salt modules is easy! Just add a \fI\%Python docstring\fP to the function.
.sp
.nf
.ft C
def spam(eggs):
    \(aq\(aq\(aq
    A function to make some spam with eggs!

    CLI Example::

        salt \(aq*\(aq test.spam eggs
    \(aq\(aq\(aq
    return eggs
.ft P
.fi
.sp
Now when the sys.doc call is executed the docstring will be cleanly returned
to the calling terminal.
.SS Add Module metadata
.sp
Add information about the module using the following field lists:
.sp
.nf
.ft C
:maintainer:    Thomas Hatch <thatch@saltstack.com, Seth House <shouse@saltstack.com>
:maturity:      new
:depends:       python\-mysqldb
:platform:      all
.ft P
.fi
.sp
The maintainer field is a comma\-delimited list of developers who help maintain
this module.
.sp
The maturity field indicates the level of quality and testing for this module.
Standard labels will be determined.
.sp
The depends field is a comma\-delimited list of modules that this module depends
on.
.sp
The platform field is a comma\-delimited list of platforms that this module is
known to run on.
.SS How Functions are Read
.sp
In Salt, Python callable objects contained within a module are made available
to the Salt minion for use. The only exception to this rule is a callable
object with a name starting with an underscore \fB_\fP.
.SS Objects Loaded Into the Salt Minion
.sp
.nf
.ft C
def foo(bar):
    return bar

class baz:
    def __init__(self, quo):
        pass
.ft P
.fi
.SS Objects NOT Loaded into the Salt Minion
.sp
.nf
.ft C
def _foobar(baz): # Preceded with an _
    return baz

cheese = {} # Not a callable Python object
.ft P
.fi
.SS Useful Decorators for Modules
.sp
Sometimes when writing modules for large scale deployments you run into some small
things that end up severely complicating the code. To alleviate some of this pain
Salt has some useful decorators for use within modules!
.SS Depends Decorator
.sp
When writing custom modules there are many times where some of the module will
work on all hosts, but some functions require (for example) a service to be installed.
Instead of trying to wrap much of the code in large try/except blocks you can use
a simple decorator to do this. If the dependancies passed to the decorator don\(aqt
exist, then the salt minion will remove those functions from the module on that host.
If a "fallback_funcion" is defined, it will replace the function instead of removing it
.sp
.nf
.ft C
from salt.utils.decorators import depends
try:
    import dependancy_that_sometimes_exists
except ImportError:
    pass

@depends(\(aqdependancy_that_sometimes_exists\(aq)
def foo():
    \(aq\(aq\(aq
    Function with a dependancy on the "dependancy_that_sometimes_exists" module,
    if the "dependancy_that_sometimes_exists" is missing this function will not exist
    \(aq\(aq\(aq
    return True

def _fallback():
    \(aq\(aq\(aq
    Fallback function for the depends decorator to replace a function with
    \(aq\(aq\(aq
    return \(aq"dependancy_that_sometimes_exists" needs to be installed for this function to exist\(aq

@depends(\(aqdependancy_that_sometimes_exists\(aq, fallback_funcion=_fallback)
def foo():
    \(aq\(aq\(aq
    Function with a dependancy on the "dependancy_that_sometimes_exists" module.
    If the "dependancy_that_sometimes_exists" is missing this function will be
    replaced with "_fallback"
    \(aq\(aq\(aq
    return True
.ft P
.fi
.SS Examples of Salt Modules
.sp
The existing Salt modules should be fairly easy to read and understand, the
goal of the main distribution\(aqs Salt modules is not only to build a set of
functions for Salt, but to stand as examples for building out more Salt
modules.
.sp
The existing modules can be found here:
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules\fP
.sp
The most simple module is the test module, it contains the simplest Salt
function, \fBtest.ping\fP:
.sp
.nf
.ft C
def ping():
    \(aq\(aq\(aq
    Just used to make sure the minion is up and responding
    Return True

    CLI Example::

        salt \(aq*\(aq test.ping
    \(aq\(aq\(aq
    return True
.ft P
.fi
.SH FULL LIST OF BUILTIN EXECUTION MODULES
.IP "Virtual modules"
.SS salt.modules.pkg
.sp
\fBpkg\fP is a virtual module that is fulfilled by one of the following modules:
.INDENT 0.0
.IP \(bu 2
\fBsalt.modules.apt\fP
.IP \(bu 2
\fBsalt.modules.ebuild\fP
.IP \(bu 2
\fBsalt.modules.freebsdpkg\fP
.IP \(bu 2
\fBsalt.modules.pacman\fP
.IP \(bu 2
\fBsalt.modules.yumpkg\fP
.IP \(bu 2
\fBsalt.modules.yumpkg5\fP
.IP \(bu 2
\fBsalt.modules.zypper\fP
.IP \(bu 2
\fBsalt.modules.brew\fP
.IP \(bu 2
\fBsalt.modules.win_pkg\fP
.UNINDENT
.SS salt.modules.sys
.sp
The regular salt modules execute in a separate context from the salt minion
and manipulating the actual salt modules needs to happen in a higher level
context within the minion process. This is where the sys pseudo module is
used.
.sp
The sys pseudo module comes with a few functions that return data about the
available functions on the minion or allows for the minion modules to be
refreshed. These functions are as follows:
.INDENT 0.0
.TP
.B salt.modules.sys.doc([module[, module.function]])
Display the inline documentation for all available modules, or for the
specified module or function.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sys.reload_modules()
Instruct the minion to reload all available modules in memory. This
function can be called if the modules need to be re\-evaluated for
availability or new modules have been made available to the minion.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sys.list_modules()
List all available (loaded) modules.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sys.list_functions()
List all known functions that are in available (loaded) modules.
.UNINDENT
.RE
.TS
center;
|l|l|.
_
T{
\fBaliases\fP
T}	T{
Manage the information in the aliases file
T}
_
T{
\fBalternatives\fP
T}	T{
salt.modules.alternatives
T}
_
T{
\fBapache\fP
T}	T{
Support for Apache
T}
_
T{
\fBapt\fP
T}	T{
Support for APT (Advanced Packaging Tool)
T}
_
T{
\fBarchive\fP
T}	T{
A module to wrap archive calls
T}
_
T{
\fBat\fP
T}	T{
Wrapper module for at(1)
T}
_
T{
\fBaugeas_cfg\fP
T}	T{
Manages configuration files via augeas
T}
_
T{
\fBbluez\fP
T}	T{
Support for Bluetooth (using Bluez in Linux)
T}
_
T{
\fBbrew\fP
T}	T{
Homebrew for Mac OS X
T}
_
T{
\fBbridge\fP
T}	T{
Module for gathering and managing bridging informations
T}
_
T{
\fBcassandra\fP
T}	T{
Cassandra NoSQL Database Module
T}
_
T{
\fBcmdmod\fP
T}	T{
A module for shelling out
T}
_
T{
\fBconfig\fP
T}	T{
Return config information
T}
_
T{
\fBcp\fP
T}	T{
Minion side functions for salt\-cp
T}
_
T{
\fBcron\fP
T}	T{
Work with cron
T}
_
T{
\fBdaemontools\fP
T}	T{
daemontools service module. This module will create daemontools type
T}
_
T{
\fBdarwin_sysctl\fP
T}	T{
Module for viewing and modifying sysctl parameters
T}
_
T{
\fBdata\fP
T}	T{
Manage a local persistent data structure that can hold any arbitrary data
T}
_
T{
\fBdebconfmod\fP
T}	T{
Support for Debconf
T}
_
T{
\fBdebian_service\fP
T}	T{
Service support for Debian systems \- uses update\-rc.d and service to modify the
T}
_
T{
\fBdig\fP
T}	T{
Compendium of generic DNS utilities
T}
_
T{
\fBdisk\fP
T}	T{
Module for gathering disk information
T}
_
T{
\fBdjangomod\fP
T}	T{
Manage Django sites
T}
_
T{
\fBdnsmasq\fP
T}	T{
Module for managing dnqmasq
T}
_
T{
\fBdnsutil\fP
T}	T{
Compendium of generic DNS utilities
T}
_
T{
\fBdpkg\fP
T}	T{
Support for DEB packages
T}
_
T{
\fBebuild\fP
T}	T{
Support for Portage
T}
_
T{
\fBeix\fP
T}	T{
Support for Eix
T}
_
T{
\fBeselect\fP
T}	T{
Support for eselect: the Gentoo\(aqs configuration and management tool.
T}
_
T{
\fBevent\fP
T}	T{
Fire events on the minion, events can be fired up to the master
T}
_
T{
\fBextfs\fP
T}	T{
Module for managing ext2/3/4 file systems
T}
_
T{
\fBfile\fP
T}	T{
Manage information about files on the minion, set/read user, group, and mode
T}
_
T{
\fBfreebsdjail\fP
T}	T{
The jail module for FreeBSD
T}
_
T{
\fBfreebsdkmod\fP
T}	T{
Module to manage FreeBSD kernel modules
T}
_
T{
\fBfreebsdpkg\fP
T}	T{
Package support for FreeBSD
T}
_
T{
\fBfreebsdservice\fP
T}	T{
The service module for FreeBSD
T}
_
T{
\fBfreebsd_sysctl\fP
T}	T{
Module for viewing and modifying sysctl parameters
T}
_
T{
\fBgem\fP
T}	T{
Manage ruby gems.
T}
_
T{
\fBgentoolkitmod\fP
T}	T{
Support for Gentoolkit
T}
_
T{
\fBgentoo_service\fP
T}	T{
Top level package command wrapper, used to translate the os detected by the
T}
_
T{
\fBgit\fP
T}	T{
Support for the Git SCM
T}
_
T{
\fBglance\fP
T}	T{
Module for handling openstack glance calls.
T}
_
T{
\fBgrains\fP
T}	T{
Control aspects of the grains data
T}
_
T{
\fBgroupadd\fP
T}	T{
Manage groups on Linux and OpenBSD
T}
_
T{
\fBgrub_legacy\fP
T}	T{
Support for GRUB Legacy
T}
_
T{
\fBguestfs\fP
T}	T{
Interact with virtual machine images via libguestfs
T}
_
T{
\fBhg\fP
T}	T{
Support for the Mercurial SCM
T}
_
T{
\fBhosts\fP
T}	T{
Manage the information in the hosts file
T}
_
T{
\fBimg\fP
T}	T{
Virtual machine image management tools
T}
_
T{
\fBiptables\fP
T}	T{
Support for iptables
T}
_
T{
\fBkeyboard\fP
T}	T{
Module for managing keyboards on POSIX\-like systems.
T}
_
T{
\fBkey\fP
T}	T{
Functions to view the minion\(aqs public key information
T}
_
T{
\fBkeystone\fP
T}	T{
Module for handling openstack keystone calls.
T}
_
T{
\fBkmod\fP
T}	T{
Module to manage Linux kernel modules
T}
_
T{
\fBlaunchctl\fP
T}	T{
Module for the management of MacOS systems that use launchd/launchctl
T}
_
T{
\fBlayman\fP
T}	T{
Support for Layman
T}
_
T{
\fBldapmod\fP
T}	T{
Module to provide LDAP commands via salt.
T}
_
T{
\fBlinux_acl\fP
T}	T{
Support for Linux File Access Control Lists
T}
_
T{
\fBlinux_lvm\fP
T}	T{
Support for Linux LVM2
T}
_
T{
\fBlinux_sysctl\fP
T}	T{
Module for viewing and modifying sysctl parameters
T}
_
T{
\fBlocalemod\fP
T}	T{
Module for managing locales on POSIX\-like systems.
T}
_
T{
\fBlocate\fP
T}	T{
Module for using the locate utilities
T}
_
T{
\fBlogrotate\fP
T}	T{
Module for managing logrotate.
T}
_
T{
\fBmakeconf\fP
T}	T{
Support for modifying make.conf under Gentoo
T}
_
T{
\fBmatch\fP
T}	T{
The match module allows for match routines to be run and determine target
T}
_
T{
\fBmdadm\fP
T}	T{
Salt module to manage RAID arrays with mdadm
T}
_
T{
\fBmine\fP
T}	T{
The function cache system allows for data to be stored on the master so it
T}
_
T{
\fBmongodb\fP
T}	T{
Module to provide MongoDB functionality to Salt
T}
_
T{
\fBmonit\fP
T}	T{
Monit service module.
T}
_
T{
\fBmoosefs\fP
T}	T{
Module for gathering and managing information about MooseFS
T}
_
T{
\fBmount\fP
T}	T{
Salt module to manage unix mounts and the fstab file
T}
_
T{
\fBmunin\fP
T}	T{
Run munin plugins/checks from salt and format the output as data.
T}
_
T{
\fBmysql\fP
T}	T{
Module to provide MySQL compatibility to salt.
T}
_
T{
\fBnetbsdservice\fP
T}	T{
The service module for NetBSD
T}
_
T{
\fBnetbsd_sysctl\fP
T}	T{
Module for viewing and modifying sysctl parameters
T}
_
T{
\fBnetwork\fP
T}	T{
Module for gathering and managing network information
T}
_
T{
\fBnfs3\fP
T}	T{
Module for managing NFS version 3.
T}
_
T{
\fBnginx\fP
T}	T{
Support for nginx
T}
_
T{
\fBnova\fP
T}	T{
Module for handling openstack nova calls.
T}
_
T{
\fBnpm\fP
T}	T{
Manage and query NPM packages.
T}
_
T{
\fBnzbget\fP
T}	T{
Support for nzbget
T}
_
T{
\fBopenbsdpkg\fP
T}	T{
Package support for OpenBSD
T}
_
T{
\fBopenbsdservice\fP
T}	T{
The service module for OpenBSD
T}
_
T{
\fBosxdesktop\fP
T}	T{
Mac OS X implementations of various commands in the "desktop" interface
T}
_
T{
\fBpacman\fP
T}	T{
A module to wrap pacman calls, since Arch is the best
T}
_
T{
\fBpam\fP
T}	T{
Support for pam
T}
_
T{
\fBparted\fP
T}	T{
Module for managing partitions on POSIX\-like systems.
T}
_
T{
\fBpecl\fP
T}	T{
Manage PHP pecl extensions.
T}
_
T{
\fBpillar\fP
T}	T{
Extract the pillar data for this minion
T}
_
T{
\fBpip\fP
T}	T{
Install Python packages with pip to either the system or a virtualenv
T}
_
T{
\fBpkgin\fP
T}	T{
Package support for pkgin based systems, inspired from freebsdpkg.py
T}
_
T{
\fBpkgng\fP
T}	T{
Support for pkgng
T}
_
T{
\fBpkg_resource\fP
T}	T{
Resources needed by pkg providers
T}
_
T{
\fBpkgutil\fP
T}	T{
Pkgutil support for Solaris
T}
_
T{
\fBpostgres\fP
T}	T{
Module to provide Postgres compatibility to salt.
T}
_
T{
\fBpoudriere\fP
T}	T{
Support for poudriere
T}
_
T{
\fBps\fP
T}	T{
A salt interface to psutil, a system and process library.
T}
_
T{
\fBpublish\fP
T}	T{
Publish a command from a minion to a target
T}
_
T{
\fBpuppet\fP
T}	T{
Execute puppet routines
T}
_
T{
\fBpw_group\fP
T}	T{
Manage groups on FreeBSD
T}
_
T{
\fBpw_user\fP
T}	T{
Manage users with the useradd command
T}
_
T{
\fBqemu_img\fP
T}	T{
Qemu\-img Command Wrapper
T}
_
T{
\fBqemu_nbd\fP
T}	T{
Qemu Command Wrapper
T}
_
T{
\fBquota\fP
T}	T{
Module for managing quotas on POSIX\-like systems.
T}
_
T{
\fBrabbitmq\fP
T}	T{
Module to provide RabbitMQ compatibility to Salt.
T}
_
T{
\fBrbenv\fP
T}	T{
Manage ruby installations with rbenv.
T}
_
T{
\fBreg\fP
T}	T{
Manage the registry on Windows
T}
_
T{
\fBret\fP
T}	T{
Module to integrate with the returner system and retrieve data sent to a salt
T}
_
T{
\fBrh_ip\fP
T}	T{
The networking module for RHEL/Fedora based distros
T}
_
T{
\fBrh_service\fP
T}	T{
Service support for RHEL\-based systems. This interface uses the service and
T}
_
T{
\fBrpm\fP
T}	T{
Support for rpm
T}
_
T{
\fBrvm\fP
T}	T{
Manage ruby installations and gemsets with RVM, the Ruby Version Manager.
T}
_
T{
\fBs3\fP
T}	T{
Connection module for Amazon S3
T}
_
T{
\fBsaltutil\fP
T}	T{
The Saltutil module is used to manage the state of the salt minion itself. It
T}
_
T{
\fBselinux\fP
T}	T{
Execute calls on selinux
T}
_
T{
\fBservice\fP
T}	T{
The default service module, if not otherwise specified salt will fall back
T}
_
T{
\fBshadow\fP
T}	T{
Manage the shadow file
T}
_
T{
\fBsmartos_imgadm\fP
T}	T{
Module for running imgadm command on SmartOS
T}
_
T{
\fBsmartos_vmadm\fP
T}	T{
Module for managing VMs on SmartOS
T}
_
T{
\fBsmf\fP
T}	T{
Service support for Solaris 10 and 11, should work with other systems
T}
_
T{
\fBsolaris_group\fP
T}	T{
Manage groups on Solaris
T}
_
T{
\fBsolarispkg\fP
T}	T{
Package support for Solaris
T}
_
T{
\fBsolaris_shadow\fP
T}	T{
Manage the password database on Solaris systems
T}
_
T{
\fBsolaris_user\fP
T}	T{
Manage users with the useradd command
T}
_
T{
\fBsolr\fP
T}	T{
Apache Solr Salt Module
T}
_
T{
\fBsqlite3\fP
T}	T{
Support for SQLite3
T}
_
T{
\fBssh\fP
T}	T{
Manage client ssh components
T}
_
T{
\fBstate\fP
T}	T{
Control the state system on the minion
T}
_
T{
\fBstatus\fP
T}	T{
Module for returning various status data about a minion.
T}
_
T{
\fBsupervisord\fP
T}	T{
Provide the service module for system supervisord or supervisord in a virtualenv
T}
_
T{
\fBsvn\fP
T}	T{
Subversion SCM
T}
_
T{
\fBsysbench\fP
T}	T{
The \(aqsysbench\(aq module is used to analyse the
T}
_
T{
\fBsysmod\fP
T}	T{
The sys module provides information about the available functions on the
T}
_
T{
\fBsystemd\fP
T}	T{
Provide the service module for systemd
T}
_
T{
\fBsystem\fP
T}	T{
Support for reboot, shutdown, etc
T}
_
T{
\fBtest\fP
T}	T{
Module for running arbitrary tests
T}
_
T{
\fBtimezone\fP
T}	T{
Module for managing timezone on POSIX\-like systems.
T}
_
T{
\fBtls\fP
T}	T{
A salt module for SSL/TLS.
T}
_
T{
\fBtomcat\fP
T}	T{
Support for Tomcat
T}
_
T{
\fBupstart\fP
T}	T{
Module for the management of upstart systems.
T}
_
T{
\fBuseradd\fP
T}	T{
Manage users with the useradd command
T}
_
T{
\fBvirt\fP
T}	T{
Work with virtual machines managed by libvirt
T}
_
T{
\fBvirtualenv\fP
T}	T{
Create virtualenv environments
T}
_
T{
\fBwin_disk\fP
T}	T{
Module for gathering disk information on Windows
T}
_
T{
\fBwin_file\fP
T}	T{
Manage information about files on the minion, set/read user, group
T}
_
T{
\fBwin_groupadd\fP
T}	T{
Manage groups on Windows
T}
_
T{
\fBwin_network\fP
T}	T{
Module for gathering and managing network information
T}
_
T{
\fBwin_pkg\fP
T}	T{
A module to manage software on Windows
T}
_
T{
\fBwin_service\fP
T}	T{
Windows Service module.
T}
_
T{
\fBwin_shadow\fP
T}	T{
Manage the shadow file
T}
_
T{
\fBwin_status\fP
T}	T{
Module for returning various status data about a minion.
T}
_
T{
\fBwin_system\fP
T}	T{
Support for reboot, shutdown, etc
T}
_
T{
\fBwin_useradd\fP
T}	T{
Manage Windows users with the net user command
T}
_
T{
\fBxapi\fP
T}	T{
This module (mostly) uses the XenAPI to manage Xen virtual machines.
T}
_
T{
\fByumpkg5\fP
T}	T{
Support for YUM
T}
_
T{
\fByumpkg\fP
T}	T{
Support for YUM
T}
_
T{
\fBzfs\fP
T}	T{
Module for running ZFS command
T}
_
T{
\fBzpool\fP
T}	T{
Module for running ZFS zpool command
T}
_
T{
\fBzypper\fP
T}	T{
Package support for openSUSE via the zypper package manager
T}
_
.TE
.SS salt.modules.aliases
.sp
Manage the information in the aliases file
.INDENT 0.0
.TP
.B salt.modules.aliases.get_target(alias)
Return the target associated with an alias
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq aliases.get_target <alias>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.aliases.has_target(alias, target)
Return true if the alias/target is set
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq aliases.has_target <alias> <target>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.aliases.list_aliases()
Return the aliases found in the aliases file in this format:
.sp
.nf
.ft C
{\(aq<alias>\(aq: \(aq<target>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq aliases.list_aliases
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.aliases.rm_alias(alias)
Remove an entry from the aliases file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq aliases.rm_alias <alias>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.aliases.set_target(alias, target)
Set the entry in the aliases file for the given alias, this will overwrite
any previous entry for the given alias or create a new one if it does not
exist.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq aliases.set_target <alias> <target>
.ft P
.fi
.UNINDENT
.SS salt.modules.alternatives
.SS salt.modules.alternatives
.sp
Support for Alternatives system
.INDENT 0.0
.TP
.B codeauthor
Radek Rada <\fI\%radek.rada@gmail.com\fP>
.TP
.B copyright
Â© 2012 by the SaltStack Team, see AUTHORS for more details.
.TP
.B license
Apache 2.0, see LICENSE for more details.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.alternatives.check_installed(name, path)
Check if the alternatives link is set to desired path.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq alternatives.check_installed name path
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.alternatives.display(name)
Display alternatives settings for defined command name.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq alternatives.display <command name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.alternatives.install(name, link, path, priority)
Install symbolic links determining default commands.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq alternatives.install name link path priority
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.alternatives.remove(name, path)
Remove symbolic links determining the default commands.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq alternatives.remove name path
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.alternatives.show_current(name)
Display the current alternatives for the given name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq alternatives.show_current emacs
.ft P
.fi
.UNINDENT
.SS salt.modules.apache
.sp
Support for Apache
.INDENT 0.0
.TP
.B salt.modules.apache.directives()
Return list of directives together with expected arguments
and places where the directive is valid (\fBapachectl \-L\fP)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.directives
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.fullversion()
Return server version from apachectl \-V
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.fullversion
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.modules()
Return list of static and shared modules from apachectl \-M
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.modules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.servermods()
Return list of modules compiled into the server (apachectl \-l)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.servermods
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.signal(signal=None)
Signals httpd to start, restart, or stop.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.signal restart
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.useradd(pwfile, user, password, opts=\(aq\(aq)
Add an HTTP user using the htpasswd command. If the htpasswd file does not
exist, it will be created. Valid options that can be passed are:
.INDENT 7.0
.INDENT 3.5
n  Don\(aqt update file; display results on stdout.
m  Force MD5 encryption of the password (default).
d  Force CRYPT encryption of the password.
p  Do not encrypt the password (plaintext).
s  Force SHA encryption of the password.
.UNINDENT
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq apache.useradd /etc/httpd/htpasswd larry badpassword
salt \(aq*\(aq apache.useradd /etc/httpd/htpasswd larry badpass opts=ns
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.userdel(pwfile, user)
Delete an HTTP user from the specified htpasswd file.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq apache.userdel /etc/httpd/htpasswd larry
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.version()
Return server version from apachectl \-v
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq apache.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apache.vhosts()
Show the settings as parsed from the config file (currently
only shows the virtualhost settings). (\fBapachectl \-S\fP)
Because each additional virtual host adds to the execution
time, this command may require a long timeout be specified.
.sp
CLI Example:
.sp
.nf
.ft C
salt \-t 10 \(aq*\(aq apache.vhosts
.ft P
.fi
.UNINDENT
.SS salt.modules.apt
.sp
Support for APT (Advanced Packaging Tool)
.INDENT 0.0
.TP
.B salt.modules.apt.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.del_repo(repo, **kwargs)
Delete a repo from the sources.list / sources.list.d
.sp
If the .list file is in the sources.list.d directory
and the file that the repo exists in does not contain any other
repo configuration, the file itself will be deleted.
.sp
The repo passed in must be a fully formed repository definition
string.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.del_repo "myrepo definition"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.expand_repo_def(repokwargs)
Take a repository definition and expand it to the full pkg repository dict
that can be used for comparison.  This is a helper function to make
the Debian/Ubuntu apt sources sane for comparison in the pkgrepo states.
.sp
There is no use to calling this function via the CLI.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.file_dict(*packages)
List the files that belong to a package, grouped by package. Not
specifying any packages will return a list of _every_ file on the system\(aqs
package database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs package database (not
generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.get_repo(repo, **kwargs)
Display a repo from the sources.list / sources.list.d
.sp
The repo passwd in needs to be a complete repo entry.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.get_repo "myrepo definition"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.install(name=None, refresh=False, fromrepo=None, skip_verify=False, debconf=None, pkgs=None, sources=None, **kwargs)
Install the passed package, add refresh=True to update the dpkg database.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to install packages from a
software repository. To install a package file manually, use the
"sources" option.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to refresh the package database before installing.
.TP
.B fromrepo
Specify a package repository to install from
(e.g., \fBapt\-get \-t unstable install somepackage\fP)
.TP
.B skip_verify
Skip the GPG verification check (e.g., \fB\-\-allow\-unauthenticated\fP, or
\fB\-\-force\-bad\-verify\fP for install from package file).
.TP
.B debconf
Provide the path to a debconf answers file, processed before
installation.
.TP
.B version
Install a specific version of the package, e.g. 1.2.3~0ubuntu0. Ignored
if "pkgs" or "sources" is passed.
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3\-0ubuntu0"}]\(aq
.UNINDENT
.TP
.B sources
A list of DEB packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.deb"},{"bar": "salt://bar.deb"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
A specific repo can be requested using the \fBfromrepo\fP keyword argument.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package name> fromrepo=unstable
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.list_pkgs(versions_as_list=False, removed=False)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
If removed is \fBTrue\fP, then only packages which have been removed (but not
purged) will be returned.
.sp
External dependencies:
.sp
.nf
.ft C
Virtual package resolution requires dctrl\-tools.
Without dctrl\-tools virtual packages will be reported as not installed.
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
salt \(aq*\(aq pkg.list_pkgs versions_as_list=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.list_repos()
Lists all repos in the sources.list (and sources.lists.d) files
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_repos
salt \(aq*\(aq pkg.list_repos disabled=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.list_upgrades(refresh=True)
List all available package upgrades.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.mod_repo(repo, **kwargs)
Modify one or more values for a repo.  If the repo does not exist, it will
be created, so long as the definition is well formed.  For Ubuntu the
"ppa:<project>/repo" format is acceptable. "ppa:" format can only be
used to create a new repository.
.sp
The following options are available to modify a repo definition:
.sp
.nf
.ft C
comps (a comma separated list of components for the repo, e.g. "main")
file (a file name to be used)
keyserver (keyserver to get gpg key from)
keyid (key id to load with the keyserver argument)
key_url (URL to a gpg key to add to the apt gpg keyring)
consolidate (if true, will attempt to de\-dup and consolidate sources)

* Note: Due to the way keys are stored for apt, there is a known issue
        where the key wont be updated unless another change is made
        at the same time.  Keys should be properly added on initial
        configuration.
.ft P
.fi
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.mod_repo \(aqmyrepo definition\(aq uri=http://new/uri
salt \(aq*\(aq pkg.mod_repo \(aqmyrepo definition\(aq comps=main,universe
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0ubuntu1\(aq \(aq0.2.4.1\-0ubuntu1\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0ubuntu1\(aq pkg2=\(aq0.2.4.1\-0ubuntu1\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.purge(name=None, pkgs=None, **kwargs)
Remove packages via \fBapt\-get purge\fP along with all configuration files
and unused dependencies.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.refresh_db()
Updates the APT database to latest packages based upon repositories
.sp
Returns a dict, with the keys being package databases and the values being
the result of the update attempt. Values can be one of the following:
.INDENT 7.0
.INDENT 3.5
\fBTrue\fP: Database updated successfully
\fBFalse\fP: Problem updating database
\fBNone\fP: Database already up\-to\-date
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.remove(name=None, pkgs=None, **kwargs)
Remove packages using \fBapt\-get remove\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.upgrade(refresh=True, **kwargs)
Upgrades all packages via \fBapt\-get dist\-upgrade\fP
.sp
Returns a dict containing the changes.
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.TP
.B {\(aq<package>\(aq:  {\(aqold\(aq: \(aq<old\-version>\(aq,
\(aqnew\(aq: \(aq<new\-version>\(aq}}
.UNINDENT
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.apt.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.archive
.sp
A module to wrap archive calls
.INDENT 0.0
.TP
.B salt.modules.archive.gunzip(gzipfile, template=None)
Uses the gunzip command to unpack gzip files
.sp
CLI Example to create \fB/tmp/sourcefile.txt\fP:
.sp
.nf
.ft C
salt \(aq*\(aq archive.gunzip /tmp/sourcefile.txt.gz
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.gunzip template=jinja /tmp/{{grains.id}}.txt.gz
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.gzip(sourcefile, template=None)
Uses the gzip command to create gzip files
.sp
CLI Example to create \fB/tmp/sourcefile.txt.gz\fP:
.sp
.nf
.ft C
salt \(aq*\(aq archive.gzip /tmp/sourcefile.txt
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.gzip template=jinja /tmp/{{grains.id}}.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.rar(rarfile, template=None, *sources)
Uses the rar command to create rar files
Uses rar for Linux from \fI\%http://www.rarlab.com/\fP
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.rar /tmp/rarfile.rar /tmp/sourcefile1 /tmp/sourcefile2
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.rar template=jinja /tmp/rarfile.rar /tmp/sourcefile1 /tmp/{{grains.id}}.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.tar(options, tarfile, cwd=None, template=None, *sources)
Uses the tar command to pack, unpack, etc tar files
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.tar cjvf /tmp/tarfile.tar.bz2 /tmp/file_1 /tmp/file_2
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.tar template=jinja cjvf /tmp/salt.tar.bz2 {{grains.saltpath}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.unrar(rarfile, dest, template=None, *xfiles)
Uses the unrar command to unpack rar files
Uses rar for Linux from \fI\%http://www.rarlab.com/\fP
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.unrar /tmp/rarfile.rar /home/strongbad/ file_1 file_2
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.unrar template=jinja /tmp/rarfile.rar /tmp/{{grains.id}}/ file_1 file_2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.unzip(zipfile, dest, template=None, *xfiles)
Uses the unzip command to unpack zip files
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.unzip /tmp/zipfile.zip /home/strongbad/ file_1 file_2
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.unzip template=jinja /tmp/zipfile.zip /tmp/{{grains.id}}/ file_1 file_2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.archive.zip(zipfile, template=None, *sources)
Uses the zip command to create zip files
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.zip /tmp/zipfile.zip /tmp/sourcefile1 /tmp/sourcefile2
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq archive.zip template=jinja /tmp/zipfile.zip /tmp/sourcefile1 /tmp/{{grains.id}}.txt
.ft P
.fi
.UNINDENT
.SS salt.modules.at
.sp
Wrapper module for at(1)
.sp
Also, a \(aqtag\(aq feature has been added to more
easily tag jobs.
.INDENT 0.0
.TP
.B salt.modules.at.at(*args, **kwargs)
Add a job to the queue.
.sp
The \(aqtimespec\(aq follows the format documented in the
at(1) manpage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq at.at <timespec> <cmd> [tag=<tag>] [runas=<user>]
salt \(aq*\(aq at.at 12:05am \(aq/sbin/reboot\(aq tag=reboot
salt \(aq*\(aq at.at \(aq3:05am +3 days\(aq \(aqbin/myscript\(aq tag=nightly runas=jim
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.at.atc(jobid)
Print the at(1) script that will run for the passed job
id. This is mostly for debugging so the output will
just be text.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq at.atc <jobid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.at.atq(tag=None)
List all queued and running jobs or only those with
an optional \(aqtag\(aq.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq at.atq
salt \(aq*\(aq at.atq [tag]
salt \(aq*\(aq at.atq [job number]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.at.atrm(*args)
Remove jobs from the queue.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq at.atrm <jobid> <jobid> .. <jobid>
salt \(aq*\(aq at.atrm all
salt \(aq*\(aq at.atrm all [tag]
.ft P
.fi
.UNINDENT
.SS salt.modules.augeas_cfg
.sp
Manages configuration files via augeas
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
Augeas Python adapter
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.get(path, value=\(aq\(aq)
Get a value for a specific augeas path
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.get /files/etc/hosts/1/ ipaddr
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.ls(path)
List the direct children of a node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.ls /files/etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.match(path, value=\(aq\(aq)
Get matches for path expression
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.match /files/etc/services/service\-name ssh
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.remove(path)
Get matches for path expression
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.remove /files/etc/sysctl.conf/net.ipv4.conf.all.log_martians
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.setvalue(*args)
Set a value for a specific augeas path
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.setvalue /files/etc/hosts/1/canonical localhost
.ft P
.fi
.sp
This will set the first entry in /etc/hosts to localhost
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.setvalue /files/etc/hosts/01/ipaddr 192.168.1.1 \e
                         /files/etc/hosts/01/canonical test
.ft P
.fi
.sp
Adds a new host to /etc/hosts the ip address 192.168.1.1 and hostname test
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.setvalue prefix=/files/etc/sudoers/ \e
         "spec[user = \(aq%wheel\(aq]/user" "%wheel" \e
         "spec[user = \(aq%wheel\(aq]/host_group/host" \(aqALL\(aq \e
         "spec[user = \(aq%wheel\(aq]/host_group/command[1]" \(aqALL\(aq \e
         "spec[user = \(aq%wheel\(aq]/host_group/command[1]/tag" \(aqPASSWD\(aq \e
         "spec[user = \(aq%wheel\(aq]/host_group/command[2]" \(aq/usr/bin/apt\-get\(aq \e
         "spec[user = \(aq%wheel\(aq]/host_group/command[2]/tag" NOPASSWD
.ft P
.fi
.sp
Ensures that the following line is present in /etc/sudoers:
.sp
.nf
.ft C
%wheel ALL = PASSWD : ALL , NOPASSWD : /usr/bin/apt\-get , /usr/bin/aptitude
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.augeas_cfg.tree(path)
Returns recursively the complete tree of a node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq augeas.tree /files/etc/
.ft P
.fi
.UNINDENT
.SS salt.modules.bluez
.sp
Support for Bluetooth (using Bluez in Linux)
.INDENT 0.0
.TP
.B salt.modules.bluez.address()
Get the many addresses of the Bluetooth adapter
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.address
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.pair(address, key)
Pair the bluetooth adapter with a device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.pair DE:AD:BE:EF:CA:FE 1234
.ft P
.fi
.sp
Where DE:AD:BE:EF:CA:FE is the address of the device
to pair with, and 1234 is the passphrase.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.scan()
Scan for bluetooth devices in the area
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.scan
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.start()
Start the bluetooth service.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.start
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.stop()
Stop the bluetooth service.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.stop
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.unpair(address)
Unpair the bluetooth adapter from a device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetooth.unpair DE:AD:BE:EF:CA:FE
.ft P
.fi
.sp
Where DE:AD:BE:EF:CA:FE is the address of the device
to unpair.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bluez.version()
Return Bluez version from bluetoothd \-v
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bluetoothd.version
.ft P
.fi
.UNINDENT
.SS salt.modules.brew
.sp
Homebrew for Mac OS X
.INDENT 0.0
.TP
.B salt.modules.brew.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.install(name=None, pkgs=None, taps=None, options=None, **kwargs)
Install the passed package(s) with \fBbrew install\fP
.INDENT 7.0
.TP
.B name
The name of the formula to be installed. Note that this parameter is
ignored if "pkgs" is passed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name>
.ft P
.fi
.TP
.B taps
Unofficial Github repos to use when updating and installing formulas.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name> tap=\(aq<tap>\(aq
salt \(aq*\(aq pkg.install zlib taps=\(aqhomebrew/dupes\(aq
salt \(aq*\(aq pkg.install php54 taps=\(aq["josegonzalez/php", "homebrew/dupes"]\(aq
.ft P
.fi
.TP
.B options
Options to pass to brew. Only applies to inital install. Due to how brew
works, modifying chosen options requires a full uninstall followed by a
fresh install. Note that if "pkgs" is used, all options will be passed
to all packages. Unreconized options for a package will be silently
ignored by brew.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name> tap=\(aq<tap>\(aq
salt \(aq*\(aq pkg.install php54 taps=\(aq["josegonzalez/php", "homebrew/dupes"]\(aq options=\(aq["\-\-with\-fpm"]\(aq
.ft P
.fi
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of formulas to install. Must be passed as a python list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install pkgs=\(aq["foo","bar"]\(aq
.ft P
.fi
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install \(aqpackage package package\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation
.sp
Note that this currently not fully implemented but needs to return
something to avoid a traceback when calling pkg.latest.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.list_upgrades()
Check whether or not an upgrade is available for all packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.remove(name=None, pkgs=None, **kwargs)
Removes packages with \fBbrew uninstall\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.upgrade_available(pkg)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.brew.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3>
.ft P
.fi
.UNINDENT
.SS salt.modules.bridge
.sp
Module for gathering and managing bridging informations
.INDENT 0.0
.TP
.B salt.modules.bridge.add(br=None)
Creates a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.add br0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.addif(br=None, iface=None)
Adds an interface to a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.addif br0 eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.delete(br=None)
Deletes a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.delete br0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.delif(br=None, iface=None)
Removes an interface from a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.delif br0 eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.find_interfaces(*args)
Returns the bridge to which the interfaces are bond to
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.find_interfaces eth0 [eth1...]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.interfaces(br=None)
Returns interfaces attached to a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.interfaces br0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.list_()
Returns the machine\(aqs bridges list
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.show(br=None)
Returns bridges interfaces along with enslaved physical interfaces. If
no interface is given, all bridges are shown, else only the specified
bridge values are returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.show
salt \(aq*\(aq bridge.show br0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.bridge.stp(br=None, state=\(aqdisable\(aq, iface=None)
Sets Spanning Tree Protocol state for a bridge
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.stp br0 enable
salt \(aq*\(aq bridge.stp br0 disable
.ft P
.fi
.sp
For the NetBSD operating system, it is required to add the interface on
which to enable the STP.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq bridge.stp bridge0 enable fxp0
salt \(aq*\(aq bridge.stp bridge0 disable fxp0
.ft P
.fi
.UNINDENT
.SS salt.modules.cassandra
.sp
Cassandra NoSQL Database Module
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
pycassa Cassandra Python adapter
.UNINDENT
.TP
.B configuration
The location of the \(aqnodetool\(aq command, host, and thrift port needs to be
specified via pillar:
.sp
.nf
.ft C
cassandra.nodetool: /usr/local/bin/nodetool
cassandra.host: localhost
cassandra.thrift_port: 9160
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.column_families(keyspace=None)
Return existing column families for all keyspaces
or just the provided one.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.column_families
salt \(aq*\(aq cassandra.column_families <keyspace>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.column_family_definition(keyspace=None, column_family=None)
Return a dictionary of column family definitions for the given
keyspace/column_family
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.column_family_definition <keyspace> <column_family>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.compactionstats()
Return compactionstats info
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.compactionstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.info()
Return cassandra node info
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.keyspaces()
Return existing keyspaces
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.keyspaces
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.netstats()
Return netstats info
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.netstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.ring()
Return cassandra ring info
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.ring
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.tpstats()
Return tpstats info
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.tpstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cassandra.version()
Return the cassandra version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cassandra.version
.ft P
.fi
.UNINDENT
.SS salt.modules.cmdmod
.sp
A module for shelling out
.sp
Keep in mind that this module is insecure, in that it can give whomever has
access to the master root execution access to all salt minions
.INDENT 0.0
.TP
.B salt.modules.cmdmod.exec_code(lang, code, cwd=None)
Pass in two strings, the first naming the executable language, aka \-
python2, python3, ruby, perl, lua, etc. the second string containing
the code you wish to execute. The stdout and stderr will be returned
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.exec_code ruby \(aqputs "cheese"\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.has_exec(cmd)
Returns true if the executable is available on the minion, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.has_exec cat
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.retcode(cmd, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=(), template=None, umask=None, quiet=False, timeout=None)
Execute a shell command and return the command\(aqs return code.
.sp
Note that \fBenv\fP represents the environment variables for the command, and
should be formatted as a dict, or a YAML string which resolves to a dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.retcode "file /bin/bash"
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.retcode template=jinja "file {{grains.pythonpath[0]}}/python"
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.retcode "grep f" stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.run(cmd, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=(), template=None, rstrip=True, umask=None, quiet=False, timeout=None, **kwargs)
Execute the passed command and return the output as a string
.sp
Note that \fBenv\fP represents the environment variables for the command, and
should be formatted as a dict, or a YAML string which resolves to a dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run "ls \-l | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run template=jinja "ls \-l /tmp/{{grains.id}} | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
Specify an alternate shell with the shell parameter:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run "Get\-ChildItem C:\e " shell=\(aqpowershell\(aq
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run "grep f" stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.run_all(cmd, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=(), template=None, rstrip=True, umask=None, quiet=False, timeout=None, **kwargs)
Execute the passed command and return a dict of return data
.sp
Note that \fBenv\fP represents the environment variables for the command, and
should be formatted as a dict, or a YAML string which resolves to a dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_all "ls \-l | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_all template=jinja "ls \-l /tmp/{{grains.id}} | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_all "grep f" stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.run_stderr(cmd, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=(), template=None, rstrip=True, umask=None, quiet=False, timeout=None, **kwargs)
Execute a command and only return the standard error
.sp
Note that \fBenv\fP represents the environment variables for the command, and
should be formatted as a dict, or a YAML string which resolves to a dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stderr "ls \-l | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stderr template=jinja "ls \-l /tmp/{{grains.id}} | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stderr "grep f" stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.run_stdout(cmd, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=(), template=None, rstrip=True, umask=None, quiet=False, timeout=None, **kwargs)
Execute a command, and only return the standard out
.sp
Note that \fBenv\fP represents the environment variables for the command, and
should be formatted as a dict, or a YAML string which resolves to a dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stdout "ls \-l | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
The template arg can be set to \(aqjinja\(aq or another supported template
engine to render the command arguments before execution.
For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stdout template=jinja "ls \-l /tmp/{{grains.id}} | awk \(aq/foo/{print \e$2}\(aq"
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run_stdout "grep f" stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.script(source, args=None, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=\(aqbase\(aq, template=\(aqjinja\(aq, umask=None, timeout=None, **kwargs)
Download a script from a remote location and execute the script locally.
The script can be located on the salt master file server or on an HTTP/FTP
server.
.sp
The script will be executed directly, so it can be written in any available
programming language.
.sp
The script can also be formated as a template, the default is jinja.
Arguments for the script can be specified as well.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.script salt://scripts/runme.sh
salt \(aq*\(aq cmd.script salt://scripts/runme.sh \(aqarg1 arg2 "arg 3"\(aq
salt \(aq*\(aq cmd.script salt://scripts/windows_task.ps1 args=\(aq \-Input c:\etmp\einfile.txt\(aq shell=\(aqpowershell\(aq
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.script salt://scripts/runme.sh stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.script_retcode(source, cwd=None, stdin=None, runas=None, shell=\(aq/bin/bash\(aq, env=\(aqbase\(aq, template=\(aqjinja\(aq, umask=None, timeout=None, **kwargs)
Download a script from a remote location and execute the script locally.
The script can be located on the salt master file server or on an HTTP/FTP
server.
.sp
The script will be executed directly, so it can be written in any available
programming language.
.sp
The script can also be formated as a template, the default is jinja.
.sp
Only evaluate the script return code and do not block for terminal output
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.script_retcode salt://scripts/runme.sh
.ft P
.fi
.sp
A string of standard input can be specified for the command to be run using
the \fBstdin\fP parameter. This can be useful in cases where sensitive
information must be read from standard input.:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.script_retcode salt://scripts/runme.sh stdin=\(aqone\entwo\enthree\enfour\enfive\en\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.which(cmd)
Returns the path of an executable available on the minion, None otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.which cat
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cmdmod.which_bin(cmds)
Returns the first command found in a list of commands
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.which_bin \(aq[pip2, pip, pip\-python]\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.config
.sp
Return config information
.INDENT 0.0
.TP
.B salt.modules.config.backup_mode(backup=\(aq\(aq)
Return the backup mode
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.backup_mode
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.dot_vals(value)
Pass in a configuration value that should be preceded by the module name
and a dot, this will return a list of all read key/value pairs
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.dot_vals host
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.gather_bootstrap_script(replace=False)
Download the salt\-bootstrap script, set replace to True to refresh the
script if it has already been downloaded
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu.gather_bootstrap_script True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.get(key, default=\(aq\(aq)
Attempt to retrieve the named value from opts, pillar, grains of the master
config, if the named value is not available return the passed default.
The default return is an empty string.
.sp
The value can also represent a value in a nested dict using a ":" delimiter
for the dict. This means that if a dict looks like this:
.sp
{\(aqpkg\(aq: {\(aqapache\(aq: \(aqhttpd\(aq}}
.sp
To retrieve the value associated with the apache key in the pkg dict this
key can be passed:
.sp
pkg:apache
.sp
This routine traverses these data stores in this order:
.INDENT 7.0
.INDENT 3.5
Local minion config (opts)
Minion\(aqs grains
Minion\(aqs pillar
Master config
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.get pkg:apache
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.manage_mode(mode)
Return a mode value, normalized to a string
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.manage_mode
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.option(value, default=\(aq\(aq, omit_opts=False, omit_master=False, omit_pillar=False)
Pass in a generic option and receive the value that will be assigned
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.option redis.host
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.config.valid_fileproto(uri)
Returns a boolean value based on whether or not the URI passed has a valid
remote file protocol designation
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq config.valid_fileproto salt://path/to/file
.ft P
.fi
.UNINDENT
.SS salt.modules.cp
.sp
Minion side functions for salt\-cp
.INDENT 0.0
.TP
.B salt.modules.cp.cache_dir(path, env=\(aqbase\(aq, include_empty=False)
Download and cache everything under a directory from the master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.cache_dir salt://path/to/dir
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.cache_file(path, env=\(aqbase\(aq)
Used to cache a single file in the local salt\-master file cache.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.cache_file salt://path/to/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.cache_files(paths, env=\(aqbase\(aq)
Used to gather many files from the master, the gathered files will be
saved in the minion cachedir reflective to the paths retrieved from the
master.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.cache_files salt://pathto/file1,salt://pathto/file1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.cache_local_file(path)
Cache a local file on the minion in the localfiles cache
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.cache_local_file /etc/hosts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.cache_master(env=\(aqbase\(aq)
Retrieve all of the files on the master and cache them locally
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.cache_master
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.get_dir(path, dest, env=\(aqbase\(aq, template=None, gzip=None)
Used to recursively copy a directory from the salt master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_dir salt://path/to/dir/ /minion/dest
.ft P
.fi
.sp
get_dir supports the same template and gzip arguments as get_file.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.get_file(path, dest, env=\(aqbase\(aq, makedirs=False, template=None, gzip=None)
Used to get a single file from the salt master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_file salt://path/to/file /minion/dest
.ft P
.fi
.sp
Template rendering can be enabled on both the source and destination file
names like so:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_file "salt://{{grains.os}}/vimrc" /etc/vimrc template=jinja
.ft P
.fi
.sp
This example would instruct all Salt minions to download the vimrc from a
directory with the same name as their os grain and copy it to /etc/vimrc
.sp
For larger files, the cp.get_file module also supports gzip compression.
Because gzip is CPU\-intensive, this should only be used in scenarios where
the compression ratio is very high (e.g. pretty\-printed JSON or YAML
files).
.sp
Use the \fIgzip\fP named argument to enable it.  Valid values are 1..9, where 1
is the lightest compression and 9 the heaviest.  1 uses the least CPU on
the master (and minion), 9 uses the most.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.get_file_str(path, env=\(aqbase\(aq)
Return the contents of a file from a URL
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_file_str salt://my/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.get_template(path, dest, template=\(aqjinja\(aq, env=\(aqbase\(aq, **kwargs)
Render a file as a template before setting it down
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_template salt://path/to/template /minion/dest
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.get_url(path, dest, env=\(aqbase\(aq)
Used to get a single file from a URL.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.get_url salt://my/file /tmp/mine
salt \(aq*\(aq cp.get_url http://www.slashdot.org /tmp/index.html
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.hash_file(path, env=\(aqbase\(aq)
Return the hash of a file, to get the hash of a file on the
salt master file server prepend the path with salt://<file on server>
otherwise, prepend the file with / for a local file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.hash_file salt://path/to/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.is_cached(path, env=\(aqbase\(aq)
Return a boolean if the given path on the master has been cached on the
minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.is_cached salt://path/to/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.list_master(env=\(aqbase\(aq)
List all of the files stored on the master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.list_master
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.list_master_dirs(env=\(aqbase\(aq)
List all of the directories stored on the master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.list_master_dirs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.list_minion(env=\(aqbase\(aq)
List all of the files cached on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.list_minion
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.list_states(env=\(aqbase\(aq)
List all of the available state modules in an environment
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.list_states
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.push(path)
Push a file from the minion up to the master, the file will be saved to
the salt master in the master\(aqs minion files cachedir
(defaults to /var/cache/salt/master/minions/files)
.sp
Since this feature allows a minion to push a file up to the master server
it is disabled by default for security purposes. To enable add the option:
file_recv: True
to the master configuration and restart the master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cp.push /etc/fstab
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cp.recv(files, dest)
Used with salt\-cp, pass the files dict, and the destination.
.sp
This function receives small fast copy files from the master via salt\-cp
.sp
CLI Example:
.sp
.nf
.ft C
This function does not work via the CLI
.ft P
.fi
.UNINDENT
.SS salt.modules.cron
.sp
Work with cron
.INDENT 0.0
.TP
.B salt.modules.cron.list_tab(user)
Return the contents of the specified user\(aqs crontab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.list_tab root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.ls(user)
Return the contents of the specified user\(aqs crontab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.list_tab root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.raw_cron(user)
Return the contents of the user\(aqs crontab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.raw_cron root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.rm(user, cmd, minute=None, hour=None, daymonth=None, month=None, dayweek=None)
Remove a cron job for a specified user. If any of the day/time params are
specified, the job will only be removed if the specified params match.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.rm_job root /usr/local/weekly
salt \(aq*\(aq cron.rm_job root /usr/bin/foo dayweek=1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.rm_env(user, name)
Remove cron environment variable for a specified user.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.rm_env root MAILTO
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.rm_job(user, cmd, minute=None, hour=None, daymonth=None, month=None, dayweek=None)
Remove a cron job for a specified user. If any of the day/time params are
specified, the job will only be removed if the specified params match.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.rm_job root /usr/local/weekly
salt \(aq*\(aq cron.rm_job root /usr/bin/foo dayweek=1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.set_env(user, name, value=None)
Set up an environment variable in the crontab.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.set_env root MAILTO user@example.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.set_job(user, minute, hour, daymonth, month, dayweek, cmd)
Sets a cron job up for a specified user.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.set_job root \(aq*\(aq \(aq*\(aq \(aq*\(aq \(aq*\(aq 1 /usr/local/weekly
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.set_special(user, special, cmd)
Set up a special command in the crontab.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.set_special @hourly \(aqecho foobar\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.write_cron_file(user, path)
Writes the contents of a file to a user\(aqs crontab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.write_cron_file root /tmp/new_cron
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.cron.write_cron_file_verbose(user, path)
Writes the contents of a file to a user\(aqs crontab and return error message on error
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq cron.write_cron_file_verbose root /tmp/new_cron
.ft P
.fi
.UNINDENT
.SS salt.modules.daemontools
.sp
daemontools service module. This module will create daemontools type
service watcher.
This module is states.service compatible so it can be used to maintain
service state via provider interface:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
provider: daemontools
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.full_restart(name)
Calls daemontools.restart() function
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.full_restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.get_all()
Return a list of all available services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.reload_(name)
Wrapper for term()
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.restart(name)
Restart service via daemontools. This will stop/start service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.start(name)
Starts service via daemontools
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.status(name, sig=None)
Return the status for a service via daemontools, return pid if running
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.stop(name)
Stops service via daemontools
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.stop <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.daemontools.term(name)
Send a TERM to service via daemontools
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq daemontools.term <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.darwin_sysctl
.sp
Module for viewing and modifying sysctl parameters
.INDENT 0.0
.TP
.B salt.modules.darwin_sysctl.assign(name, value)
Assign a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.assign net.inet.icmp.icmplim 50
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.darwin_sysctl.get(name)
Return a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.get hw.physmem
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.darwin_sysctl.persist(name, value, config=\(aq/etc/sysctl.conf\(aq)
Assign and persist a simple sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.persist net.inet.icmp.icmplim 50
salt \(aq*\(aq sysctl.persist coretemp_load NO config=/etc/sysctl.conf
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.darwin_sysctl.show()
Return a list of sysctl parameters for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.show
.ft P
.fi
.UNINDENT
.SS salt.modules.data
.sp
Manage a local persistent data structure that can hold any arbitrary data
specific to the minion
.INDENT 0.0
.TP
.B salt.modules.data.cas(key, value, old_value)
Check and set a value in the minion datastore
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.cas <key> <value> <old_value>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.clear()
Clear out all of the data in the minion datastore, this function is
destructive!
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.clear
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.dump(new_data)
Replace the entire datastore with a passed data structure
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.dump \(aq{\(aqeggs\(aq: \(aqspam\(aq}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.getval(key)
Get a value from the minion datastore
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.getval <key>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.getvals(*keys)
Get values from the minion datastore
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.getvals <key> [<key> ...]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.load()
Return all of the data in the minion datastore
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.load
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.data.update(key, value)
Update a key with a value in the minion datastore
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq data.update <key> <value>
.ft P
.fi
.UNINDENT
.SS salt.modules.debconfmod
.sp
Support for Debconf
.INDENT 0.0
.TP
.B salt.modules.debconfmod.get_selections(fetchempty=True)
Answers to debconf questions for all packages in the following format:
.sp
.nf
.ft C
{\(aqpackage\(aq: [[\(aqquestion\(aq, \(aqtype\(aq, \(aqvalue\(aq], ...]}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq debconf.get_selections
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debconfmod.set_(package, question, type, value, *extra)
Set answers to debconf questions for a package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq debconf.set <package> <question> <type> <value> [<value> ...]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debconfmod.set_file(path, **kwargs)
Set answers to debconf questions from a file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq debconf.set_file salt://pathto/pkg.selections
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debconfmod.show(name)
Answers to debconf questions for a package in the following format:
.sp
.nf
.ft C
[[\(aqquestion\(aq, \(aqtype\(aq, \(aqvalue\(aq], ...]
.ft P
.fi
.sp
If debconf doesn\(aqt know about a package, we return None.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq debconf.show <package name>
.ft P
.fi
.UNINDENT
.SS salt.modules.debian_service
.sp
Service support for Debian systems \- uses update\-rc.d and service to modify the
system
.INDENT 0.0
.TP
.B salt.modules.debian_service.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.disabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.enabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.force_reload(name)
Force\-reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.force_reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.get_all()
Return all available boot services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.get_disabled()
Return a set of services that are installed but disabled
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.get_enabled()
Return a list of service that are enabled on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.reload_(name)
Reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.status(name, sig=None)
Return the status for a service, pass a signature to use to find
the service via ps
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.debian_service.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.dig
.sp
Compendium of generic DNS utilities
.INDENT 0.0
.TP
.B salt.modules.dig.A(host, nameserver=None)
Return the A record for \(aqhost\(aq.
.sp
Always returns a list.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.A www.google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dig.MX(domain, resolve=False, nameserver=None)
Return a list of lists for the MX of \(aqdomain\(aq. Example:
.sp
.nf
.ft C
>>> dig.MX(\(aqsaltstack.org\(aq)
[ [10, \(aqmx01.1and1.com.\(aq], [10, \(aqmx00.1and1.com.\(aq] ]
.ft P
.fi
.sp
If the \(aqresolve\(aq argument is True, resolve IPs for the servers.
.sp
It\(aqs limited to one IP, because although in practice it\(aqs very rarely a
round robin, it is an acceptable configuration and pulling just one IP lets
the data be similar to the non\-resolved version. If you think an MX has
multiple IPs, don\(aqt use the resolver here, resolve them in a separate step.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.MX google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dig.NS(domain, resolve=True, nameserver=None)
Return a list of IPs of the nameservers for \(aqdomain\(aq
.sp
If \(aqresolve\(aq is False, don\(aqt resolve names.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.NS google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dig.SPF(domain, record=\(aqSPF\(aq, nameserver=None)
Return the allowed IPv4 ranges in the SPF record for \(aqdomain\(aq.
.sp
If record is \(aqSPF\(aq and the SPF record is empty, the TXT record will be
searched automatically. If you know the domain uses TXT and not SPF,
specifying that will save a lookup.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.SPF google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dig.check_ip(x)
Check that string x is a valid IP
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.check_ip 127.0.0.1
.ft P
.fi
.UNINDENT
.SS salt.modules.disk
.sp
Module for gathering disk information
.INDENT 0.0
.TP
.B salt.modules.disk.inodeusage(args=None)
Return inode usage information for volumes mounted on this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq disk.inodeusage
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.disk.usage(args=None)
Return usage information for volumes mounted on this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq disk.usage
.ft P
.fi
.UNINDENT
.SS salt.modules.djangomod
.sp
Manage Django sites
.INDENT 0.0
.TP
.B salt.modules.djangomod.collectstatic(settings_module, bin_env=None, no_post_process=False, ignore=None, dry_run=False, clear=False, link=False, no_default_ignore=False, pythonpath=None, env=None)
Collect static files from each of your applications into a single location
that can easily be served in production.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq django.collectstatic <settings_module>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.djangomod.command(settings_module, command, bin_env=None, pythonpath=None, env=None, *args, **kwargs)
Run arbitrary django management command
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq django.command <settings_module> <command>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.djangomod.createsuperuser(settings_module, username, email, bin_env=None, database=None, pythonpath=None, env=None)
Create a super user for the database.
This function defaults to use the \fB\-\-noinput\fP flag which prevents the
creation of a password for the superuser.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq django.createsuperuser <settings_module> user user@example.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.djangomod.loaddata(settings_module, fixtures, bin_env=None, database=None, pythonpath=None, env=None)
Load fixture data
.INDENT 7.0
.TP
.B Fixtures:
comma separated list of fixtures to load
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq django.loaddata <settings_module> <comma delimited list of fixtures>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.djangomod.syncdb(settings_module, bin_env=None, migrate=False, database=None, pythonpath=None, env=None, noinput=True)
Run syncdb
.sp
Execute the Django\-Admin syncdb command, if South is available on the
minion the \fBmigrate\fP option can be passed as \fBTrue\fP calling the
migrations to run after the syncdb completes
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq django.syncdb <settings_module>
.ft P
.fi
.UNINDENT
.SS salt.modules.dnsmasq
.sp
Module for managing dnqmasq
.INDENT 0.0
.TP
.B salt.modules.dnsmasq.fullversion()
Shows installed version of dnsmasq, and compile options
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq dnsmasq.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsmasq.get_config(config_file=\(aq/etc/dnsmasq.conf\(aq)
Dumps all options from the config file
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq dnsmasq.get_config
salt \(aq*\(aq dnsmasq.get_config file=/etc/dnsmasq.conf
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsmasq.set_config(config_file=\(aq/etc/dnsmasq.conf\(aq, follow=True, **kwargs)
Sets a value or a set of values in the specified file. By default, if
conf\-dir is configured in this file, salt will attempt to set the option
in any file inside the conf\-dir where it has already been enabled. If it
does not find it inside any files, it will append it to the main config
file. Setting follow to False will turn off this behavior.
.sp
If a config option currently appears multiple times (such as dhcp\-host,
which is specified at least once per host), the new option will be added
to the end of the main config file (and not to any includes). If you need
an option added to a specific include file, specify it as the config_file.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq dnsmasq.set_config domain=mydomain.com
salt \(aq*\(aq dnsmasq.set_config follow=False domain=mydomain.com
salt \(aq*\(aq dnsmasq.set_config file=/etc/dnsmasq.conf domain=mydomain.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsmasq.version()
Shows installed version of dnsmasq
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq dnsmasq.version
.ft P
.fi
.UNINDENT
.SS salt.modules.dnsutil
.sp
Compendium of generic DNS utilities
.INDENT 0.0
.TP
.B salt.modules.dnsutil.A(host, nameserver=None)
Return the A record for \(aqhost\(aq.
.sp
Always returns a list.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.A www.google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.MX(domain, resolve=False, nameserver=None)
Return a list of lists for the MX of \(aqdomain\(aq. Example:
.sp
.nf
.ft C
>>> dig.MX(\(aqsaltstack.org\(aq)
[ [10, \(aqmx01.1and1.com.\(aq], [10, \(aqmx00.1and1.com.\(aq] ]
.ft P
.fi
.sp
If the \(aqresolve\(aq argument is True, resolve IPs for the servers.
.sp
It\(aqs limited to one IP, because although in practice it\(aqs very rarely a
round robin, it is an acceptable configuration and pulling just one IP lets
the data be similar to the non\-resolved version. If you think an MX has
multiple IPs, don\(aqt use the resolver here, resolve them in a separate step.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.MX google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.NS(domain, resolve=True, nameserver=None)
Return a list of IPs of the nameservers for \(aqdomain\(aq
.sp
If \(aqresolve\(aq is False, don\(aqt resolve names.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.NS google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.SPF(domain, record=\(aqSPF\(aq, nameserver=None)
Return the allowed IPv4 ranges in the SPF record for \(aqdomain\(aq.
.sp
If record is \(aqSPF\(aq and the SPF record is empty, the TXT record will be
searched automatically. If you know the domain uses TXT and not SPF,
specifying that will save a lookup.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.SPF google.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.check_ip(ip_addr)
Check that string ip_addr is a valid IP
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dig.check_ip 127.0.0.1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.hosts_append(hostsfile=\(aq/etc/hosts\(aq, ip_addr=None, entries=None)
Append a single line to the /etc/hosts file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq dnsutil.hosts_append /etc/hosts 127.0.0.1 ad1.yuk.co,ad2.yuk.co
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.hosts_remove(hostsfile=\(aq/etc/hosts\(aq, entries=None)
Remove a host from the /etc/hosts file. If doing so will leave a line
containing only an IP address, then the line will be deleted. This function
will leave comments and blank lines intact.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq dnsutil.hosts_delete /etc/hosts ad1.yuk.co
salt \(aq*\(aq dnsutil.hosts_delete /etc/hosts ad2.yuk.co,ad1.yuk.co
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.parse_hosts(hostsfile=\(aq/etc/hosts\(aq, hosts=None)
Parse /etc/hosts file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq dnsutil.parse_hosts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dnsutil.parse_zone(zonefile=None, zone=None)
Parses a zone file. Can be passed raw zone data on the API level.
.sp
CLI Example:
.sp
.nf
.ft C
salt ns1 dnsutil.parse_zone /var/lib/named/example.com.zone
.ft P
.fi
.UNINDENT
.SS salt.modules.dpkg
.sp
Support for DEB packages
.INDENT 0.0
.TP
.B salt.modules.dpkg.file_dict(*packages)
List the files that belong to a package, grouped by package. Not
specifying any packages will return a list of _every_ file on the system\(aqs
package database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.file_list httpd
salt \(aq*\(aq lowpkg.file_list httpd postfix
salt \(aq*\(aq lowpkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dpkg.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs package database (not
generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.file_list httpd
salt \(aq*\(aq lowpkg.file_list httpd postfix
salt \(aq*\(aq lowpkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.dpkg.list_pkgs(*packages)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
External dependencies:
.sp
.nf
.ft C
Virtual package resolution requires aptitude. Because this function
uses dpkg, virtual packages will be reported as not installed.
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.list_pkgs
salt \(aq*\(aq lowpkg.list_pkgs httpd
.ft P
.fi
.UNINDENT
.SS salt.modules.ebuild
.sp
Support for Portage
.INDENT 0.0
.TP
.B optdepends
.INDENT 7.0
.IP \(bu 2
portage Python adapter
.UNINDENT
.UNINDENT
.sp
For now all package names \fIMUST\fP include the package category,
i.e. \fB\(aqvim\(aq\fP will not work, \fB\(aqapp\-editors/vim\(aq\fP will.
.INDENT 0.0
.TP
.B salt.modules.ebuild.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.depclean(name=None, slot=None, pkgs=None)
Portage has a function to remove unused dependencies. If a package
is provided, it will only removed the package if no other package
depends on it.
.INDENT 7.0
.TP
.B name
The name of the package to be cleaned.
.TP
.B slot
Restrict the remove to a specific slot. Ignored if \fBname\fP is None.
.TP
.B pkgs
Clean multiple packages. \fBslot\fP argument is ignored if this
argument is present. Must be passed as a python list.
.UNINDENT
.sp
Return a list containing the removed packages:
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.depclean <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.install(name=None, refresh=False, pkgs=None, sources=None, slot=None, **kwargs)
Install the passed package(s), add refresh=True to sync the portage tree
before package is installed.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to emerge a package from the
portage tree. To install a tbz2 package manually, use the "sources"
option described below.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to sync the portage tree before installing.
.TP
.B version
Install a specific version of the package, e.g. 1.0.9\-r1. Ignored
if "pkgs" or "sources" is passed.
.TP
.B slot
Similar to version, but specifies a valid slot to be installed. It
will install the latest available version in the specified slot.
Ignored if "pkgs" or "sources" or "version" is passed.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sys\-devel/gcc slot=\(aq4.4\(aq
.UNINDENT
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from the portage tree. Must be passed as
a python list.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo","bar"]\(aq
.UNINDENT
.TP
.B sources
A list of tbz2 packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.tbz2"},{"bar": "salt://bar.tbz2"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.list_upgrades(refresh=True)
List all available package upgrades.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.porttree_matches(name)
Returns a list containing the matches for a given package name from the
portage tree. Note that the specific version of the package will not be
provided for packages that have several versions in the portage tree, but
rather the name of the package (i.e. "dev\-python/paramiko").
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.purge(name=None, slot=None, pkgs=None, **kwargs)
Portage does not have a purge, this function calls remove followed
by depclean to emulate a purge process
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.TP
.B slot
Restrict the remove to a specific slot. Ignored if name is None.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
Uninstall multiple packages. \fBslot\fP argument is ignored if this
argument is present. Must be passed as a python list.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package name> slot=4.4
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.refresh_db()
Updates the portage tree (emerge \-\-sync). Uses eix\-sync if available.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.remove(name=None, slot=None, pkgs=None, **kwargs)
Remove packages via emerge \-\-unmerge.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.TP
.B slot
Restrict the remove to a specific slot. Ignored if \fBname\fP is None.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
Uninstall multiple packages. \fBslot\fP argument is ignored if this
argument is present. Must be passed as a python list.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package name> slot=4.4
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.update(pkg, slot=None, refresh=False)
Updates the passed package (emerge \-\-update package)
.INDENT 7.0
.TP
.B slot
Restrict the update to a particular slot. It will update to the
latest version within the slot.
.UNINDENT
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.update <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.upgrade(refresh=True)
Run a full system upgrade (emerge \-\-update world)
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ebuild.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.eix
.sp
Support for Eix
.INDENT 0.0
.TP
.B salt.modules.eix.sync()
Sync portage/overlay trees and update the eix database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eix.sync
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.eix.update()
Update the eix database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eix.update
.ft P
.fi
.UNINDENT
.SS salt.modules.eselect
.sp
Support for eselect: the Gentoo\(aqs configuration and management tool.
.INDENT 0.0
.TP
.B salt.modules.eselect.exec_action(module, action, parameter=\(aq\(aq, state_only=False)
Execute an arbitrary action on a module.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eselect.exec_action <module name> <action> [parameter]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.eselect.get_current_target(module)
Get the currently selected target for the given module.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eselect.get_current_target <module name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.eselect.get_modules()
Get available modules list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eselect.get_modules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.eselect.get_target_list(module)
Get available target for the given module.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eselect.get_target_list <module name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.eselect.set_target(module, target)
Set the target for the given module.
Target can be specified by index or name.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq eselect.set_target <module name> <target>
.ft P
.fi
.UNINDENT
.SS salt.modules.event
.sp
Fire events on the minion, events can be fired up to the master
.INDENT 0.0
.TP
.B salt.modules.event.fire(data, tag)
Fire an event on the local minion event bus
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq event.fire \(aqstuff to be in the event\(aq \(aqtag\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.event.fire_master(data, tag)
Fire an event off on the master server
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq event.fire_master \(aqstuff to be in the event\(aq \(aqtag\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.extfs
.sp
Module for managing ext2/3/4 file systems
.INDENT 0.0
.TP
.B salt.modules.extfs.attributes(device, args=None)
Return attributes from dumpe2fs for a specified device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq extfs.attributes /dev/sda1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.extfs.blocks(device, args=None)
Return block and inode info from dumpe2fs for a specified device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq extfs.blocks /dev/sda1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.extfs.dump(device, args=None)
Return all contents of dumpe2fs for a specified device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq extfs.dump /dev/sda1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.extfs.mkfs(device, fs_type, **kwargs)
Create a file system on the specified device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq extfs.mkfs /dev/sda1 fs_type=ext4 opts=\(aqacl,noexec\(aq
.ft P
.fi
.sp
Valid options are:
.sp
.nf
.ft C
block_size: 1024, 2048 or 4096
check: check for bad blocks
direct: use direct IO
ext_opts: extended file system options (comma\-separated)
fragment_size: size of fragments
force: setting force to True will cause mke2fs to specify the \-F option
       twice (it is already set once); this is truly dangerous
blocks_per_group: number of blocks in a block group
number_of_groups: ext4 option for a virtual block group
bytes_per_inode: set the bytes/inode ratio
inode_size: size of the inode
journal: set to True to create a journal (default on ext3/4)
journal_opts: options for the fs journal (comma separated)
blocks_file: read bad blocks from file
label: label to apply to the file system
reserved: percentage of blocks reserved for super\-user
last_dir: last mounted directory
test: set to True to not actually create the file system (mke2fs \-n)
number_of_inodes: override default number of inodes
creator_os: override "creator operating system" field
opts: mount options (comma separated)
revision: set the filesystem revision (default 1)
super: write superblock and group descriptors only
fs_type: set the filesystem type (REQUIRED)
usage_type: how the filesystem is going to be used
uuid: set the UUID for the file system

see man 8 mke2fs for a more complete description of these options
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.extfs.tune(device, **kwargs)
Set attributes for the specified device (using tune2fs)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq extfs.tune /dev/sda1 force=True label=wildstallyns opts=\(aqacl,noexec\(aq
.ft P
.fi
.sp
Valid options are:
.sp
.nf
.ft C
max: max mount count
count: mount count
error: error behavior
extended_opts: extended options (comma separated)
force: force, even if there are errors (set to True)
group: group name or gid that can use the reserved blocks
interval: interval between checks
journal: set to True to create a journal (default on ext3/4)
journal_opts: options for the fs journal (comma separated)
label: label to apply to the file system
reserved: percentage of blocks reserved for super\-user
last_dir: last mounted directory
opts: mount options (comma separated)
feature: set or clear a feature (comma separated)
mmp_check: mmp check interval
reserved: reserved blocks count
quota_opts: quota options (comma separated)
time: time last checked
user: user or uid who can use the reserved blocks
uuid: set the UUID for the file system

see man 8 tune2fs for a more complete description of these options
.ft P
.fi
.UNINDENT
.SS salt.modules.file
.sp
Manage information about files on the minion, set/read user, group, and mode
data
.INDENT 0.0
.TP
.B salt.modules.file.append(path, *args)
Append text to the end of a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.append /etc/motd \e
        "With all thine offerings thou shalt offer salt."\e
        "Salt is what makes things taste bad when it isn\(aqt in them."
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.check_file_meta(name, sfn, source, source_sum, user, group, mode, env, template=None, contents=None)
Check for the changes in the file metadata.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.check_file_meta /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf \(aq{hash_type: \(aqmd5\(aq, \(aqhsum\(aq: <md5sum>}\(aq root, root, \(aq755\(aq base
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.check_hash(path, hash)
Check if a file matches the given hash string
.sp
Returns true if the hash matched, otherwise false. Raises ValueError if
the hash was not formatted correctly.
.INDENT 7.0
.TP
.B path
A file path
.TP
.B hash
A string in the form <hash_type>=<hash_value>. For example:
\fBmd5=e138491e9d5b97023cea823fe17bac22\fP
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.check_hash /etc/fstab md5=<md5sum>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.check_managed(name, source, source_hash, user, group, mode, template, makedirs, context, defaults, env, contents=None, **kwargs)
Check to see what changes need to be made for a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.check_managed /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf \(aq{hash_type: \(aqmd5\(aq, \(aqhsum\(aq: <md5sum>}\(aq root, root, \(aq755\(aq jinja True None None base
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.check_perms(name, ret, user, group, mode)
Check the permissions on files and chown if needed
.INDENT 7.0
.TP
.B Note: \(aqmode\(aq here is expected to be either a string or an integer,
in which case it will be converted into a base\-10 string.
.sp
What this means is that in your YAML salt file, you can specify
mode as an integer(eg, 644) or as a string(eg, \(aq644\(aq). But, to
specify mode 0777, for example, it must be specified as the string,
\(aq0777\(aq otherwise, 0777 will be parsed as an octal and you\(aqd get 511
instead.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.check_perms /etc/sudoers \(aq{}\(aq root root 400
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.chgrp(path, group)
Change the group of a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.chgrp /etc/passwd root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.chown(path, user, group)
Chown a file, pass the file the desired user and group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.chown /etc/passwd root root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.comment(path, regex, char=\(aq#\(aq, backup=\(aq.bak\(aq)
Comment out specified lines in a file
.INDENT 7.0
.TP
.B path
The full path to the file to be edited
.TP
.B regex
A regular expression used to find the lines that are to be commented;
this pattern will be wrapped in parenthesis and will move any
preceding/trailing \fB^\fP or \fB$\fP characters outside the parenthesis
(e.g., the pattern \fB^foo$\fP will be rewritten as \fB^(foo)$\fP)
.TP
.B char
\fB#\fP
The character to be inserted at the beginning of a line in order to
comment it out
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension
.IP Warning
This backup will be overwritten each time \fBsed\fP / \fBcomment\fP /
\fBuncomment\fP is called. Meaning the backup will only be useful
after the first invocation.
.RE
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.comment /etc/modules pcspkr
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.contains(path, text)
Return True if the file at \fBpath\fP contains \fBtext\fP
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.contains /etc/crontab \(aqmymaintenance.sh\(aq
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.contains_glob(path, glob)
Return True if the given glob matches a string in the named file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.contains_glob /etc/foobar \(aq*cheese*\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.contains_regex(path, regex, lchar=\(aq\(aq)
Return True if the given regular expression matches on any line in the text
of a given file.
.sp
If the lchar argument (leading char) is specified, it
will strip \fIlchar\fP from the left side of each line before trying to match
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq file.contains_regex /etc/crontab
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.contains_regex_multiline(path, regex)
Return True if the given regular expression matches anything in the text
of a given file
.sp
Traverses multiple lines at a time, via the salt BufferedReader (reads in
chunks)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.contains_regex_multiline /etc/crontab \(aq^maint\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.directory_exists(path)
Tests to see if path is a valid directory.  Returns True/False.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.directory_exists /etc
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.file_exists(path)
Tests to see if path is a valid file.  Returns True/False.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.file_exists /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.find(path, **kwargs)
Approximate the Unix find(1) command and return a list of paths that
meet the specified criteria.
.sp
The options include match criteria:
.sp
.nf
.ft C
name    = path\-glob                 # case sensitive
iname   = path\-glob                 # case insensitive
regex   = path\-regex                # case sensitive
iregex  = path\-regex                # case insensitive
type    = file\-types                # match any listed type
user    = users                     # match any listed user
group   = groups                    # match any listed group
size    = [+\-]number[size\-unit]     # default unit = byte
mtime   = interval                  # modified since date
grep    = regex                     # search file contents
.ft P
.fi
.sp
and/or actions:
.sp
.nf
.ft C
delete [= file\-types]               # default type = \(aqf\(aq
exec    = command [arg ...]         # where {} is replaced by pathname
print  [= print\-opts]
.ft P
.fi
.sp
The default action is \(aqprint=path\(aq.
.sp
file\-glob:
.sp
.nf
.ft C
*                = match zero or more chars
?                = match any char
[abc]            = match a, b, or c
[!abc] or [^abc] = match anything except a, b, and c
[x\-y]            = match chars x through y
[!x\-y] or [^x\-y] = match anything except chars x through y
{a,b,c}          = match a or b or c
.ft P
.fi
.sp
path\-regex: a Python re (regular expression) pattern to match pathnames
.sp
file\-types: a string of one or more of the following:
.sp
.nf
.ft C
a: all file types
b: block device
c: character device
d: directory
p: FIFO (named pipe)
f: plain file
l: symlink
s: socket
.ft P
.fi
.sp
users: a space and/or comma separated list of user names and/or uids
.sp
groups: a space and/or comma separated list of group names and/or gids
.sp
size\-unit:
.sp
.nf
.ft C
b: bytes
k: kilobytes
m: megabytes
g: gigabytes
t: terabytes
.ft P
.fi
.sp
interval:
.sp
.nf
.ft C
[<num>w] [<num>[d]] [<num>h] [<num>m] [<num>s]

where:
    w: week
    d: day
    h: hour
    m: minute
    s: second
.ft P
.fi
.sp
print\-opts: a comma and/or space separated list of one or more of the
following:
.sp
.nf
.ft C
group: group name
md5:   MD5 digest of file contents
mode:  file permissions (as integer)
mtime: last modification time (as time_t)
name:  file basename
path:  file absolute path
size:  file size in bytes
type:  file type
user:  user name
.ft P
.fi
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq file.find / type=f name=\e*.bak size=+10m
salt \(aq*\(aq file.find /var mtime=+30d size=+10m print=path,size,mtime
salt \(aq*\(aq file.find /var/log name=\e*.[0\-9] mtime=+30d size=+10m delete
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_diff(minionfile, masterfile, env=\(aqbase\(aq)
Return unified diff of file compared to file on master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_diff /home/fred/.vimrc salt://users/fred/.vimrc
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_gid(path)
Return the id of the group that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_gid /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_group(path)
Return the group that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_group /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_hash(path, form=\(aqmd5\(aq, chunk_size=4096)
Get the hash sum of a file
.INDENT 7.0
.TP
.B This is better than \fBget_sum\fP for the following reasons:
.INDENT 7.0
.IP \(bu 2
It does not read the entire file into memory.
.IP \(bu 2
.INDENT 2.0
.TP
.B It does not return a string on error. The returned value of
\fBget_sum\fP cannot really be trusted since it is vulnerable to
collisions: \fBget_sum(..., \(aqxyz\(aq) == \(aqHash xyz not supported\(aq\fP
.UNINDENT
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_hash /etc/shadow
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_managed(name, template, source, source_hash, user, group, mode, env, context, defaults, **kwargs)
Return the managed file data for file.managed
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_managed /etc/httpd/conf.d/httpd.conf jinja salt://http/httpd.conf \(aq{hash_type: \(aqmd5\(aq, \(aqhsum\(aq: <md5sum>}\(aq root root \(aq755\(aq base None None
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_mode(path)
Return the mode of a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_mode /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_selinux_context(path)
Get an SELinux context from a given path
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_selinux_context /etc/hosts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_sum(path, form=\(aqmd5\(aq)
Return the sum for the given file, default is md5, sha1, sha224, sha256,
sha384, sha512 are supported
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_sum /etc/passwd sha512
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_uid(path)
Return the id of the user that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_uid /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.get_user(path)
Return the user that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_user /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.gid_to_group(gid)
Convert the group id to the group name on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.gid_to_group 0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.group_to_gid(group)
Convert the group to the gid on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.group_to_gid root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.makedirs(path, user=None, group=None, mode=None)
Ensure that the directory containing this path is available.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.makedirs /opt/code
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.makedirs_perms(name, user=None, group=None, mode=\(aq0755\(aq)
Taken and modified from os.makedirs to set user, group and mode for each
directory created.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.makedirs_perms /opt/code
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.manage_file(name, sfn, ret, source, source_sum, user, group, mode, env, backup, template=None, show_diff=True, contents=None)
Checks the destination against what was retrieved with get_managed and
makes the appropriate modifications (if necessary).
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.manage_file /etc/httpd/conf.d/httpd.conf \(aq{}\(aq salt://http/httpd.conf \(aq{hash_type: \(aqmd5\(aq, \(aqhsum\(aq: <md5sum>}\(aq root root \(aq755\(aq base \(aq\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.mkdir(dir_path, user=None, group=None, mode=None)
Ensure that a directory is available.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.mkdir /opt/jetty/context
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.patch(originalfile, patchfile, options=\(aq\(aq, dry_run=False)
Apply a patch to a file
.sp
Equivalent to:
.sp
.nf
.ft C
patch <options> <originalfile> <patchfile>
.ft P
.fi
.INDENT 7.0
.TP
.B originalfile
The full path to the file or directory to be patched
.TP
.B patchfile
A patch file to apply to \fBoriginalfile\fP
.TP
.B options
Options to pass to patch.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.patch /opt/file.txt /tmp/file.txt.patch
.ft P
.fi
.sp
New in version 0.10.4.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.psed(path, before, after, limit=\(aq\(aq, backup=\(aq.bak\(aq, flags=\(aqgMS\(aq, escape_all=False, multi=False)
Make a simple edit to a file (pure Python version)
.sp
Equivalent to:
.sp
.nf
.ft C
sed <backup> <options> "/<limit>/ s/<before>/<after>/<flags> <file>"
.ft P
.fi
.INDENT 7.0
.TP
.B path
The full path to the file to be edited
.TP
.B before
A pattern to find in order to replace with \fBafter\fP
.TP
.B after
Text that will replace \fBbefore\fP
.TP
.B limit
\fB\(aq\(aq\fP
An initial pattern to search for before searching for \fBbefore\fP
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension;
\fBWARNING:\fP each time \fBsed\fP/\fBcomment\fP/\fBuncomment\fP is called will
overwrite this backup
.TP
.B flags
\fBgMS\fP.INDENT 7.0
.TP
.B Flags to modify the search. Valid values are :
\fBg\fP: Replace all occurrences of the pattern, not just the first.
\fBI\fP: Ignore case.
\fBL\fP: Make \fB\ew\fP, \fB\eW\fP, \fB\eb\fP, \fB\eB\fP, \fB\es\fP and \fB\eS\fP dependent on the locale.
\fBM\fP: Treat multiple lines as a single line.
\fBS\fP: Make \fI.\fP match all characters, including newlines.
\fBU\fP: Make \fB\ew\fP, \fB\eW\fP, \fB\eb\fP, \fB\eB\fP, \fB\ed\fP, \fB\eD\fP, \fB\es\fP and \fB\eS\fP dependent on Unicode.
\fBX\fP: Verbose (whitespace is ignored).
.UNINDENT
.TP
.B multi: \fBFalse\fP
If True, treat the entire file as a single line
.UNINDENT
.sp
Forward slashes and single quotes will be escaped automatically in the
\fBbefore\fP and \fBafter\fP patterns.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.sed /etc/httpd/httpd.conf \(aqLogLevel warn\(aq \(aqLogLevel info\(aq
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.remove(path)
Remove the named file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.remove /tmp/foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.rename(src, dst)
Rename a file or directory
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.rename /path/to/src /path/to/dst
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.restorecon(path, recursive=False)
Reset the SELinux context on a given path
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.restorecon /home/user/.ssh/authorized_keys
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.sed(path, before, after, limit=\(aq\(aq, backup=\(aq.bak\(aq, options=\(aq\-r \-e\(aq, flags=\(aqg\(aq, escape_all=False)
Make a simple edit to a file
.sp
Equivalent to:
.sp
.nf
.ft C
sed <backup> <options> "/<limit>/ s/<before>/<after>/<flags> <file>"
.ft P
.fi
.INDENT 7.0
.TP
.B path
The full path to the file to be edited
.TP
.B before
A pattern to find in order to replace with \fBafter\fP
.TP
.B after
Text that will replace \fBbefore\fP
.TP
.B limit
\fB\(aq\(aq\fP
An initial pattern to search for before searching for \fBbefore\fP
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension;
\fBWARNING:\fP each time \fBsed\fP/\fBcomment\fP/\fBuncomment\fP is called will
overwrite this backup
.TP
.B options
\fB\-r \-e\fP
Options to pass to sed
.TP
.B flags
\fBg\fP
Flags to modify the sed search; e.g., \fBi\fP for case\-insensitve pattern
matching
.UNINDENT
.sp
Forward slashes and single quotes will be escaped automatically in the
\fBbefore\fP and \fBafter\fP patterns.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.sed /etc/httpd/httpd.conf \(aqLogLevel warn\(aq \(aqLogLevel info\(aq
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.sed_contains(path, text, limit=\(aq\(aq, flags=\(aqg\(aq)
Return True if the file at \fBpath\fP contains \fBtext\fP. Utilizes sed to
perform the search (line\-wise search).
.sp
Note: the \fBp\fP flag will be added to any flags you pass in.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.contains /etc/crontab \(aqmymaintenance.sh\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.set_mode(path, mode)
Set the mode of a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.set_mode /etc/passwd 0644
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.set_selinux_context(path, user=None, role=None, type=None, range=None)
Set a specific SELinux label on a given path
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.set_selinux_context path <role> <type> <range>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.source_list(source, source_hash, env)
Check the source list and return the source to use
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.source_list salt://http/httpd.conf \(aq{hash_type: \(aqmd5\(aq, \(aqhsum\(aq: <md5sum>}\(aq base
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.stats(path, hash_type=\(aqmd5\(aq, follow_symlink=False)
Return a dict containing the stats for a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.stats /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.symlink(src, link)
Create a symbolic link to a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.symlink /path/to/file /path/to/link
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.touch(name, atime=None, mtime=None)
Just like \(aqnix\(aqs "touch" command, create a file if it
doesn\(aqt exist or simply update the atime and mtime if
it already does.
.INDENT 7.0
.TP
.B atime:
Access time in Unix epoch time
.TP
.B mtime:
Last modification in Unix epoch time
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.touch /var/log/emptyfile
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.uid_to_user(uid)
Convert a uid to a user name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.uid_to_user 0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.uncomment(path, regex, char=\(aq#\(aq, backup=\(aq.bak\(aq)
Uncomment specified commented lines in a file
.INDENT 7.0
.TP
.B path
The full path to the file to be edited
.TP
.B regex
A regular expression used to find the lines that are to be uncommented.
This regex should not include the comment character. A leading \fB^\fP
character will be stripped for convenience (for easily switching
between comment() and uncomment()).
.TP
.B char
\fB#\fP
The character to remove in order to uncomment a line
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension;
\fBWARNING:\fP each time \fBsed\fP/\fBcomment\fP/\fBuncomment\fP is called will
overwrite this backup
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.uncomment /etc/hosts.deny \(aqALL: PARANOID\(aq
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.file.user_to_uid(user)
Convert user name to a uid
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.user_to_uid root
.ft P
.fi
.UNINDENT
.SS salt.modules.freebsdjail
.sp
The jail module for FreeBSD
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.fstab(jail)
Display contents of a fstab(5) file defined in specified
jail\(aqs configuration. If no file is defined, return False.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.fstab <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.get_enabled()
Return which jails are set to be run
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.is_enabled()
See if jail service is actually enabled on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.is_enabled <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.restart(jail=\(aq\(aq)
Restart the specified jail or all, if none specified
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.restart [<jail name>]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.show_config(jail)
Display specified jail\(aqs configuration
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.show_config <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.start(jail=\(aq\(aq)
Start the specified jail or all, if none specified
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.start [<jail name>]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.status(jail)
See if specified jail is currently running
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.status <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.stop(jail=\(aq\(aq)
Stop the specified jail or all, if none specified
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.stop [<jail name>]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdjail.sysctl()
Dump all jail related kernel states (sysctl)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq jail.sysctl
.ft P
.fi
.UNINDENT
.SS salt.modules.freebsdkmod
.sp
Module to manage FreeBSD kernel modules
.INDENT 0.0
.TP
.B salt.modules.freebsdkmod.available()
Return a list of all available kernel modules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.available
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdkmod.check_available(mod)
Check to see if the specified kernel module is available
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.check_available kvm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdkmod.load(mod)
Load the specified kernel module
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.load kvm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdkmod.lsmod()
Return a dict containing information about currently loaded modules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.lsmod
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdkmod.remove(mod)
Remove the specified kernel module
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.remove kvm
.ft P
.fi
.UNINDENT
.SS salt.modules.freebsdpkg
.sp
Package support for FreeBSD
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.file_dict(*packages)
List the files that belong to a package, grouped by package. Not
specifying any packages will return a list of _every_ file on the
system\(aqs package database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs package database (not
generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs)
Install the passed package
.INDENT 7.0
.TP
.B name
The name of the package to be installed.
.TP
.B refresh
Whether or not to refresh the package database before installing.
.TP
.B fromrepo
Specify a package repository to install from.
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install pkgs=\(aq["foo","bar"]\(aq
.ft P
.fi
.TP
.B sources
A list of packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.deb"},{"bar": "salt://bar.deb"}]\(aq
.ft P
.fi
.UNINDENT
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.refresh_db()
Use pkg update to get latest repo.txz when using pkgng, else update the
ports tree with portsnap otherwise. If the ports tree does not exist it
will be downloaded and set up.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.rehash()
Recomputes internal hash table for the PATH variable.
Use whenever a new command is created during the current
session.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.rehash
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.remove(name=None, pkgs=None, **kwargs)
Remove packages.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.search(pkg_name)
Use \fIpkg search\fP if pkg is being used.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.search \(aqmysql\-server\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.upgrade()
Run pkg upgrade, if pkgng used. Otherwise do nothing
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdpkg.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.freebsdservice
.sp
The service module for FreeBSD
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.available(name, **kwargs)
Check that the given service is available.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.available sshd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.disable(name, **kwargs)
Disable the named service to start at boot
.sp
Arguments the same as for enable()
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.disabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.enable(name, **kwargs)
Enable the named service to start at boot
.INDENT 7.0
.TP
.B name
service name
.TP
.B config
/etc/rc.conf
Config file for managing service. If config value is
empty string, then /etc/rc.conf.d/<service> used.
See man rc.conf(5) for details.
.sp
Also service.config variable can be used to change default.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.enabled(name)
Return True if the named service is enabled, false otherwise
.INDENT 7.0
.TP
.B name
Service name
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.get_all()
Return a list of all available services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.get_disabled()
Return what services are available but not enabled to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.get_enabled()
Return what services are set to run on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.reload_(name)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.status(name, sig=None)
Return the status for a service (True or False).
.INDENT 7.0
.TP
.B name
Name of service.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsdservice.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.freebsd_sysctl
.sp
Module for viewing and modifying sysctl parameters
.INDENT 0.0
.TP
.B salt.modules.freebsd_sysctl.assign(name, value)
Assign a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.assign net.inet.icmp.icmplim 50
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsd_sysctl.get(name)
Return a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.get hw.physmem
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsd_sysctl.persist(name, value, config=\(aq/etc/sysctl.conf\(aq)
Assign and persist a simple sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.persist net.inet.icmp.icmplim 50
salt \(aq*\(aq sysctl.persist coretemp_load NO config=/boot/loader.conf
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.freebsd_sysctl.show()
Return a list of sysctl parameters for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.show
.ft P
.fi
.UNINDENT
.SS salt.modules.gem
.sp
Manage ruby gems.
.INDENT 0.0
.TP
.B salt.modules.gem.install(gems, ruby=None, runas=None, version=None, rdoc=False, ri=False)
Installs one or several gems.
.INDENT 7.0
.TP
.B gems
The gems to install.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.TP
.B version
None
Specify the version to install for the gem.
Doesn\(aqt play nice with multiple gems at once
.TP
.B rdoc
False
Generate RDoc documentation for the gem(s).
.TP
.B ri
False
Generate RI documentation for the gem(s).
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.install vagrant
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.list_(prefix=\(aq\(aq, ruby=None, runas=None)
List locally installed gems.
.INDENT 7.0
.TP
.B prefix :
Only list gems when the name matches this prefix.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
gem.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.sources_add(source_uri, ruby=None, runas=None)
Add a gem source.
.INDENT 7.0
.TP
.B source_uri
The source URI to add.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.sources_add http://rubygems.org/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.sources_list(ruby=None, runas=None)
List the configured gem sources.
.INDENT 7.0
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.sources_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.sources_remove(source_uri, ruby=None, runas=None)
Remove a gem source.
.INDENT 7.0
.TP
.B source_uri
The source URI to remove.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.sources_remove http://rubygems.org/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.uninstall(gems, ruby=None, runas=None)
Uninstall one or several gems.
.INDENT 7.0
.TP
.B gems
The gems to uninstall.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.uninstall vagrant
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.update(gems, ruby=None, runas=None)
Update one or several gems.
.INDENT 7.0
.TP
.B gems
The gems to update.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.update vagrant
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gem.update_system(version=\(aq\(aq, ruby=None, runas=None)
Update rubygems.
.INDENT 7.0
.TP
.B version
(newest)
The version of rubygems to install.
.TP
.B ruby
None
If RVM is installed, the ruby version and gemset to use.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gem.update_system
.ft P
.fi
.UNINDENT
.SS salt.modules.gentoolkitmod
.sp
Support for Gentoolkit
.INDENT 0.0
.TP
.B salt.modules.gentoolkitmod.eclean_dist(destructive=False, package_names=False, size_limit=0, time_limit=0, fetch_restricted=False, exclude_file=\(aq/etc/eclean/distfiles.exclude\(aq)
Clean obsolete portage sources
.INDENT 7.0
.TP
.B destructive
Only keep minimum for reinstallation
.TP
.B package_names
Protect all versions of installed packages. Only meaningful if used
with destructive=True
.TP
.B size_limit <size>
Don\(aqt delete distfiles bigger than <size>.
<size> is a size specification: "10M" is "ten megabytes",
"200K" is "two hundreds kilobytes", etc. Units are: G, M, K and B.
.TP
.B time_limit <time>
Don\(aqt delete distfiles files modified since <time>
<time> is an amount of time: "1y" is "one year", "2w" is
"two weeks", etc. Units are: y (years), m (months), w (weeks),
d (days) and h (hours).
.TP
.B fetch_restricted
Protect fetch\-restricted files. Only meaningful if used with
destructive=True
.TP
.B exclude_file
Path to exclusion file. Default is /etc/eclean/distfiles.exclude
This is the same default eclean\-dist uses. Use None if this file
exists and you want to ignore.
.UNINDENT
.sp
Return a dict containing the cleaned, saved, and deprecated dists:
.sp
.nf
.ft C
{\(aqcleaned\(aq: {<dist file>: <size>},
 \(aqdeprecated\(aq: {<package>: <dist file>},
 \(aqsaved\(aq: {<package>: <dist file>},
 \(aqtotal_cleaned\(aq: <size>}
.ft P
.fi
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq gentoolkit.eclean_dist destructive=True
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoolkitmod.eclean_pkg(destructive=False, package_names=False, time_limit=0, exclude_file=\(aq/etc/eclean/packages.exclude\(aq)
Clean obsolete binary packages
.INDENT 7.0
.TP
.B destructive
Only keep minimum for reinstallation
.TP
.B package_names
Protect all versions of installed packages. Only meaningful if used
with destructive=True
.TP
.B time_limit <time>
Don\(aqt delete distfiles files modified since <time>
<time> is an amount of time: "1y" is "one year", "2w" is
"two weeks", etc. Units are: y (years), m (months), w (weeks),
d (days) and h (hours).
.TP
.B exclude_file
Path to exclusion file. Default is /etc/eclean/packages.exclude
This is the same default eclean\-pkg uses. Use None if this file
exists and you want to ignore.
.UNINDENT
.sp
Return a dict containing the cleaned binary packages:
.sp
.nf
.ft C
{\(aqcleaned\(aq: {<dist file>: <size>},
 \(aqtotal_cleaned\(aq: <size>}
.ft P
.fi
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq gentoolkit.eclean_pkg destructive=True
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoolkitmod.glsa_check_list(glsa_list)
List the status of Gentoo Linux Security Advisories
.INDENT 7.0
.TP
.B glsa_list
can contain an arbitrary number of GLSA ids, filenames
containing GLSAs or the special identifiers \(aqall\(aq and \(aqaffected\(aq
.UNINDENT
.sp
Returns a dict containing glsa ids with a description, status, and CVEs:
.sp
.nf
.ft C
{<glsa id>: {\(aqdescription\(aq: <glsa description>,
    \(aqstatus\(aq: <glsa status>,
    \(aqCVEs\(aq: [<list of CVEs>]}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gentoolkit.glsa_check_list \(aqaffected\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoolkitmod.revdep_rebuild(lib=None)
Fix up broken reverse dependencies
.INDENT 7.0
.TP
.B lib
Search for reverse dependencies for a particular library rather
than every library on the system. It can be a full path to a
library or basic regular expression.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq gentoolkit.revdep_rebuild
.ft P
.fi
.UNINDENT
.SS salt.modules.gentoo_service
.sp
Top level package command wrapper, used to translate the os detected by the
grains to the correct service manager
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.disabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.enabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.get_all()
Return all available boot services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.get_disabled()
Return a set of services that are installed but disabled
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.get_enabled()
Return a list of service that are enabled on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.status(name, sig=None)
Return the status for a service, returns the PID or an empty string if the
service is running or not, pass a signature to use to find the service via
ps
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name> [service signature]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.gentoo_service.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.git
.sp
Support for the Git SCM
.INDENT 0.0
.TP
.B salt.modules.git.add(cwd, file_name, user=None, opts=None)
add a file to git
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B file_name
Path to the file in the cwd
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.add /path/to/git/repo /path/to/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.archive(cwd, output, rev=\(aqHEAD\(aq, fmt=None, prefix=None, user=None)
Export a tarball from the repository
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B output
The path to the archive tarball
.TP
.B rev: HEAD
The revision to create an archive from
.TP
.B fmt: None
Format of the resulting archive, zip and tar are commonly used
.TP
.B prefix
None
Prepend <prefix>/ to every filename in the archive
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
If \fBprefix\fP is not specified it defaults to the basename of the repo
directory.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.archive /path/to/repo /path/to/archive.tar.gz
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.checkout(cwd, rev, force=False, opts=None, user=None)
Checkout a given revision
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B rev
The remote branch or revision to checkout
.TP
.B force
False
Force a checkout even if there might be overwritten changes
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq git.checkout /path/to/repo somebranch user=jeff

salt \(aq*\(aq git.checkout /path/to/repo opts=\(aqtestbranch \-\- conf/file1 file2\(aq

salt \(aq*\(aq git.checkout /path/to/repo rev=origin/mybranch opts=\-\-track
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.clone(cwd, repository, opts=None, user=None, identity=None)
Clone a new repository
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B repository
The git URI of the repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.TP
.B identity
None
A path to a private key to use over SSH
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.clone /path/to/repo git://github.com/saltstack/salt.git

salt \(aq*\(aq git.clone /path/to/repo.git\e
        git://github.com/saltstack/salt.git \(aq\-\-bare \-\-origin github\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.commit(cwd, message, user=None, opts=None)
create a commit
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B message
The commit message
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.commit /path/to/git/repo \(aqThe commit message\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.config_get(cwd, setting_name, user=None)
Get a key from the git configuration file (.git/config) of the repository.
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B setting_name
The name of the configuration key to get
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.config_get /path/to/repo user.email
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.config_set(cwd, setting_name, setting_value, user=None)
Set a key in the git configuration file (.git/config) of the repository.
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B setting_name
The name of the configuration key to set
.TP
.B setting_value
The (new) value to set
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.config_set /path/to/repo user.email me@example.com
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.describe(cwd, rev=\(aqHEAD\(aq, user=None)
Returns the git describe string (or the SHA hash if there are no tags) for
the given revision
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B rev: HEAD
The revision to describe
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq git.describe /path/to/repo

salt \(aq*\(aq git.describe /path/to/repo develop
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.fetch(cwd, opts=None, user=None, identity=None)
Perform a fetch on the given repository
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.TP
.B identity
None
A path to a private key to use over SSH
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.fetch /path/to/repo \(aq\-\-all\(aq

salt \(aq*\(aq git.fetch cwd=/path/to/repo opts=\(aq\-\-all\(aq user=johnny
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.init(cwd, opts=None, user=None)
Initialize a new git repository
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.init /path/to/repo.git opts=\(aq\-\-bare\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.merge(cwd, branch=\(aq@{upstream}\(aq, opts=None, user=None)
Merge a given branch
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B branch
@{upstream}
The remote branch or revision to merge into the current branch
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.fetch /path/to/repo
salt \(aq*\(aq git.merge /path/to/repo @{upstream}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.pull(cwd, opts=None, user=None, identity=None)
Perform a pull on the given repository
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.TP
.B identity
None
A path to a private key to use over SSH
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.pull /path/to/repo opts=\(aq\-\-rebase origin master\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.push(cwd, remote_name, branch=\(aqmaster\(aq, user=None, opts=None, identity=None)
Push to remote
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B remote_name
Name of the remote to push to
.TP
.B branch
master
Name of the branch to push
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.TP
.B identity
None
A path to a private key to use over SSH
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.push /path/to/git/repo remote\-name
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.rebase(cwd, rev=\(aqmaster\(aq, opts=None, user=None)
Rebase the current branch
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B rev
master
The revision to rebase onto the current branch
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.rebase /path/to/repo master
salt \(aq*\(aq git.rebase /path/to/repo \(aqorigin master\(aq
.ft P
.fi
.sp
That is the same as:
.INDENT 7.0
.INDENT 3.5
git rebase master
git rebase origin master
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.remote_get(cwd, remote=\(aqorigin\(aq, user=None)
get the fetch and push URL for a specified remote name
.INDENT 7.0
.TP
.B remote
origin
the remote name used to define the fetch and push URL
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.remote_get /path/to/repo
salt \(aq*\(aq git.remote_get /path/to/repo upstream
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.remote_set(cwd, name=\(aqorigin\(aq, url=None, user=None)
sets a remote with name and URL like git remote add <remote_name> <remote_url>
.INDENT 7.0
.TP
.B remote_name
origin
defines the remote name
.TP
.B remote_url
None
defines the remote URL; should not be None!
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.remote_set /path/to/repo remote_url=git@github.com:saltstack/salt.git
salt \(aq*\(aq git.remote_set /path/to/repo origin git@github.com:saltstack/salt.git
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.remotes(cwd, user=None)
Get remotes like git remote \-v
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.remotes /path/to/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.reset(cwd, opts=None, user=None)
Reset the repository checkout
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.reset /path/to/repo master
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.revision(cwd, rev=\(aqHEAD\(aq, short=False, user=None)
Returns the long hash of a given identifier (hash, branch, tag, HEAD, etc)
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B rev: HEAD
The revision
.TP
.B short: False
Return an abbreviated SHA1 git hash
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.revision /path/to/repo mybranch
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.rm(cwd, file_name, user=None, opts=None)
Remove a file from git
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B file_name
Path to the file in the cwd
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.rm /path/to/git/repo /path/to/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.stash(cwd, opts=None, user=None)
Stash changes in the repository checkout
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.stash /path/to/repo master
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.status(cwd, user=None)
Return the status of the repository. The returned format uses the status
codes of gits \(aqporcelain\(aq output mode
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B user
None
Run git as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.status /path/to/git/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.git.submodule(cwd, init=True, opts=None, user=None, identity=None)
Initialize git submodules
.INDENT 7.0
.TP
.B cwd
The path to the Git repository
.TP
.B init
True
Ensure that new submodules are initialized
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run git as a user other than what the minion runs as
.TP
.B identity
None
A path to a private key to use over SSH
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq git.submodule /path/to/repo.git/sub/repo
.ft P
.fi
.UNINDENT
.SS salt.modules.glance
.sp
Module for handling openstack glance calls.
.INDENT 0.0
.TP
.B optdepends
.INDENT 7.0
.IP \(bu 2
glanceclient Python adapter
.UNINDENT
.TP
.B configuration
This module is not usable until the following are specified
either in a pillar or in the minion\(aqs config file:
.sp
.nf
.ft C
keystone.user: admin
keystone.password: verybadpass
keystone.tenant: admin
keystone.tenant_id: f80919baedab48ec8931f200c65a50df
keystone.insecure: False   #(optional)
keystone.auth_url: \(aqhttp://127.0.0.1:5000/v2.0/\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.glance.image_create(**kwargs)
Create an image (glance image\-create)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq glance.image_create name=f16\-jeos is_public=true                  disk_format=qcow2 container_format=ovf                  copy_from=http://berrange.fedorapeople.org/images/2012\-02\-29/f16\-x86_64\-openstack\-sda.qcow2
.ft P
.fi
.sp
For all possible values, run:
.sp
.nf
.ft C
glance help image\-create
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.glance.image_delete(id=None, name=None)
Delete an image (glance image\-delete)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq glance.image_delete c2eb2eb0\-53e1\-4a80\-b990\-8ec887eae7df
salt \(aq*\(aq glance.image_delete id=c2eb2eb0\-53e1\-4a80\-b990\-8ec887eae7df
salt \(aq*\(aq glance.image_delete name=f16\-jeos
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.glance.image_list(id=None)
Return a list of available images (glance image\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq glance.image_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.glance.image_show(id=None, name=None)
Return details about a specific image (glance image\-show)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq glance.image_get
.ft P
.fi
.UNINDENT
.SS salt.modules.grains
.sp
Control aspects of the grains data
.INDENT 0.0
.TP
.B salt.modules.grains.get(key, default=\(aq\(aq)
Attempt to retrieve the named value from grains, if the named value is not
available return the passed default. The default return is an empty string.
.sp
The value can also represent a value in a nested dict using a ":" delimiter
for the dict. This means that if a dict in grains looks like this:
.sp
{\(aqpkg\(aq: {\(aqapache\(aq: \(aqhttpd\(aq}}
.sp
To retrieve the value associated with the apache key in the pkg dict this
key can be passed:
.sp
pkg:apache
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.get pkg:apache
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.grains.item(*args, **kargs)
Return a single component of the grains data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.item os
.ft P
.fi
.sp
Return multiple components of the grains data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.item os osrelease oscodename
.ft P
.fi
.sp
Sanitized CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.item host sanitize=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.grains.items(sanitize=False)
Return the grains data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.items
.ft P
.fi
.sp
Sanitized CLI output:
.sp
.nf
.ft C
salt \(aq*\(aq grains.items sanitize=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.grains.ls()
Return a list of all available grains
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.ls
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.grains.setval(key, val)
Set a grains value in the grains config file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grains.setval key val
.ft P
.fi
.UNINDENT
.SS salt.modules.groupadd
.sp
Manage groups on Linux and OpenBSD
.INDENT 0.0
.TP
.B salt.modules.groupadd.add(name, gid=None, system=False)
Add the specified group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.add foo 3456
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.groupadd.chgid(name, gid)
Change the gid for a named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.groupadd.delete(name)
Remove the named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.delete foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.groupadd.getent(refresh=False)
Return info on all groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.groupadd.info(name)
Return information about a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.info foo
.ft P
.fi
.UNINDENT
.SS salt.modules.grub_legacy
.sp
Support for GRUB Legacy
.INDENT 0.0
.TP
.B salt.modules.grub_legacy.conf()
Parse GRUB conf file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grub.conf
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.grub_legacy.version()
Return server version from grub \-\-version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq grub.version
.ft P
.fi
.UNINDENT
.SS salt.modules.guestfs
.sp
Interact with virtual machine images via libguestfs
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
libguestfs
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.guestfs.mount(location, access=\(aqrw\(aq)
Mount an image
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aqguest.mount\(aq /srv/images/fedora.qcow
.ft P
.fi
.UNINDENT
.SS salt.modules.hg
.sp
Support for the Mercurial SCM
.INDENT 0.0
.TP
.B salt.modules.hg.archive(cwd, output, rev=\(aqtip\(aq, fmt=None, prefix=None, user=None)
Export a tarball from the repository
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B output
The path to the archive tarball
.TP
.B rev: tip
The revision to create an archive from
.TP
.B fmt: None
Format of the resulting archive. Mercurial supports: tar,
tbz2, tgz, zip, uzip, and files formats.
.TP
.B prefix
None
Prepend <prefix>/ to every filename in the archive
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
If \fBprefix\fP is not specified it defaults to the basename of the repo
directory.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hg.archive /path/to/repo output=/tmp/archive.tgz fmt=tgz
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hg.clone(cwd, repository, opts=None, user=None)
Clone a new repository
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B repository
The hg URI of the repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hg.clone /path/to/repo https://bitbucket.org/birkenfeld/sphinx
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hg.describe(cwd, rev=\(aqtip\(aq, user=None)
Mimick git describe and return an identifier for the given revision
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B rev: tip
The path to the archive tarball
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hg.describe /path/to/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hg.pull(cwd, opts=None, user=None)
Perform a pull on the given repository
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B opts
None
Any additional options to add to the command line
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hg.pull /path/to/repo \(aq\-u\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hg.revision(cwd, rev=\(aqtip\(aq, short=False, user=None)
Returns the long hash of a given identifier (hash, branch, tag, HEAD, etc)
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B rev: tip
The revision
.TP
.B short: False
Return an abbreviated commit hash
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hg.revision /path/to/repo mybranch
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hg.update(cwd, rev, force=False, user=None)
Update to a given revision
.INDENT 7.0
.TP
.B cwd
The path to the Mercurial repository
.TP
.B rev
The revision to update to
.TP
.B force
False
Force an update
.TP
.B user
None
Run hg as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt devserver1 hg.update /path/to/repo somebranch
.ft P
.fi
.UNINDENT
.SS salt.modules.hosts
.sp
Manage the information in the hosts file
.INDENT 0.0
.TP
.B salt.modules.hosts.add_host(ip, alias)
Add a host to an existing entry, if the entry is not in place then create
it with the given host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.add_host <ip> <alias>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.get_alias(ip)
Return the list of aliases associated with an ip
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.get_alias <ip addr>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.get_ip(host)
Return the ip associated with the named host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.get_ip <hostname>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.has_pair(ip, alias)
Return true if the alias is set
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.has_pair <ip> <alias>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.list_hosts()
Return the hosts found in the hosts file in this format:
.sp
.nf
.ft C
{\(aq<ip addr>\(aq: [\(aqalias1\(aq, \(aqalias2\(aq, ...]}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.list_hosts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.rm_host(ip, alias)
Remove a host entry from the hosts file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.rm_host <ip> <alias>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.hosts.set_host(ip, alias)
Set the host entry in the hosts file for the given ip, this will overwrite
any previous entry for the given ip
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq hosts.set_host <ip> <alias>
.ft P
.fi
.UNINDENT
.SS salt.modules.img
.sp
Virtual machine image management tools
.INDENT 0.0
.TP
.B salt.modules.img.bootstrap(location, size, fmt)
HIGHLY EXPERIMENTAL
Bootstrap a virtual machine image
.INDENT 7.0
.TP
.B location:
The location to create the image
.TP
.B size:
The size of the image to create in megabytes
.TP
.B fmt:
The image format, raw or qcow2
.TP
.B CLI Example::
salt \(aq*\(aq qemu_nbd.bootstrap /srv/salt\-images/host.qcow 4096 qcow2
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.img.mnt_image(location)
Mount the named image and return the mount point
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq img.mount_image /tmp/foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.img.mount_image(location)
Mount the named image and return the mount point
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq img.mount_image /tmp/foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.img.seed(location, id_=\(aq\(aq, config=None)
Make sure that the image at the given location is mounted, salt is
installed, keys are seeded, and execute a state run
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq img.seed /tmp/image.qcow2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.img.umount_image(mnt)
Unmount an image mountpoint
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq img.umount_image /mnt/foo
.ft P
.fi
.UNINDENT
.SS salt.modules.iptables
.sp
Support for iptables
.INDENT 0.0
.TP
.B salt.modules.iptables.append(table=\(aqfilter\(aq, chain=None, rule=None)
Append a rule to the specified table/chain.
.INDENT 7.0
.TP
.B This function accepts a rule in a standard iptables command format,
starting with the chain. Trying to force users to adapt to a new
method of creating rules would be irritating at best, and we
already have a parser that can handle it.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.append filter INPUT rule=\(aq\-m state \-\-state RELATED,ESTABLISHED \-j ACCEPT\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.delete(table, chain=None, position=None, rule=None)
.INDENT 7.0
.TP
.B Delete a rule from the specified table/chain, specifying either the rule
in its entirety, or the rule\(aqs position in the chain.
.TP
.B This function accepts a rule in a standard iptables command format,
starting with the chain. Trying to force users to adapt to a new
method of creating rules would be irritating at best, and we
already have a parser that can handle it.
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.delete filter INPUT position=3
salt \(aq*\(aq iptables.delete filter INPUT rule=\(aq\-m state \-\-state RELATED,ESTABLISHED \-j ACCEPT\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.flush(table=\(aqfilter\(aq)
Flush all chains in the specified table.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.flush filter
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.get_policy(table=\(aqfilter\(aq, chain=None)
Return the current policy for the specified table/chain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.get_policy filter INPUT
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.get_rules()
Return a data structure of the current, in\-memory rules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.get_rules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.get_saved_policy(table=\(aqfilter\(aq, chain=None, conf_file=None)
Return the current policy for the specified table/chain
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.get_saved_policy filter INPUT
salt \(aq*\(aq iptables.get_saved_policy filter INPUT conf_file=/etc/iptables.saved
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.get_saved_rules(conf_file=None)
Return a data structure of the rules in the conf file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.get_saved_rules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.insert(table=\(aqfilter\(aq, chain=None, position=None, rule=None)
Insert a rule into the specified table/chain, at the specified position.
.INDENT 7.0
.TP
.B This function accepts a rule in a standard iptables command format,
starting with the chain. Trying to force users to adapt to a new
method of creating rules would be irritating at best, and we
already have a parser that can handle it.
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.insert filter INPUT position=3 rule=\(aq\-m state \-\-state RELATED,ESTABLISHED \-j ACCEPT\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.save(filename=None)
Save the current in\-memory rules to disk
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.save /etc/sysconfig/iptables
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.set_policy(table=\(aqfilter\(aq, chain=None, policy=None)
Set the current policy for the specified table/chain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.set_policy filter INPUT ACCEPT
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.iptables.version()
Return version from iptables \-\-version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq iptables.version
.ft P
.fi
.UNINDENT
.SS salt.modules.keyboard
.sp
Module for managing keyboards on POSIX\-like systems.
.INDENT 0.0
.TP
.B salt.modules.keyboard.get_sys()
Get current system keyboard setting
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keyboard.get_sys
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keyboard.get_x()
Get current X keyboard setting
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keyboard.get_x
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keyboard.set_sys(layout)
Set current system keyboard setting
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keyboard.set_sys dvorak
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keyboard.set_x(layout)
Set current X keyboard setting
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keyboard.set_x dvorak
.ft P
.fi
.UNINDENT
.SS salt.modules.key
.sp
Functions to view the minion\(aqs public key information
.INDENT 0.0
.TP
.B salt.modules.key.finger()
Return the minion\(aqs public key fingerprint
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq key.finger
.ft P
.fi
.UNINDENT
.SS salt.modules.keystone
.sp
Module for handling openstack keystone calls.
.INDENT 0.0
.TP
.B optdepends
.INDENT 7.0
.IP \(bu 2
keystoneclient Python adapter
.UNINDENT
.TP
.B configuration
This module is not usable until the following are specified
either in a pillar or in the minion\(aqs config file:
.sp
.nf
.ft C
keystone.user: admin
keystone.password: verybadpass
keystone.tenant: admin
keystone.tenant_id: f80919baedab48ec8931f200c65a50df
keystone.insecure: False   #(optional)
keystone.auth_url: \(aqhttp://127.0.0.1:5000/v2.0/\(aq

OR (for token based authentication)

keystone.token: \(aqADMIN\(aq
keystone.endpoint: \(aqhttp://127.0.0.1:35357/v2.0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.auth()
Set up keystone credentials
.sp
Only intended to be used within Keystone\-enabled modules
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.ec2_credentials_get(id=None, name=None, access=None)
Return ec2_credentials for a user (keystone ec2\-credentials\-get)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.ec2_credentials_get c965f79c4f864eaaa9c3b41904e67082 access=722787eb540849158668370dc627ec5f
salt \(aq*\(aq keystone.ec2_credentials_get id=c965f79c4f864eaaa9c3b41904e67082 access=722787eb540849158668370dc627ec5f
salt \(aq*\(aq keystone.ec2_credentials_get name=nova access=722787eb540849158668370dc627ec5f
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.ec2_credentials_list(id=None, name=None)
Return a list of ec2_credentials for a specific user (keystone ec2\-credentials\-list)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.ec2_credentials_list 298ce377245c4ec9b70e1c639c89e654
salt \(aq*\(aq keystone.ec2_credentials_list id=298ce377245c4ec9b70e1c639c89e654
salt \(aq*\(aq keystone.ec2_credentials_list name=jack
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.endpoint_get(service)
Return a specific endpoint (keystone endpoint\-get)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.endpoint_get ec2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.endpoint_list()
Return a list of available endpoints (keystone endpoints\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.endpoint_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.role_get(id=None, name=None)
Return a specific roles (keystone role\-get)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.role_get c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.role_get id=c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.role_get name=nova
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.role_list()
Return a list of available roles (keystone role\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.role_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.service_get(id=None, name=None)
Return a specific services (keystone service\-get)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.service_get c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.service_get id=c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.service_get name=nova
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.service_list()
Return a list of available services (keystone services\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.service_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.tenant_get(id=None, name=None)
Return a specific tenants (keystone tenant\-get)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.tenant_get c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.tenant_get id=c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.tenant_get name=nova
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.tenant_list()
Return a list of available tenants (keystone tenants\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.tenant_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.token_get()
Return the configured tokens (keystone token\-get)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.token_get c965f79c4f864eaaa9c3b41904e67082
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_create(name, password, email, tenant_id=None, enabled=True)
Create a user (keystone user\-create)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_create name=jack password=zero email=jack@halloweentown.org tenant_id=a28a7b5a999a455f84b1f5210264375e enabled=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_delete(id=None, name=None)
Delete a user (keystone user\-delete)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_delete c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.user_delete id=c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.user_delete name=nova
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_get(id=None, name=None)
Return a specific users (keystone user\-get)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_get c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.user_get id=c965f79c4f864eaaa9c3b41904e67082
salt \(aq*\(aq keystone.user_get name=nova
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_list()
Return a list of available users (keystone user\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_password_update(id=None, name=None, password=None)
Update a user\(aqs password (keystone user\-password\-update)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_delete c965f79c4f864eaaa9c3b41904e67082 password=12345
salt \(aq*\(aq keystone.user_delete id=c965f79c4f864eaaa9c3b41904e67082 password=12345
salt \(aq*\(aq keystone.user_delete name=nova password=12345
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_role_list(user_id=None, tenant_id=None, user_name=None, tenant_name=None)
Return a list of available user_roles (keystone user_roles\-list)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_role_list             user_id=298ce377245c4ec9b70e1c639c89e654             tenant_id=7167a092ece84bae8cead4bf9d15bb3b
salt \(aq*\(aq keystone.user_role_list user_name=admin tenant_name=admin
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.keystone.user_update(id=None, name=None, email=None, enabled=None)
Update a user\(aqs information (keystone user\-update)
The following fields may be updated: name, email, enabled.
Because the name is one of the fields, a valid user id is required.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq keystone.user_update id=c965f79c4f864eaaa9c3b41904e67082 name=newname
salt \(aq*\(aq keystone.user_update c965f79c4f864eaaa9c3b41904e67082 name=newname email=newemail@domain.com
.ft P
.fi
.UNINDENT
.SS salt.modules.kmod
.sp
Module to manage Linux kernel modules
.INDENT 0.0
.TP
.B salt.modules.kmod.available()
Return a list of all available kernel modules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.available
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.check_available(mod)
Check to see if the specified kernel module is available
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.check_available kvm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.is_loaded(mod)
Check to see if the specified kernel module is loaded
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.is_loaded kvm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.load(mod, persist=False)
Load the specified kernel module
.INDENT 7.0
.TP
.B mod
Name of module to add
.TP
.B persist
Write module to /etc/modules to make it load on system reboot
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.load kvm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.lsmod()
Return a dict containing information about currently loaded modules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.lsmod
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.mod_list(only_persist=False)
Return a list of the loaded module names
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.mod_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.kmod.remove(mod, persist=False, comment=True)
Remove the specified kernel module
.INDENT 7.0
.TP
.B mod
Name of module to remove
.TP
.B persist
Also remove module from /etc/modules
.TP
.B comment
If persist is set don\(aqt remove line from /etc/modules but only
comment it
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq kmod.remove kvm
.ft P
.fi
.UNINDENT
.SS salt.modules.launchctl
.sp
Module for the management of MacOS systems that use launchd/launchctl
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
plistlib Python module
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.available(job_label)
Check that the given service is available.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.available com.openssh.sshd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.get_all()
Return all installed services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.restart(job_label, runas=None)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service label>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.start(job_label, runas=None)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service label>
salt \(aq*\(aq service.start org.ntp.ntpd
salt \(aq*\(aq service.start /System/Library/LaunchDaemons/org.ntp.ntpd.plist
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.status(job_label, runas=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service label>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.launchctl.stop(job_label, runas=None)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service label>
salt \(aq*\(aq service.stop org.ntp.ntpd
salt \(aq*\(aq service.stop /System/Library/LaunchDaemons/org.ntp.ntpd.plist
.ft P
.fi
.UNINDENT
.SS salt.modules.layman
.sp
Support for Layman
.INDENT 0.0
.TP
.B salt.modules.layman.add(overlay)
Add the given overlay from the caced remote list to your locally
installed overlays. Specify \(aqALL\(aq to add all overlays from the
remote list.
.sp
Return a list of the new overlay(s) added:
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq layman.add <overlay name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.layman.delete(overlay)
Remove the given overlay from the your locally installed overlays.
Specify \(aqALL\(aq to remove all overlays.
.sp
Return a list of the overlays(s) that were removed:
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq layman.delete <overlay name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.layman.list_local()
List the locally installed overlays.
.sp
Return a list of installed overlays:
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq layman.list_local
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.layman.sync(overlay=\(aqALL\(aq)
Update the specified overlay. Use \(aqALL\(aq to synchronize all overlays.
This is the default if no overlay is specified.
.INDENT 7.0
.TP
.B overlay
Name of the overlay to sync. (Defaults to \(aqALL\(aq)
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq layman.sync
.ft P
.fi
.UNINDENT
.SS salt.modules.ldapmod
.sp
Module to provide LDAP commands via salt.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
ldap Python module
.UNINDENT
.TP
.B configuration
In order to connect to LDAP, certain configuration is required
in the minion config on the LDAP server. The minimum configuration items
that must be set are:
.sp
.nf
.ft C
ldap.basedn: dc=acme,dc=com (example values, adjust to suit)
.ft P
.fi
.sp
If your LDAP server requires authentication then you must also set:
.sp
.nf
.ft C
ldap.binddn: admin
ldap.bindpw: password
.ft P
.fi
.sp
In addition, the following optional values may be set:
.sp
.nf
.ft C
ldap.server: localhost (default=localhost, see warning below)
ldap.port: 389 (default=389, standard port)
ldap.tls: False (default=False, no TLS)
ldap.scope: 2 (default=2, ldap.SCOPE_SUBTREE)
ldap.attrs: [saltAttr] (default=None, return all attributes)
.ft P
.fi
.UNINDENT
.IP Warning
At the moment this module only recommends connection to LDAP services
listening on \(aqlocalhost\(aq.  This is deliberate to avoid the potentially
dangerous situation of multiple minions sending identical update commands
to the same LDAP server.  It\(aqs easy enough to override this behaviour, but
badness may ensue \- you have been warned.
.RE
.INDENT 0.0
.TP
.B salt.modules.ldapmod.search(filter, dn=None, scope=None, attrs=None, **kwargs)
Run an arbitrary LDAP query and return the results.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aqldaphost\(aq ldap.search "filter=cn=myhost"
.ft P
.fi
.sp
returns:
.sp
.nf
.ft C
\(aqmyhost\(aq: { \(aqcount\(aq: 1,
        \(aqresults\(aq: [[\(aqcn=myhost,ou=hosts,o=acme,c=gb\(aq,
            {\(aqsaltKeyValue\(aq: [\(aqntpserver=ntp.acme.local\(aq, \(aqfoo=myfoo\(aq],
             \(aqsaltState\(aq: [\(aqfoo\(aq, \(aqbar\(aq]}]],
        \(aqtime\(aq: {\(aqhuman\(aq: \(aq1.2ms\(aq, \(aqraw\(aq: \(aq0.00123\(aq}}}
.ft P
.fi
.sp
Search and connection options can be overridden by specifying the relevant
option as key=value pairs, for example:
.sp
.nf
.ft C
salt \(aqldaphost\(aq ldap.search filter=cn=myhost dn=ou=hosts,o=acme,c=gb
scope=1 attrs=\(aq\(aq server=\(aqlocalhost\(aq port=\(aq7393\(aq tls=True bindpw=\(aqssh\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.linux_acl
.sp
Support for Linux File Access Control Lists
.INDENT 0.0
.TP
.B salt.modules.linux_acl.delfacl(acl_type, acl_name, *args)
Remove specific FACL from the specified file(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq acl.delfacl user myuser /tmp/house/kitchen
salt \(aq*\(aq acl.delfacl default:group mygroup /tmp/house/kitchen
salt \(aq*\(aq acl.delfacl d:u myuser /tmp/house/kitchen
salt \(aq*\(aq acl.delfacl g myuser /tmp/house/kitchen /tmp/house/livingroom
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_acl.getfacl(*args)
Return (extremely verbose) map of FACLs on specified file(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq acl.getfacl /tmp/house/kitchen
salt \(aq*\(aq acl.getfacl /tmp/house/kitchen /tmp/house/livingroom
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_acl.modfacl(acl_type, acl_name, perms, *args)
Add or modify a FACL for the specified file(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq acl.addfacl user myuser rwx /tmp/house/kitchen
salt \(aq*\(aq acl.addfacl default:group mygroup rx /tmp/house/kitchen
salt \(aq*\(aq acl.addfacl d:u myuser 7 /tmp/house/kitchen
salt \(aq*\(aq acl.addfacl g mygroup 0 /tmp/house/kitchen /tmp/house/livingroom
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_acl.version()
Return facl version from getfacl \-\-version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq acl.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_acl.wipefacls(*args)
Remove all FACLs from the specified file(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq acl.wipefacls /tmp/house/kitchen
salt \(aq*\(aq acl.wipefacls /tmp/house/kitchen /tmp/house/livingroom
.ft P
.fi
.UNINDENT
.SS salt.modules.linux_lvm
.sp
Support for Linux LVM2
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.fullversion()
Return all version info from lvm version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.fullversion
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.lvcreate(lvname, vgname, size=None, extents=None, pv=\(aq\(aq)
Create a new logical volume, with option for which physical volume to be used
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.lvcreate new_volume_name vg_name size=10G
salt \(aq*\(aq lvm.lvcreate new_volume_name vg_name extents=100 /dev/sdb
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.lvdisplay(lvname=\(aq\(aq)
Return information about the logical volume(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.lvdisplay
salt \(aq*\(aq lvm.lvdisplay /dev/vg_myserver/root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.lvremove(lvname, vgname)
Remove a given existing logical volume from a named existing volume group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.lvremove lvname vgname force=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.pvcreate(devices, **kwargs)
Set a physical device to be used as an LVM physical volume
.sp
CLI Examples:
.sp
.nf
.ft C
salt mymachine lvm.pvcreate /dev/sdb1,/dev/sdb2
salt mymachine lvm.pvcreate /dev/sdb1 dataalignmentoffset=7s
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.pvdisplay(pvname=\(aq\(aq)
Return information about the physical volume(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.pvdisplay
salt \(aq*\(aq lvm.pvdisplay /dev/md0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.version()
Return LVM version from lvm version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.vgcreate(vgname, devices, **kwargs)
Create an LVM volume group
.sp
CLI Examples:
.sp
.nf
.ft C
salt mymachine lvm.vgcreate my_vg /dev/sdb1,/dev/sdb2
salt mymachine lvm.vgcreate my_vg /dev/sdb1 clustered=y
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.vgdisplay(vgname=\(aq\(aq)
Return information about the volume group(s)
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lvm.vgdisplay
salt \(aq*\(aq lvm.vgdisplay nova\-volumes
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_lvm.vgremove(vgname)
Remove an LVM volume group
.sp
CLI Examples:
.sp
.nf
.ft C
salt mymachine lvm.vgremove vgname
salt mymachine lvm.vgremove vgname force=True
.ft P
.fi
.UNINDENT
.SS salt.modules.linux_sysctl
.sp
Module for viewing and modifying sysctl parameters
.INDENT 0.0
.TP
.B salt.modules.linux_sysctl.assign(name, value)
Assign a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.assign net.ipv4.ip_forward 1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_sysctl.get(name)
Return a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.get net.ipv4.ip_forward
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_sysctl.persist(name, value, config=\(aq/etc/sysctl.conf\(aq)
Assign and persist a simple sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.persist net.ipv4.ip_forward 1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.linux_sysctl.show()
Return a list of sysctl parameters for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.show
.ft P
.fi
.UNINDENT
.SS salt.modules.localemod
.sp
Module for managing locales on POSIX\-like systems.
.INDENT 0.0
.TP
.B salt.modules.localemod.get_locale()
Get the current system locale
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locale.get_locale
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.localemod.list_avail()
Lists available (compiled) locales
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locale.list_avail
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.localemod.set_locale(locale)
Sets the current system locale
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locale.set_locale \(aqen_US.UTF\-8\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.locate
.sp
Module for using the locate utilities
.INDENT 0.0
.TP
.B salt.modules.locate.locate(pattern, database=\(aq\(aq, limit=0, **kwargs)
Performs a file lookup. Valid options (and their defaults) are:
.sp
.nf
.ft C
basename=False
count=False
existing=False
follow=True
ignore=False
nofollow=False
wholename=True
regex=False
database=<locate\(aqs default database>
limit=<integer, not set by default>
.ft P
.fi
.sp
See the manpage for locate for further explanation of these options.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locate.locate
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.locate.stats()
Returns statistics about the locate database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locate.stats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.locate.updatedb()
Updates the locate database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locate.updatedb
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.locate.version()
Returns the version of locate
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq locate.version
.ft P
.fi
.UNINDENT
.SS salt.modules.logrotate
.sp
Module for managing logrotate.
.INDENT 0.0
.TP
.B salt.modules.logrotate.set_(key, value, setting=None, conf_file=\(aq/etc/logrotate.conf\(aq)
Set a new value for a specific configuration line
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq logrotate.set rotate 2
.ft P
.fi
.sp
Can also be used to set a single value inside a multiline configuration
block. For instance, to change rotate in the following block:
.sp
.nf
.ft C
/var/log/wtmp {
    monthly
    create 0664 root root
    rotate 1
}
.ft P
.fi
.sp
Use the following command:
.sp
.nf
.ft C
salt \(aq*\(aq logrotate.set /var/log/wtmp rotate 2
.ft P
.fi
.sp
This module also has the ability to scan files inside an include directory,
and make changes in the appropriate file.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.logrotate.show_conf(conf_file=\(aq/etc/logrotate.conf\(aq)
Show parsed configuration
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq logrotate.show_conf
.ft P
.fi
.UNINDENT
.SS salt.modules.makeconf
.sp
Support for modifying make.conf under Gentoo
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_cflags(value)
Add to or create a new CFLAGS in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_cflags \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_cxxflags(value)
Add to or create a new CXXFLAGS in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_cxxflags \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_emerge_default_opts(value)
Add to or create a new EMERGE_DEFAULT_OPTS in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_emerge_default_opts \(aq\e\-\e\-jobs\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_features(value)
Add to or create a new FEATURES in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_features \(aqwebrsync\-gpg\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_gentoo_mirrors(value)
Add to or create a new GENTOO_MIRRORS in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_gentoo_mirrors \(aqhttp://distfiles.gentoo.org\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_makeopts(value)
Add to or create a new MAKEOPTS in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_makeopts \(aq\e\-j3\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.append_var(var, value)
Add to or create a new variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.append_var \(aqLINGUAS\(aq \(aqen\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.cflags_contains(value)
Verify if CFLAGS variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.cflags_contains \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.chost_contains(value)
Verify if CHOST variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.chost_contains \(aqx86_64\-pc\-linux\-gnu\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.cxxflags_contains(value)
Verify if CXXFLAGS variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.cxxflags_contains \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.emerge_default_opts_contains(value)
Verify if EMERGE_DEFAULT_OPTS variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.emerge_default_opts_contains \(aq\e\-\e\-jobs\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.features_contains(value)
Verify if FEATURES variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.features_contains \(aqwebrsync\-gpg\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.gentoo_mirrors_contains(value)
Verify if GENTOO_MIRRORS variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.gentoo_mirrors_contains \(aqhttp://distfiles.gentoo.org\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_cflags()
Get the value of CFLAGS variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_cflags
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_chost()
Get the value of CHOST variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_chost
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_cxxflags()
Get the value of CXXFLAGS variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_cxxflags
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_emerge_default_opts()
Get the value of EMERGE_DEFAULT_OPTS variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_emerge_default_opts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_features()
Get the value of FEATURES variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_features
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_gentoo_mirrors()
Get the value of GENTOO_MIRRORS variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_gentoo_mirrors
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_makeopts()
Get the value of MAKEOPTS variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_makeopts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_sync()
Get the value of SYNC variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_sync
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.get_var(var)
Get the value of a variable in the make.conf
.sp
Return the value of the variable or None if the variable is
not in the make.conf
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.get_var \(aqLINGUAS\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.makeopts_contains(value)
Verify if MAKEOPTS variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.makeopts_contains \(aq\e\-j3\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.remove_var(var)
Remove a variable from the make.conf
.sp
Return a dict containing the new value for the variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.remove_var \(aqLINGUAS\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_cflags(value)
Set the CFLAGS variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_cflags \(aq\e\-march=native \e\-O2 \e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_chost(value)
Set the CHOST variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_chost \(aqx86_64\-pc\-linux\-gnu\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_cxxflags(value)
Set the CXXFLAGS variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_cxxflags \(aq\e\-march=native \e\-O2 \e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_emerge_default_opts(value)
Set the EMERGE_DEFAULT_OPTS variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_emerge_default_opts \(aq\e\-\e\-jobs\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_gentoo_mirrors(value)
Set the GENTOO_MIRRORS variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_gentoo_mirrors \(aqhttp://distfiles.gentoo.org\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_makeopts(value)
Set the MAKEOPTS variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_makeopts \(aq\e\-j3\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_sync(value)
Set the SYNC variable
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_sync \(aqrsync://rsync.namerica.gentoo.org/gentoo\-portage\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.set_var(var, value)
Set a variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.set_var \(aqLINGUAS\(aq \(aqen\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.sync_contains(value)
Verify if SYNC variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.sync_contains \(aqrsync://rsync.namerica.gentoo.org/gentoo\-portage\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_cflags(value)
Remove a value from CFLAGS variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_cflags \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_cxxflags(value)
Remove a value from CXXFLAGS variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_cxxflags \(aq\e\-pipe\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_emerge_default_opts(value)
Remove a value from EMERGE_DEFAULT_OPTS variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_emerge_default_opts \(aq\e\-\e\-jobs\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_features(value)
Remove a value from FEATURES variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_features \(aqwebrsync\-gpg\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_gentoo_mirrors(value)
Remove a value from GENTOO_MIRRORS variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_gentoo_mirrors \(aqhttp://distfiles.gentoo.org\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_makeopts(value)
Remove a value from MAKEOPTS variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_makeopts \(aq\e\-j3\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.trim_var(var, value)
Remove a value from a variable in the make.conf
.sp
Return a dict containing the new value for variable:
.sp
.nf
.ft C
{\(aq<variable>\(aq: {\(aqold\(aq: \(aq<old\-value>\(aq,
                \(aqnew\(aq: \(aq<new\-value>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.trim_var \(aqLINGUAS\(aq \(aqen\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.makeconf.var_contains(var, value)
Verify if variable contains a value in make.conf
.sp
Return True if value is set for var
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq makeconf.var_contains \(aqLINGUAS\(aq \(aqen\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.match
.sp
The match module allows for match routines to be run and determine target
specs.
.INDENT 0.0
.TP
.B salt.modules.match.compound(tgt)
Return True if the minion matches the given compound target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.compound \(aqL@cheese,foo and *\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.data(tgt)
Return True if the minion matches the given data target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.data \(aqspam:eggs\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.glob(tgt)
Return True if the minion matches the given glob target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.glob \(aq*\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.grain(tgt)
Return True if the minion matches the given grain target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.grain \(aqos:Ubuntu\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.grain_pcre(tgt)
Return True if the minion matches the given grain_pcre target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.grain_pcre \(aqos:Fedo.*\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.ipcidr(tgt)
Return True if the minion matches the given ipcidr target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.ipcidr \(aq192.168.44.0/24\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.list_(tgt)
Return True if the minion matches the given list target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.list \(aqserver1,server2\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.pcre(tgt)
Return True if the minion matches the given pcre target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.pcre \(aq.*\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.match.pillar(tgt)
Return True if the minion matches the given pillar target
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq match.pillar \(aqcheese:foo\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.mdadm
.sp
Salt module to manage RAID arrays with mdadm
.INDENT 0.0
.TP
.B salt.modules.mdadm.create(*args)
Create a RAID device.
.sp
WARNING!! Use with CAUTION, as this function can be very destructive if not
used properly!
.sp
Use it just as a regular mdadm command.
.sp
For more info, read \(aqman mdadm\(aq
.sp
NOTE: It takes time to create a RAID array. You can check the progress in
"resync_status:" field of command:
.INDENT 7.0
.INDENT 3.5
salt \(aq*\(aq raid.detail /dev/md0
.UNINDENT
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
Test mode: if you add a test_mode=True as an argument \- it will print out the command to double check.

    salt \(aq*\(aq raid.create /dev/md0 level=1 chunk=256 raid\-devices=2 /dev/xvdd /dev/xvde test_mode=True

NON\-Testing mode:

    salt \(aq*\(aq raid.create /dev/md0 level=1 chunk=256 raid\-devices=2 /dev/xvdd /dev/xvde
.ft P
.fi
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBargs\fP \-\- The arguments u pass to this function.
.IP \(bu 2
\fBarguments\fP \-\- arguments[\(aqnew_array\(aq]: The name of the new RAID array that will be created.
arguments[\(aqopt_val\(aq]: Option with Value. Example: raid\-devices=2
arguments[\(aqopt_raw\(aq]: Option without Value. Example: force
arguments[\(aqdisks_to_array\(aq]: The disks that will be added to the new raid.
.UNINDENT
.TP
.B Returns
.INDENT 7.0
.TP
.B test_mode=True:
Prints out the full command.
.TP
.B test_mode=False (Default):
Executes command on remote the host(s) and
Prints out the mdadm output.
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mdadm.destroy(device)
Destroy a RAID device.
.sp
WARNING This will zero the superblock of all members of the RAID array..
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq raid.destroy /dev/md0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mdadm.detail(device=\(aq/dev/md0\(aq)
Show detail for a specified RAID device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq raid.detail \(aq/dev/md0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mdadm.list_()
List the RAID devices.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq raid.list
.ft P
.fi
.UNINDENT
.SS salt.modules.mine
.sp
The function cache system allows for data to be stored on the master so it
can be easily read by other minions
.INDENT 0.0
.TP
.B salt.modules.mine.get(tgt, fun, expr_form=\(aqglob\(aq)
Get data from the mine based on the target, function and expr_form
.sp
Targets can be matched based on any standard matching system that can be
matched on the master via these keywords:
.INDENT 7.0
.INDENT 3.5
glob
pcre
grain
grain_pcre
pillar
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mine.get \(aq*\(aq network.interfaces
salt \(aq*\(aq mine.get \(aqos:Fedora\(aq network.interfaces grain
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mine.send(func, *args, **kwargs)
Send a specific function to the mine.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mine.send network.interfaces eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mine.update(clear=False)
Execute the configured functions and send the data back up to the master
The functions to be executed are merged from the master config, pillar and
minion config under the option "function_cache":
.sp
.nf
.ft C
mine_functions:
  network.ip_addrs:
    \- eth0
  disk.usage: []
.ft P
.fi
.sp
The function cache will be populated with information from executing these
functions
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mine.update
.ft P
.fi
.UNINDENT
.SS salt.modules.mongodb
.sp
Module to provide MongoDB functionality to Salt
.INDENT 0.0
.TP
.B configuration
This module uses PyMongo, and accepts configuration details as
parameters as well as configuration settings:
.sp
.nf
.ft C
mongodb.host: \(aqlocalhost\(aq
mongodb.port: 27017
mongodb.user: \(aq\(aq
mongodb.password: \(aq\(aq
.ft P
.fi
.sp
This data can also be passed into pillar. Options passed into opts will
overwrite options passed into pillar.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.db_exists(name, user=None, password=None, host=None, port=None)
Checks if a database exists in Mongodb
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.db_exists <name> <user> <password> <host> <port>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.db_list(user=None, password=None, host=None, port=None)
List all Mongodb databases
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.db_list <user> <password> <host> <port>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.db_remove(name, user=None, password=None, host=None, port=None)
Remove a Mongodb database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.db_remove <name> <user> <password> <host> <port>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.user_create(name, passwd, user=None, password=None, host=None, port=None, database=\(aqadmin\(aq)
Create a Mongodb user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.user_create <name> <user> <password> <host> <port> <database>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.user_exists(name, user=None, password=None, host=None, port=None, database=\(aqadmin\(aq)
Checks if a user exists in Mongodb
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.user_exists <name> <user> <password> <host> <port> <database>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.user_list(user=None, password=None, host=None, port=None, database=\(aqadmin\(aq)
List users of a Mongodb database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.user_list <name> <user> <password> <host> <port> <database>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mongodb.user_remove(name, user=None, password=None, host=None, port=None, database=\(aqadmin\(aq)
Remove a Mongodb user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mongodb.user_remove <name> <user> <password> <host> <port> <database>
.ft P
.fi
.UNINDENT
.SS salt.modules.monit
.sp
Monit service module. This module will create a monit type
service watcher.
.INDENT 0.0
.TP
.B salt.modules.monit.monitor(name)
monitor service via monit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.monitor <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.monit.restart(name)
Restart service via monit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.monit.start(name)
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.monit.stop(name)
Stops service via monit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.stop <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.monit.summary(svc_name=\(aq \(aq)
Display a summary from monit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.summary
salt \(aq*\(aq monit.summary <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.monit.unmonitor(name)
Unmonitor service via monit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq monit.unmonitor <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.moosefs
.sp
Module for gathering and managing information about MooseFS
.INDENT 0.0
.TP
.B salt.modules.moosefs.dirinfo(path, opts=None)
Return information on a directory located on the Moose
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq moosefs.dirinfo /path/to/dir/ [\-[n][h|H]]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.moosefs.fileinfo(path)
Return information on a file located on the Moose
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq moosefs.fileinfo /path/to/dir/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.moosefs.getgoal(path, opts=None)
Return goal(s) for a file or directory
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq moosefs.getgoal /path/to/file [\-[n][h|H]]
salt \(aq*\(aq moosefs.getgoal /path/to/dir/ [\-[n][h|H][r]]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.moosefs.mounts()
Return a list of current MooseFS mounts
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq moosefs.mounts
.ft P
.fi
.UNINDENT
.SS salt.modules.mount
.sp
Salt module to manage unix mounts and the fstab file
.INDENT 0.0
.TP
.B salt.modules.mount.active()
List the active mounts.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.active
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.fstab(config=\(aq/etc/fstab\(aq)
List the contents of the fstab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.fstab
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.is_fuse_exec(cmd)
Returns true if the command passed is a fuse mountable application.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.is_fuse_exec sshfs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.mount(name, device, mkmnt=False, fstype=\(aq\(aq, opts=\(aqdefaults\(aq)
Mount a device
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.mount /mnt/foo /dev/sdz1 True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.remount(name, device, mkmnt=False, fstype=\(aq\(aq, opts=\(aqdefaults\(aq)
Attempt to remount a device, if the device is not already mounted, mount
is called
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.remount /mnt/foo /dev/sdz1 True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.rm_fstab(name, config=\(aq/etc/fstab\(aq)
Remove the mount point from the fstab
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.rm_fstab /mnt/foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.set_fstab(name, device, fstype, opts=\(aqdefaults\(aq, dump=0, pass_num=0, config=\(aq/etc/fstab\(aq)
Verify that this mount is represented in the fstab, change the mount
to match the data passed, or add the mount if it is not present.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.set_fstab /mnt/foo /dev/sdz1 ext4
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.swapoff(name)
Deactivate a named swap mount
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.swapoff /root/swapfile
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.swapon(name, priority=None)
Activate a swap disk
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.swapon /root/swapfile
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.swaps()
Return a dict containing information on active swap
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.swaps
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mount.umount(name)
Attempt to unmount a device by specifying the directory it is mounted on
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mount.umount /mnt/foo
.ft P
.fi
.UNINDENT
.SS salt.modules.munin
.sp
Run munin plugins/checks from salt and format the output as data.
.INDENT 0.0
.TP
.B salt.modules.munin.list_plugins()
List all the munin plugins
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq munin.list_plugins
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.munin.run(plugins)
Run one or more named munin plugins
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq munin.run uptime
salt \(aq*\(aq munin.run uptime,cpu,load,memory
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.munin.run_all()
Run all the munin plugins
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq munin.run_all
.ft P
.fi
.UNINDENT
.SS salt.modules.mysql
.sp
Module to provide MySQL compatibility to salt.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
MySQLdb Python module
.UNINDENT
.TP
.B configuration
In order to connect to MySQL, certain configuration is required
in /etc/salt/minion on the relevant minions. Some sample configs might look
like:
.sp
.nf
.ft C
mysql.host: \(aqlocalhost\(aq
mysql.port: 3306
mysql.user: \(aqroot\(aq
mysql.pass: \(aq\(aq
mysql.db: \(aqmysql\(aq
mysql.unix_socket: \(aq/tmp/mysql.sock\(aq
.ft P
.fi
.sp
You can also use a defaults file:
.sp
.nf
.ft C
mysql.default_file: \(aq/etc/mysql/debian.cnf\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_check(name, table=None)
Repairs the full database or just a given table
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_check dbname
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_create(name)
Adds a databases to the MySQL server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_create \(aqdbname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_exists(name)
Checks if a database exists on the MySQL server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_exists \(aqdbname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_list()
Return a list of databases of a MySQL server using the output
from the \fBSHOW DATABASES\fP query.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_optimize(name, table=None)
Optimizes the full database or just a given table
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_optimize dbname
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_remove(name)
Removes a databases from the MySQL server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_remove \(aqdbname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_repair(name, table=None)
Repairs the full database or just a given table
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_repair dbname
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.db_tables(name)
Shows the tables in the given MySQL database (if exists)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.db_tables \(aqdatabase\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.free_slave()
Frees a slave from its master.  This is a WIP, do not use.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.free_slave
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.get_master_status()
Retrieves the master status from the minion.
.INDENT 7.0
.TP
.B Returns:
.INDENT 7.0
.TP
.B {\(aqhost.domain.com\(aq: {\(aqBinlog_Do_DB\(aq: \(aq\(aq,
\(aqBinlog_Ignore_DB\(aq: \(aq\(aq,
\(aqFile\(aq: \(aqmysql\-bin.000021\(aq,
\(aqPosition\(aq: 107}}
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.get_master_status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.get_slave_status()
Retrieves the slave status from the minion.
.sp
Returns:
.sp
.nf
.ft C
{\(aqhost.domain.com\(aq: {\(aqConnect_Retry\(aq: 60,
               \(aqExec_Master_Log_Pos\(aq: 107,
               \(aqLast_Errno\(aq: 0,
               \(aqLast_Error\(aq: \(aq\(aq,
               \(aqLast_IO_Errno\(aq: 0,
               \(aqLast_IO_Error\(aq: \(aq\(aq,
               \(aqLast_SQL_Errno\(aq: 0,
               \(aqLast_SQL_Error\(aq: \(aq\(aq,
               \(aqMaster_Host\(aq: \(aqcomet.scion\-eng.com\(aq,
               \(aqMaster_Log_File\(aq: \(aqmysql\-bin.000021\(aq,
               \(aqMaster_Port\(aq: 3306,
               \(aqMaster_SSL_Allowed\(aq: \(aqNo\(aq,
               \(aqMaster_SSL_CA_File\(aq: \(aq\(aq,
               \(aqMaster_SSL_CA_Path\(aq: \(aq\(aq,
               \(aqMaster_SSL_Cert\(aq: \(aq\(aq,
               \(aqMaster_SSL_Cipher\(aq: \(aq\(aq,
               \(aqMaster_SSL_Key\(aq: \(aq\(aq,
               \(aqMaster_SSL_Verify_Server_Cert\(aq: \(aqNo\(aq,
               \(aqMaster_Server_Id\(aq: 1,
               \(aqMaster_User\(aq: \(aqreplu\(aq,
               \(aqRead_Master_Log_Pos\(aq: 107,
               \(aqRelay_Log_File\(aq: \(aqklo\-relay\-bin.000071\(aq,
               \(aqRelay_Log_Pos\(aq: 253,
               \(aqRelay_Log_Space\(aq: 553,
               \(aqRelay_Master_Log_File\(aq: \(aqmysql\-bin.000021\(aq,
               \(aqReplicate_Do_DB\(aq: \(aq\(aq,
               \(aqReplicate_Do_Table\(aq: \(aq\(aq,
               \(aqReplicate_Ignore_DB\(aq: \(aq\(aq,
               \(aqReplicate_Ignore_Server_Ids\(aq: \(aq\(aq,
               \(aqReplicate_Ignore_Table\(aq: \(aq\(aq,
               \(aqReplicate_Wild_Do_Table\(aq: \(aq\(aq,
               \(aqReplicate_Wild_Ignore_Table\(aq: \(aq\(aq,
               \(aqSeconds_Behind_Master\(aq: 0,
               \(aqSkip_Counter\(aq: 0,
               \(aqSlave_IO_Running\(aq: \(aqYes\(aq,
               \(aqSlave_IO_State\(aq: \(aqWaiting for master to send event\(aq,
               \(aqSlave_SQL_Running\(aq: \(aqYes\(aq,
               \(aqUntil_Condition\(aq: \(aqNone\(aq,
               \(aqUntil_Log_File\(aq: \(aq\(aq,
               \(aqUntil_Log_Pos\(aq: 0}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.get_slave_status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.grant_add(grant, database, user, host=\(aqlocalhost\(aq, grant_option=False, escape=True)
Adds a grant to the MySQL server.
.sp
For database, make sure you specify database.table or database.*
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.grant_add \(aqSELECT,INSERT,UPDATE,...\(aq \(aqdatabase.*\(aq \(aqfrank\(aq \(aqlocalhost\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.grant_exists(grant, database, user, host=\(aqlocalhost\(aq, grant_option=False, escape=True)
Checks to see if a grant exists in the database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.grant_exists \(aqSELECT,INSERT,UPDATE,...\(aq \(aqdatabase.*\(aq \(aqfrank\(aq \(aqlocalhost\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.grant_revoke(grant, database, user, host=\(aqlocalhost\(aq, grant_option=False, escape=True)
Removes a grant from the MySQL server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.grant_revoke \(aqSELECT,INSERT,UPDATE\(aq \(aqdatabase.*\(aq \(aqfrank\(aq \(aqlocalhost\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.processlist()
Retrieves the processlist from the MySQL server via
"SHOW FULL PROCESSLIST".
.INDENT 7.0
.TP
.B Returns: a list of dicts, with each dict representing a process:
.INDENT 7.0
.TP
.B {\(aqCommand\(aq: \(aqQuery\(aq,
\(aqHost\(aq: \(aqlocalhost\(aq,
\(aqId\(aq: 39,
\(aqInfo\(aq: \(aqSHOW FULL PROCESSLIST\(aq,
\(aqRows_examined\(aq: 0,
\(aqRows_read\(aq: 1,
\(aqRows_sent\(aq: 0,
\(aqState\(aq: None,
\(aqTime\(aq: 0,
\(aqUser\(aq: \(aqroot\(aq,
\(aqdb\(aq: \(aqmysql\(aq}
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.processlist
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.query(database, query)
Run an arbitrary SQL query and return the results or
the number of affected rows.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.query mydb "UPDATE mytable set myfield=1 limit 1"
returns: {\(aqquery time\(aq: {\(aqhuman\(aq: \(aq39.0ms\(aq, \(aqraw\(aq: \(aq0.03899\(aq},
\(aqrows affected\(aq: 1L}

salt \(aq*\(aq mysql.query mydb "SELECT id,name,cash from users limit 3"
returns: {\(aqcolumns\(aq: (\(aqid\(aq, \(aqname\(aq, \(aqcash\(aq),
    \(aqquery time\(aq: {\(aqhuman\(aq: \(aq1.0ms\(aq, \(aqraw\(aq: \(aq0.001\(aq},
    \(aqresults\(aq: ((1L, \(aqUser 1\(aq, Decimal(\(aq110.000000\(aq)),
                (2L, \(aqUser 2\(aq, Decimal(\(aq215.636756\(aq)),
                (3L, \(aqUser 3\(aq, Decimal(\(aq0.040000\(aq))),
    \(aqrows returned\(aq: 3L}

salt \(aq*\(aq mysql.query mydb "INSERT into users values (null,\(aquser 4\(aq, 5)"
returns: {\(aqquery time\(aq: {\(aqhuman\(aq: \(aq25.6ms\(aq, \(aqraw\(aq: \(aq0.02563\(aq},
   \(aqrows affected\(aq: 1L}

salt \(aq*\(aq mysql.query mydb "DELETE from users where id = 4 limit 1"
returns: {\(aqquery time\(aq: {\(aqhuman\(aq: \(aq39.0ms\(aq, \(aqraw\(aq: \(aq0.03899\(aq},
    \(aqrows affected\(aq: 1L}
.ft P
.fi
.sp
Jinja Example:
.sp
.nf
.ft C
Run a query on "mydb" and use row 0, column 0\(aqs data.
{{ salt[\(aqmysql.query\(aq]("mydb","SELECT info from mytable limit 1")[\(aqresults\(aq][0][0] }}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.slave_lag()
Return the number of seconds that a slave SQL server is lagging behind the
master, if the host is not a slave it will return \-1.  If the server is
configured to be a slave for replication but slave IO is not running then
\-2 will be returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.slave_lag
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.status()
Return the status of a MySQL server using the output
from the \fBSHOW STATUS\fP query.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_chpass(user, host=\(aqlocalhost\(aq, password=None, password_hash=None)
Change password for MySQL user
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_chpass frank localhost newpassword

salt \(aq*\(aq mysql.user_chpass frank localhost password_hash=\(aqhash\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_create(user, host=\(aqlocalhost\(aq, password=None, password_hash=None)
Creates a MySQL user.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_create \(aqusername\(aq \(aqhostname\(aq \(aqpassword\(aq

salt \(aq*\(aq mysql.user_create \(aqusername\(aq \(aqhostname\(aq password_hash=\(aqhash\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_exists(user, host=\(aqlocalhost\(aq, password=None, password_hash=None)
Checks if a user exists on the  MySQL server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_exists \(aqusername\(aq \(aqhostname\(aq \(aqpassword\(aq

salt \(aq*\(aq mysql.user_exists \(aqusername\(aq \(aqhostname\(aq password_hash=\(aqhash\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_grants(user, host=\(aqlocalhost\(aq)
Shows the grants for the given MySQL user (if it exists)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_grants \(aqfrank\(aq \(aqlocalhost\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_info(user, host=\(aqlocalhost\(aq)
Get full info on a MySQL user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_info root localhost
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_list()
Return a list of users on a MySQL server
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.user_remove(user, host=\(aqlocalhost\(aq)
Delete MySQL user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.user_remove frank localhost
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.mysql.version()
Return the version of a MySQL server using the output
from the \fBSELECT VERSION()\fP query.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq mysql.version
.ft P
.fi
.UNINDENT
.SS salt.modules.netbsdservice
.sp
The service module for NetBSD
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.disabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.enabled(name)
Return True if the named service is enabled, false otherwise
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.force_reload(name)
Force\-reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.force_reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.get_all()
Return all available boot services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.get_disabled()
Return a set of services that are installed but disabled
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.get_enabled()
Return a list of service that are enabled on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.reload_(name, **kwargs)
Reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.status(name, sig=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsdservice.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.netbsd_sysctl
.sp
Module for viewing and modifying sysctl parameters
.INDENT 0.0
.TP
.B salt.modules.netbsd_sysctl.assign(name, value)
Assign a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.assign net.inet.icmp.icmplim 50
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsd_sysctl.get(name)
Return a single sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.get hw.physmem
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsd_sysctl.persist(name, value)
Assign and persist a simple sysctl parameter for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.persist net.inet.icmp.icmplim 50
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.netbsd_sysctl.show()
Return a list of sysctl parameters for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysctl.show
.ft P
.fi
.UNINDENT
.SS salt.modules.network
.sp
Module for gathering and managing network information
.INDENT 0.0
.TP
.B salt.modules.network.arp()
Return the arp table from the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq \(aq*\(aq network.arp
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.dig(host)
Performs a DNS lookup with dig
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.dig archlinux.org
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.hwaddr(iface)
Return the hardware address (a.k.a. MAC address) for a given interface
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.hwaddr eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.in_subnet(cidr)
Returns True if host is within specified subnet, otherwise False.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.in_subnet 10.0.0.0/16
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.interfaces()
Return a dictionary of information about all the interfaces on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.interfaces
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.ip_addrs(interface=None, include_loopback=False)
Returns a list of IPv4 addresses assigned to the host. 127.0.0.1 is
ignored, unless \(aqinclude_loopback=True\(aq is indicated. If \(aqinterface\(aq is
provided, then only IP addresses from that interface will be returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ip_addrs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.ip_addrs6(interface=None, include_loopback=False)
Returns a list of IPv6 addresses assigned to the host. ::1 is ignored,
unless \(aqinclude_loopback=True\(aq is indicated. If \(aqinterface\(aq is provided,
then only IP addresses from that interface will be returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ip_addrs6
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.netstat()
Return information on open ports and states
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.netstat
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.ping(host)
Performs a ping to a host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ping archlinux.org
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.subnets()
Returns a list of subnets to which the host belongs
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.subnets
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.network.traceroute(host)
Performs a traceroute to a 3rd party host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.traceroute archlinux.org
.ft P
.fi
.UNINDENT
.SS salt.modules.nfs3
.sp
Module for managing NFS version 3.
.INDENT 0.0
.TP
.B salt.modules.nfs3.del_export(exports=\(aq/etc/exports\(aq, path=None)
Remove an export
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nfs.del_export /media/storage
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nfs3.list_exports(exports=\(aq/etc/exports\(aq)
List configured exports
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nfs.list_exports
.ft P
.fi
.UNINDENT
.SS salt.modules.nginx
.sp
Support for nginx
.INDENT 0.0
.TP
.B salt.modules.nginx.configtest()
test configuration and exit
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nginx.configtest
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nginx.signal(signal=None)
Signals nginx to start, reload, reopen or stop.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nginx.signal reload
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nginx.version()
Return server version from nginx \-v
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nginx.version
.ft P
.fi
.UNINDENT
.SS salt.modules.nova
.sp
Module for handling openstack nova calls.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
novaclient Python module
.UNINDENT
.TP
.B configuration
This module is not usable until the user, password, tenant, and
auth URL are specified either in a pillar or in the minion\(aqs config file.
For example:
.sp
.nf
.ft C
keystone.user: admin
keystone.password: verybadpass
keystone.tenant: admin
keystone.auth_url: \(aqhttp://127.0.0.1:5000/v2.0/\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.flavor_create(name, id=0, ram=0, disk=0, vcpus=1)
Add a flavor to nova (nova flavor\-create). The following parameters are
required:
.sp
<name>   Name of the new flavor (must be first)
<id>     Unique integer ID for the new flavor
<ram>    Memory size in MB
<disk>   Disk size in GB
<vcpus>  Number of vcpus
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.flavor_create myflavor id=6 ram=4096 disk=10 vcpus=1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.flavor_delete(id)
Delete a flavor from nova by id (nova flavor\-delete)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.flavor_delete 7\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.flavor_list()
Return a list of available flavors (nova flavor\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.flavor_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.image_list(name=None)
Return a list of available images (nova images\-list + nova image\-show)
If a name is provided, only that image will be displayed.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq nova.image_list
salt \(aq*\(aq nova.image_list myimage
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.image_meta_delete(id=None, name=None, keys=None)
Delete a key=value pair from the metadata for an image (nova image\-meta set)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq nova.image_meta_delete id=6f52b2ff\-0b31\-4d84\-8fd1\-af45b84824f6 keys=cheese
salt \(aq*\(aq nova.image_meta_delete name=myimage keys=salad,beans
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.image_meta_set(id=None, name=None, **kwargs)
Sets a key=value pair in the metadata for an image (nova image\-meta set)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq nova.image_meta_set id=6f52b2ff\-0b31\-4d84\-8fd1\-af45b84824f6 cheese=gruyere
salt \(aq*\(aq nova.image_meta_set name=myimage salad=pasta beans=baked
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.keypair_add(name, pubfile=None, pubkey=None)
Add a keypair to nova (nova keypair\-add)
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq nova.keypair_add mykey pubfile=\(aq/home/myuser/.ssh/id_rsa.pub\(aq
salt \(aq*\(aq nova.keypair_add mykey pubkey=\(aqssh\-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAuGj4A7HcPLPl/etc== myuser@mybox\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.keypair_delete(name)
Add a keypair to nova (nova keypair\-delete)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.keypair_delete mykey\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.keypair_list()
Return a list of available keypairs (nova keypair\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.keypair_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.list_()
To maintain the feel of the nova command line, this function simply calls
the server_list function.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.secgroup_create(name, description)
Add a secgroup to nova (nova secgroup\-create)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.secgroup_create mygroup \(aqThis is my security group\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.secgroup_delete(name)
Delete a secgroup to nova (nova secgroup\-delete)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.secgroup_delete mygroup
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.secgroup_list()
Return a list of available security groups (nova items\-list)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.secgroup_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.server_list()
Return detailed information for an active server
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.show
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.server_show(server_id)
Return detailed information for an active server
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nova.show
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nova.show(server_id)
To maintain the feel of the nova command line, this function simply calls
the server_show function.
.UNINDENT
.SS salt.modules.npm
.sp
Manage and query NPM packages.
.INDENT 0.0
.TP
.B salt.modules.npm.install(pkg=None, dir=None, runas=None)
Install an NPM package.
.sp
If no directory is specified, the package will be installed globally. If
no package is specified, the dependencies (from package.json) of the
package in the given directory will be installed.
.INDENT 7.0
.TP
.B pkg
A package name in any format accepted by NPM
.TP
.B dir
The target directory in which to install the package, or None for
global installation
.TP
.B runas
The user to run NPM with
.UNINDENT
.sp
CLI example:
.sp
.nf
.ft C
salt \(aq*\(aq npm.install coffee\-script
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.npm.list_(pkg=None, dir=None)
List installed NPM packages.
.sp
If no directory is specified, this will return the list of globally\-
installed packages.
.INDENT 7.0
.TP
.B pkg
Limit package listing by name
.TP
.B dir
The directory whose packages will be listed, or None for global
installation
.UNINDENT
.sp
CLI example:
.sp
.nf
.ft C
salt \(aq*\(aq npm.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.npm.uninstall(pkg, dir=None, runas=None)
Uninstall an NPM package.
.sp
If no directory is specified, the package will be uninstalled globally.
.INDENT 7.0
.TP
.B pkg
A package name in any format accepted by NPM
.TP
.B dir
The target directory from which to uninstall the package, or None for
global installation
.TP
.B runas
The user to run NPM with
.UNINDENT
.sp
CLI example:
.sp
.nf
.ft C
salt \(aq*\(aq npm.uninstall coffee\-script
.ft P
.fi
.UNINDENT
.SS salt.modules.nzbget
.sp
Support for nzbget
.INDENT 0.0
.TP
.B salt.modules.nzbget.list_(user=None)
Return list of active downloads using nzbget \-L.
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.list larry
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.pause(user=None)
Pause nzbget daemon using \-P option.
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.pause shemp
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.serverversion()
Return server version from nzbget \-V.
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.serverversion moe
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.start(user=None)
Start nzbget as a daemon using \-D option
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.start
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.stop(user=None)
Stop nzbget daemon using \-Q option.
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.stop curly
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.unpause(user=None)
Unpause nzbget daemon using \-U option.
Default user is root.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.unpause shemp
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.nzbget.version()
Return version from nzbget \-v.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq nzbget.version
.ft P
.fi
.UNINDENT
.SS salt.modules.openbsdpkg
.sp
Package support for OpenBSD
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\(aq \(aq<\(aq \(aq0.2.4.1\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.install(name=None, pkgs=None, sources=None, **kwargs)
Install the passed package
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example, Install one package:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name>
.ft P
.fi
.sp
CLI Example, Install more than one package:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install pkgs=\(aq["<package name>", "<package name>"]\(aq
.ft P
.fi
.sp
CLI Example, Install more than one package from a alternate source (e.g. salt file\-server, HTTP, FTP, local filesystem):
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "salt://pkgs/<pkg filename>"}]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.latest_version(*names, **kwargs)
The available version of the package in the repository
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\(aq \(aq0.2.4.1\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\(aq pkg2=\(aq0.2.4.1\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.remove(name=None, pkgs=None, **kwargs)
Remove a single package with pkg_delete
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdpkg.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.openbsdservice
.sp
The service module for OpenBSD
.INDENT 0.0
.TP
.B salt.modules.openbsdservice.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdservice.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdservice.status(name, sig=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.openbsdservice.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.osxdesktop
.sp
Mac OS X implementations of various commands in the "desktop" interface
.INDENT 0.0
.TP
.B salt.modules.osxdesktop.get_output_volume()
Get the output volume (range 0 to 100)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq desktop.get_output_volume
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.osxdesktop.lock()
Lock the desktop session
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq desktop.lock
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.osxdesktop.say(*words)
Say some words.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq desktop.say <word0> <word1> ... <wordN>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.osxdesktop.screensaver()
Launch the screensaver
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq desktop.screensaver
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.osxdesktop.set_output_volume(volume)
Set the volume of sound (range 0 to 100)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq desktop.set_output_volume <volume>
.ft P
.fi
.UNINDENT
.SS salt.modules.pacman
.sp
A module to wrap pacman calls, since Arch is the best
(\fI\%https://wiki.archlinux.org/index.php/Arch_is_the_best\fP)
.INDENT 0.0
.TP
.B salt.modules.pacman.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.file_dict(*packages)
List the files that belong to a package, grouped by package. Not
specifying any packages will return a list of _every_ file on the system\(aqs
package database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs package database (not
generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.install(name=None, refresh=True, pkgs=None, sources=None, **kwargs)
Install the passed package, add refresh=True to install with an \-Sy.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to install packages from a
software repository. To install a package file manually, use the
"sources" option.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to refresh the package database before installing.
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list. A specific version number can be specified
by using a single\-element dict representing the package and its
version. As with the \fBversion\fP parameter above, comparison operators
can be used to target a specific version of a package.
.INDENT 7.0
.TP
.B CLI Examples::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3\-4"}]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "<1.2.3\-4"}]\(aq
.UNINDENT
.TP
.B sources
A list of packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.pkg.tar.xz"},{"bar": "salt://bar.pkg.tar.xz"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.list_upgrades()
List all available package upgrades on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.purge(name=None, pkgs=None, **kwargs)
Recursively remove a package and all dependencies which were installed
with it, this will call a \fBpacman \-Rsc\fP
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.refresh_db()
Just run a \fBpacman \-Sy\fP, return a dict:
.sp
.nf
.ft C
{\(aq<database name>\(aq: Bool}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.remove(name=None, pkgs=None, **kwargs)
Remove packages with \fBpacman \-R\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.upgrade()
Run a full system upgrade, a pacman \-Syu
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pacman.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.pam
.sp
Support for pam
.INDENT 0.0
.TP
.B salt.modules.pam.read_file(file_name)
This is just a test function, to make sure parsing works
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pam.read_file /etc/pam.d/login
.ft P
.fi
.UNINDENT
.SS salt.modules.parted
.sp
Module for managing partitions on POSIX\-like systems.
.sp
Some functions may not be available, depending on your version of parted.
.sp
Check man 8 parted for more information, or the online docs at:
.sp
\fI\%http://www.gnu.org/software/parted/manual/html_chapter/parted_2.html\fP
.sp
In light of parted not directly supporting partition IDs, some of this module
has been written to utilize sfdisk instead. For further information, please
reference the man page for sfdisk:
.sp
.nf
.ft C
man 8 sfdisk
.ft P
.fi
.INDENT 0.0
.TP
.B salt.modules.parted.align_check(device, part_type, partition)
partition.align_check device part_type partition
.sp
Check if partition satisfies the alignment constraint of part_type.
Type must be "minimal" or "optimal".
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.align_check /dev/sda minimal 1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.check(device, minor)
partition.check device minor
.sp
Checks if the file system on partition <minor> has any errors.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.check 1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.cp(device, from_minor, to_minor)
partition.check device from_minor to_minor
.INDENT 7.0
.TP
.B Copies the file system on the partition <from\-minor> to partition
<to\-minor>, deleting the original contents of the destination
partition.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.cp /dev/sda 2 3
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.get_id(device, minor)
partition.get_id
.sp
Prints the system ID for the partition. Some typical values are:
.sp
.nf
.ft C
 b: FAT32 (vfat)
 7: HPFS/NTFS
82: Linux Swap
83: Linux
8e: Linux LVM
fd: Linux RAID Auto
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.get_id /dev/sda 1
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.mkfs(device, fs_type)
partition.mkfs device fs_type
.INDENT 7.0
.TP
.B Makes a file system <fs_type> on partition <device>, destroying all data
that resides on that partition. <fs_type> must be one of "ext2",
"fat32", "fat16", "linux\-swap" or "reiserfs" (if libreiserfs is
installed)
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.mkfs /dev/sda2 fat32
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.mklabel(device, label_type)
partition.mklabel device label_type
.sp
Create a new disklabel (partition table) of label_type.
Type should be one of "aix", "amiga", "bsd", "dvh", "gpt", "loop", "mac",
"msdos", "pc98", or "sun".
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.mklabel /dev/sda msdos
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.mkpart(device, part_type, fs_type, start, end)
partition.mkpart device part_type fs_type start end
.INDENT 7.0
.TP
.B Make a part_type partition for filesystem fs_type, beginning at start and
ending at end (by default in megabytes).  part_type should be one of
"primary", "logical", or "extended".
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.mkpart /dev/sda primary fat32 0 639
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.mkpartfs(device, part_type, fs_type, start, end)
partition.mkpartfs device part_type fs_type start end
.INDENT 7.0
.TP
.B Make a <part_type> partition with a new filesystem of <fs_type>, beginning
at <start> and ending at <end> (by default in megabytes).  <part_type>
should be one of "primary", "logical", or "extended". <fs_type> must be
one of "ext2", "fat32", "fat16", "linux\-swap" or "reiserfs" (if
libreiserfs is installed)
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.mkpartfs /dev/sda logical ext2 440 670
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.name(device, partition, name)
partition.name device partition name
.INDENT 7.0
.TP
.B Set the name of partition to name. This option works only on Mac, PC98,
and GPT disklabels. The name can be placed in quotes, if necessary.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.name /dev/sda 1 \(aqMy Documents\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.part_list(device, unit=None)
partition.part_list device unit
.sp
Prints partition information of given <device>
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq partition.part_list /dev/sda
salt \(aq*\(aq partition.part_list /dev/sda unit=s
salt \(aq*\(aq partition.part_list /dev/sda unit=kB
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.probe(device=\(aq\(aq)
Ask the kernel to update its local partition data
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq partition.probe
salt \(aq*\(aq partition.probe /dev/sda
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.rescue(device, start, end)
partition.rescue device start end
.INDENT 7.0
.TP
.B Rescue a lost partition that was located somewhere between start and end.
If a partition is found, parted will ask if you want to create an
entry for it in the partition table.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.rescue /dev/sda 0 8056
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.resize(device, minor, start, end)
partition.resize device minor, start, end
.INDENT 7.0
.TP
.B Resizes the partition with number <minor>. The partition will start <start>
from the beginning of the disk, and end <end> from the beginning of the
disk. resize never changes the minor number. Extended partitions can be
resized, so long as the new extended partition completely contains all
logical partitions.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.resize /dev/sda 3 200 850
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.rm(device, minor)
partition.rm device minor
.sp
Removes the partition with number <minor>.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.rm /dev/sda 5
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.set_(device, minor, flag, state)
partition.set device  minor flag state
.INDENT 7.0
.TP
.B Changes a flag on the partition with number <minor>. A flag can be either
"on" or "off". Some or all of these flags will be available, depending
on what disk label you are using.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.set /dev/sda 1 boot on
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.set_id(device, minor, system_id)
partition.set_id
.sp
Sets the system ID for the partition. Some typical values are:
.sp
.nf
.ft C
 b: FAT32 (vfat)
 7: HPFS/NTFS
82: Linux Swap
83: Linux
8e: Linux LVM
fd: Linux RAID Auto
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.set_id /dev/sda 1 83
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.parted.toggle(device, partition, flag)
partition.toggle device partition flag
.sp
Toggle the state of <flag> on <partition>
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq partition.name /dev/sda 1 boot
.ft P
.fi
.UNINDENT
.SS salt.modules.pecl
.sp
Manage PHP pecl extensions.
.INDENT 0.0
.TP
.B salt.modules.pecl.install(pecls)
Installs one or several pecl extensions.
.INDENT 7.0
.TP
.B pecls
The pecl extensions to install.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pecl.install fuse
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pecl.list_()
List installed pecl extensions.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pecl.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pecl.uninstall(pecls)
Uninstall one or several pecl extensions.
.INDENT 7.0
.TP
.B pecls
The pecl extensions to uninstall.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pecl.uninstall fuse
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pecl.update(pecls)
Update one or several pecl extensions.
.INDENT 7.0
.TP
.B pecls
The pecl extensions to update.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pecl.update fuse
.ft P
.fi
.UNINDENT
.SS salt.modules.pillar
.sp
Extract the pillar data for this minion
.INDENT 0.0
.TP
.B salt.modules.pillar.data(key=None)
This function calls the master for a fresh pillar and generates the pillar
data on the fly. Unlike pillar.raw which returns the pillar data which
is currently loaded into the minion.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.data
.ft P
.fi
.sp
With the optional key argument, you can select a subtree of the
pillar data.:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.data key=\(aqroles\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pillar.ext(external)
Generate the pillar and apply an explicit external pillar
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.ext \(aqlibvirt: _\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pillar.get(key, default=\(aq\(aq)
New in version 0.14.
.sp
Attempt to retrieve the named value from pillar, if the named value is not
available return the passed default. The default return is an empty string.
.sp
The value can also represent a value in a nested dict using a ":" delimiter
for the dict. This means that if a dict in pillar looks like this:
.sp
{\(aqpkg\(aq: {\(aqapache\(aq: \(aqhttpd\(aq}}
.sp
To retrieve the value associated with the apache key in the pkg dict this
key can be passed:
.sp
pkg:apache
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.get pkg:apache
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pillar.raw(key=None)
Return the raw pillar data that is available in the module. This will
show the pillar as it is loaded as the __pillar__ dict.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.raw
.ft P
.fi
.sp
With the optional key argument, you can select a subtree of the
pillar raw data.:
.sp
.nf
.ft C
salt \(aq*\(aq pillar.raw key=\(aqroles\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.pip
.sp
Install Python packages with pip to either the system or a virtualenv
.INDENT 0.0
.TP
.B salt.modules.pip.freeze(bin_env=None, runas=None, cwd=None)
Return a list of installed packages either globally or in the specified
virtualenv
.INDENT 7.0
.TP
.B bin_env
path to pip bin or path to virtualenv. If doing an uninstall from
the system python and want to use a specific pip bin (pip\-2.7,
pip\-2.6, etc..) just specify the pip bin you want.
If uninstalling from a virtualenv, just use the path to the virtualenv
(/home/code/path/to/virtualenv/)
.TP
.B runas
User to run pip as
.TP
.B cwd
Current working directory to run pip from
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pip.freeze /home/code/path/to/virtualenv/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pip.install(pkgs=None, requirements=None, env=None, bin_env=None, log=None, proxy=None, timeout=None, editable=None, find_links=None, index_url=None, extra_index_url=None, no_index=False, mirrors=None, build=None, target=None, download=None, download_cache=None, source=None, upgrade=False, force_reinstall=False, ignore_installed=False, exists_action=None, no_deps=False, no_install=False, no_download=False, install_options=None, runas=None, no_chown=False, cwd=None, activate=False, __env__=\(aqbase\(aq)
Install packages with pip
.sp
Install packages individually or from a pip requirements file. Install
packages globally or to a virtualenv.
.INDENT 7.0
.TP
.B pkgs
comma separated list of packages to install
.TP
.B requirements
path to requirements
.TP
.B bin_env
path to pip bin or path to virtualenv. If doing a system install,
and want to use a specific pip bin (pip\-2.7, pip\-2.6, etc..) just
specify the pip bin you want.
If installing into a virtualenv, just use the path to the virtualenv
(/home/code/path/to/virtualenv/)
.TP
.B env
deprecated, use bin_env now
.TP
.B log
Log file where a complete (maximum verbosity) record will be kept
.TP
.B proxy
Specify a proxy in the form
user:passwd@proxy.server:port. Note that the
user:password@ is optional and required only if you
are behind an authenticated proxy.  If you provide
user@proxy.server:port then you will be prompted for a
password.
.TP
.B timeout
Set the socket timeout (default 15 seconds)
.TP
.B editable
install something editable (i.e.
git+https://github.com/worldcompany/djangoembed.git#egg=djangoembed)
.TP
.B find_links
URL to look for packages at
.TP
.B index_url
Base URL of Python Package Index
.TP
.B extra_index_url
Extra URLs of package indexes to use in addition to \fBindex_url\fP
.TP
.B no_index
Ignore package index
.TP
.B mirrors
Specific mirror URLs to query (automatically adds \-\-use\-mirrors)
.TP
.B build
Unpack packages into \fBbuild\fP dir
.TP
.B target
Install packages into \fBtarget\fP dir
.TP
.B download
Download packages into \fBdownload\fP instead of installing them
.TP
.B download_cache
Cache downloaded packages in \fBdownload_cache\fP dir
.TP
.B source
Check out \fBeditable\fP packages into \fBsource\fP dir
.TP
.B upgrade
Upgrade all packages to the newest available version
.TP
.B force_reinstall
When upgrading, reinstall all packages even if they are already
up\-to\-date.
.TP
.B ignore_installed
Ignore the installed packages (reinstalling instead)
.TP
.B exists_action
Default action when a path already exists: (s)witch, (i)gnore, (w)wipe, (b)ackup
.TP
.B no_deps
Ignore package dependencies
.TP
.B no_install
Download and unpack all packages, but don\(aqt actually install them
.TP
.B no_download
Don\(aqt download any packages, just install the ones
already downloaded (completes an install run with
\-\-no\-install)
.TP
.B install_options
Extra arguments to be supplied to the setup.py install
command (use like \-\-install\-option="\-\-install\-
scripts=/usr/local/bin").  Use multiple \-\-install\-
option options to pass multiple options to setup.py
install.  If you are using an option with a directory
path, be sure to use absolute path.
.TP
.B runas
User to run pip as
.TP
.B no_chown
When runas is given, do not attempt to copy and chown
a requirements file
.TP
.B cwd
Current working directory to run pip from
.TP
.B activate
Activates the virtual environment, if given via bin_env,
before running install.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pip.install <package name>,<package2 name>

salt \(aq*\(aq pip.install requirements=/path/to/requirements.txt

salt \(aq*\(aq pip.install <package name> bin_env=/path/to/virtualenv

salt \(aq*\(aq pip.install <package name> bin_env=/path/to/pip_bin
.ft P
.fi
.sp
Complicated CLI example:
.sp
.nf
.ft C
salt \(aq*\(aq pip.install markdown,django editable=git+https://github.com/worldcompany/djangoembed.git#egg=djangoembed upgrade=True no_deps=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pip.list_(prefix=\(aq\(aq, bin_env=None, runas=None, cwd=None)
Filter list of installed apps from \fBfreeze\fP and check to see if
\fBprefix\fP exists in the list of packages installed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pip.list salt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pip.uninstall(pkgs=None, requirements=None, bin_env=None, log=None, proxy=None, timeout=None, runas=None, cwd=None, __env__=\(aqbase\(aq)
Uninstall packages with pip
.sp
Uninstall packages individually or from a pip requirements file. Uninstall
packages globally or from a virtualenv.
.INDENT 7.0
.TP
.B pkgs
comma separated list of packages to install
.TP
.B requirements
path to requirements
.TP
.B bin_env
path to pip bin or path to virtualenv. If doing an uninstall from
the system python and want to use a specific pip bin (pip\-2.7,
pip\-2.6, etc..) just specify the pip bin you want.
If uninstalling from a virtualenv, just use the path to the virtualenv
(/home/code/path/to/virtualenv/)
.TP
.B log
Log file where a complete (maximum verbosity) record will be kept
.TP
.B proxy
Specify a proxy in the form
user:passwd@proxy.server:port. Note that the
user:password@ is optional and required only if you
are behind an authenticated proxy.  If you provide
user@proxy.server:port then you will be prompted for a
password.
.TP
.B timeout
Set the socket timeout (default 15 seconds)
.TP
.B runas
User to run pip as
.TP
.B cwd
Current working directory to run pip from
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pip.uninstall <package name>,<package2 name>

salt \(aq*\(aq pip.uninstall requirements=/path/to/requirements.txt

salt \(aq*\(aq pip.uninstall <package name> bin_env=/path/to/virtualenv

salt \(aq*\(aq pip.uninstall <package name> bin_env=/path/to/pip_bin
.ft P
.fi
.UNINDENT
.SS salt.modules.pkgin
.sp
Package support for pkgin based systems, inspired from freebsdpkg.py
.INDENT 0.0
.TP
.B salt.modules.pkgin.available_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.file_dict(package)
List the files that belong to a package.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list nginx
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.file_list(package)
List the files that belong to a package.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list nginx
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.install(name=None, refresh=False, fromrepo=None, pkgs=None, sources=None, **kwargs)
Install the passed package
.INDENT 7.0
.TP
.B name
The name of the package to be installed.
.TP
.B refresh
Whether or not to refresh the package database before installing.
.TP
.B fromrepo
Specify a package repository to install from.
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install pkgs=\(aq["foo","bar"]\(aq
.ft P
.fi
.TP
.B sources
A list of packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.deb"},{"bar": "salt://bar.deb"}]\(aq
.ft P
.fi
.UNINDENT
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.refresh_db()
Use pkg update to get latest pkg_summary
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.rehash()
Recomputes internal hash table for the PATH variable.
Use whenever a new command is created during the current
session.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.rehash
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.remove(name=None, pkgs=None, **kwargs)
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a list containing the removed packages.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.search(pkg_name)
Searches for an exact match using pkgin ^package$
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.search \(aqmysql\-server\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.upgrade()
Run pkg upgrade, if pkgin used. Otherwise do nothing
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgin.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.pkgng
.sp
Support for pkgng
.INDENT 0.0
.TP
.B salt.modules.pkgng.add(pkg_path)
Install a package from either a local source or remote one
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.add /tmp/package.txz
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.audit()
Audits installed packages against known vulnerabilities
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.audit
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.autoremove(dryrun=False)
Delete packages which were automatically installed as dependencies and are
not required anymore.
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.TP
.B dryrun
Dry\-run mode. The list of changes to packages is always printed,
but no changes are actually made.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.autoremove
salt \(aq*\(aq pkgng.autoremove dryrun=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.backup(file_name)
Export installed packages into yaml+mtree file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.backup /tmp/pkg
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.check(depends=False, recompute=False, checksum=False)
Sanity checks installed packages
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.TP
.B depends
Check for and install missing dependencies.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.check recompute=True
.ft P
.fi
.TP
.B recompute
Recompute sizes and checksums of installed packages.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.check depends=True
.ft P
.fi
.TP
.B checksum
Find invalid checksums for installed packages.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.check checksum=True
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.clean()
Cleans the local cache of fetched remote packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.clean
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.delete(pkg_name, all_installed=False, force=False, glob=False, dryrun=False, recurse=False, regex=False, pcre=False)
Delete a package from the database and system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.delete <package name>

all_installed
    Deletes all installed packages from the system and empties the
    database. USE WITH CAUTION!

    CLI Example::

        salt \(aq*\(aq pkgng.delete all all_installed=True force=True

force
    Forces packages to be removed despite leaving unresolved
    dependencies.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <package name> force=True

glob
    Treat the package names as shell glob patterns.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <package name> glob=True

dryrun
    Dry run mode. The list of packages to delete is always printed, but
    no packages are actually deleted.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <package name> dryrun=True

recurse
    Delete all packages that require the listed package as well.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <package name> recurse=True

regex
    Treat the package names as regular expressions.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <regular expression> regex=True

pcre
    Treat the package names as extended regular expressions.

    CLI Example::

        salt \(aq*\(aq pkgng.delete <extended regular expression> pcre=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.fetch(pkg_name, all=False, quiet=False, reponame=None, glob=True, regex=False, pcre=False, local=False, depends=False)
Fetches remote packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.fetch <package name>

all
    Fetch all packages.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> all=True

quiet
    Quiet mode. Show less output.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> quiet=True

reponame
    Fetches packages from the given reponame if multiple repo support
    is enabled. See pkg.conf(5).

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> reponame=repo

glob
    Treat pkg_name as a shell glob pattern.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> glob=True

regex
    Treat pkg_name as a regular expression.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <regular expression> regex=True

pcre
    Treat pkg_name is an extended regular expression.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <extended regular expression> pcre=True

local
    Skip updating the repository catalogues with pkg\-update(8). Use the
    local cache only.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> local=True

depends
    Fetch the package and its dependencies as well.

    CLI Example::

        salt \(aq*\(aq pkgng.fetch <package name> depends=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.info(pkg_name=None)
Returns info on packages installed on system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.info
salt \(aq*\(aq pkgng.info sudo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.install(pkg_name, orphan=False, force=False, glob=False, local=False, dryrun=False, quiet=False, require=False, reponame=None, regex=False, pcre=False)
Install package from repositories
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.install <package name>

orphan
    Mark the installed package as orphan. Will be automatically removed
    if no other packages depend on them. For more information please
    refer to pkg\-autoremove(8).

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> orphan=True

force
    Force the reinstallation of the package if already installed.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> force=True

glob
    Treat the package names as shell glob patterns.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> glob=True

local
    Skip updating the repository catalogues with pkg\-update(8). Use the
    locally cached copies only.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> local=True

dryrun
    Dru\-run mode. The list of changes to packages is always printed,
    but no changes are actually made.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> dryrun=True

quiet
    Force quiet output, except when dryrun is used, where pkg install
    will always show packages to be installed, upgraded or deleted.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> quiet=True

require
    When used with force, reinstalls any packages that require the
    given package.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> require=True force=True

reponame
    In multi\-repo mode, override the pkg.conf ordering and only attempt
    to download packages from the named repository.

    CLI Example::

        salt \(aq*\(aq pkgng.install <package name> reponame=repo

regex
    Treat the package names as a regular expression

    CLI Example::

        salt \(aq*\(aq pkgng.install <regular expression> regex=True

pcre
    Treat the package names as extended regular expressions.

    CLI Example::

        salt \(aq*\(aq pkgng.install <extended regular expression> pcre=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.latest_version(pkg_name, **kwargs)
The available version of the package in the repository
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.latest_version <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.parse_config(file_name=\(aq/usr/local/etc/pkg.conf\(aq)
Return dict of uncommented global variables.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.parse_config
*NOTE* not working right
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.restore(file_name)
Reads archive created by pkg backup \-d and recreates the database.
.INDENT 7.0
.INDENT 3.5
salt \(aq*\(aq pkgng.restore /tmp/pkg
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.search(pkg_name, exact=False, glob=False, regex=False, pcre=False, comment=False, desc=False, full=False, depends=False, size=False, quiet=False, origin=False, prefix=False)
Searches in remote package repositories
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.search pattern

exact
    Treat pattern as exact pattern.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern exact=True

glob
    Treat pattern as a shell glob pattern.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern glob=True

regex
    Treat pattern as a regular expression.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern regex=True

pcre
    Treat pattern as an extended regular expression.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern pcre=True

comment
    Search for pattern in the package comment one\-line description.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern comment=True

desc
    Search for pattern in the package description.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern desc=True

full
    Displays full information about the matching packages.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern full=True

depends
    Displays the dependencies of pattern.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern depends=True

size
    Displays the size of the package

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern size=True

quiet
    Be quiet. Prints only the requested information without displaying
    many hints.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern quiet=True

origin
    Displays pattern origin.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern origin=True

prefix
    Displays the installation prefix for each package matching pattern.

    CLI Example::

        salt \(aq*\(aq pkgng.search pattern prefix=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.stats(local=False, remote=False)
Return pkgng stats.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.stats

local
    Display stats only for the local package database.

    CLI Example::

        salt \(aq*\(aq pkgng.stats local=True

remote
    Display stats only for the remote package database(s).

    CLI Example::

        salt \(aq*\(aq pkgng.stats remote=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.update(force=False)
Refresh PACKAGESITE contents
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.update

force
    Force a full download of the repository catalogue without regard to
    the respective ages of the local and remote copies of the
    catalogue.

    CLI Example::

        salt \(aq*\(aq pkgng.update force=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.update_package_site(new_url)
Updates remote package repo URL, PACKAGESITE var to be exact.
.sp
Must be using \fI\%http://\fP, \fI\%ftp://\fP, or https// protos
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.update_package_site http://127.0.0.1/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.updating(pkg_name, filedate=None, filename=None)
\(aq
Displays UPDATING entries of software packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.updating foo

filedate
    Only entries newer than date are shown. Use a YYYYMMDD date format.

    CLI Example::

        salt \(aq*\(aq pkgng.updating foo filedate=20130101

filename
    Defines an alternative location of the UPDATING file.

    CLI Example::

        salt \(aq*\(aq pkgng.updating foo filename=/tmp/UPDATING
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.upgrade(force=False, local=False, dryrun=False)
Upgrade all packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.upgrade

force
    Force reinstalling/upgrading the whole set of packages.

    CLI Example::

        salt \(aq*\(aq pkgng.upgrade force=True

local
    Skip updating the repository catalogues with pkg\-update(8). Use the
    local cache only.

    CLI Example::

        salt \(aq*\(aq pkgng.update local=True

dryrun
    Dry\-run mode: show what packages have updates available, but do not
    perform any upgrades. Repository catalogues will be updated as
    usual unless the local option is also given.

    CLI Example::

        salt \(aq*\(aq pkgng.update dryrun=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.version()
Displays the current version of pkg
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgng.which(file_name, origin=False, quiet=False)
Displays which package installed a specific file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgng.which <file name>

origin
    Shows the origin of the package instead of name\-version.

    CLI Example::

        salt \(aq*\(aq pkgng.which <file name> origin=True

quiet
    Quiet output.

    CLI Example::

        salt \(aq*\(aq pkgng.which <file name> quiet=True
.ft P
.fi
.UNINDENT
.SS salt.modules.pkg_resource
.sp
Resources needed by pkg providers
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.add_pkg(pkgs, name, version)
Add a package to a dict of installed packages.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.add_pkg \(aq{}\(aq bind 9
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.check_desired(desired=None)
Examines desired package names to make sure they were formatted properly.
Returns a list of problems encountered.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.check_desired
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Package version comparison function.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.compare
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.find_changes(old=None, new=None)
Compare before and after results from pkg.list_pkgs() to determine what
changes were made to the packages installed on the minion.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.find_changes
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.pack_pkgs(pkgs)
Accepts a list of packages or package/version pairs (or a string
representing said list) and returns a dict of name/version pairs. For a
given package, if no version was specified (i.e. the value is a string and
not a dict, then the dict returned will use None as the value for that
package.
.INDENT 7.0
.TP
.B Example: \(aq["foo", {"bar": 1.2}, "baz"]\(aq would become
{\(aqfoo\(aq: None, \(aqbar\(aq: 1.2, \(aqbaz\(aq: None}
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.pack_pkgs \(aq["foo", {"bar": 1.2}, "baz"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.pack_sources(sources)
Accepts list of dicts (or a string representing a list of dicts) and packs
the key/value pairs into a single dict.
.sp
Example: \(aq[{"foo": "salt://foo.rpm"}, {"bar": "salt://bar.rpm"}]\(aq would
become {"foo": "salt://foo.rpm", "bar": "salt://bar.rpm"}
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.pack_sources \(aq[{"foo": "salt://foo.rpm"}, {"bar": "salt://bar.rpm"}]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.parse_targets(name=None, pkgs=None, sources=None, **kwargs)
Parses the input to pkg.install and returns back the package(s) to be
installed. Returns a list of packages, as well as a string noting whether
the packages are to come from a repository or a binary package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.parse_targets
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Compares two version strings using distutils.version.LooseVersion. This is
a fallback for providers which don\(aqt have a version comparison utility
built into them.  Return \-1 if version1 < version2, 0 if version1 ==
version2, and 1 if version1 > version2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.perform_cmp
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.sort_pkglist(pkgs)
Accepts a dict obtained from pkg.list_pkgs() and sorts in place the list of
versions for any packages that have multiple versions installed, so that
two package lists can be compared to one another.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.sort_pkglist \(aq["3.45", "2.13"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.stringify(pkgs)
Takes a dict of package name/version information and joins each list of
installed versions into a string.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.stringify \(aqvim: 7.127\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkg_resource.version(*names, **kwargs)
Common interface for obtaining the version of installed packages.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg_resource.version vim
salt \(aq*\(aq pkg_resource.version foo bar baz
salt \(aq*\(aq pkg_resource.version \(aqpython*\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.pkgutil
.sp
Pkgutil support for Solaris
.INDENT 0.0
.TP
.B salt.modules.pkgutil.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.install(name=None, refresh=False, version=None, pkgs=None, **kwargs)
Install packages using the pkgutil tool.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package_name>
salt \(aq*\(aq pkg.install SMClgcc346
.ft P
.fi
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from OpenCSW. Must be passed as a python
list.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.latest_version CSWpython
salt \(aq*\(aq pkgutil.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
salt \(aq*\(aq pkg.list_pkgs versions_as_list=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.list_upgrades(refresh=True)
List all available package upgrades on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.refresh_db()
Updates the pkgutil repo database (pkgutil \-U)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.remove(name=None, pkgs=None, **kwargs)
Remove a package and all its dependencies which are not in use by other
packages.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.upgrade(refresh=True, **kwargs)
Upgrade all of the packages to the latest available version.
.sp
Returns a dict containing the changes:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.upgrade_available(name)
Check if there is an upgrade available for a certain package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.upgrade_available CSWpython
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pkgutil.version(*names, **kwargs)
Returns a version if the package is installed, else returns an empty string
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkgutil.version CSWpython
.ft P
.fi
.UNINDENT
.SS salt.modules.postgres
.sp
Module to provide Postgres compatibility to salt.
.INDENT 0.0
.TP
.B configuration
In order to connect to Postgres, certain configuration is
required in /etc/salt/minion on the relevant minions. Some sample configs
might look like:
.sp
.nf
.ft C
postgres.host: \(aqlocalhost\(aq
postgres.port: \(aq5432\(aq
postgres.user: \(aqpostgres\(aq
postgres.pass: \(aq\(aq
postgres.maintenance_db: \(aqpostgres\(aq
.ft P
.fi
.sp
The default for the maintenance_db is \(aqpostgres\(aq and in most cases it can
be left at the default setting.
This data can also be passed into pillar. Options passed into opts will
overwrite options passed into pillar
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.db_alter(name, user=None, host=None, port=None, maintenance_db=None, password=None, tablespace=None, owner=None, runas=None)
Change tablesbase or/and owner of databse.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.db_alter dbname owner=otheruser
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.db_create(name, user=None, host=None, port=None, maintenance_db=None, password=None, tablespace=None, encoding=None, lc_collate=None, lc_ctype=None, owner=None, template=None, runas=None)
Adds a databases to the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.db_create \(aqdbname\(aq

salt \(aq*\(aq postgres.db_create \(aqdbname\(aq template=template_postgis
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.db_exists(name, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Checks if a database exists on the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.db_exists \(aqdbname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.db_list(user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Return dictionary with information about databases of a Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.db_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.db_remove(name, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Removes a databases from the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.db_remove \(aqdbname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.group_create(groupname, user=None, host=None, port=None, maintenance_db=None, password=None, createdb=False, createuser=False, encrypted=False, superuser=False, replication=False, rolepassword=None, groups=None, runas=None)
Creates a Postgres group. A group is postgres is similar to a user, but
cannot login.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.group_create \(aqgroupname\(aq user=\(aquser\(aq host=\(aqhostname\(aq port=\(aqport\(aq password=\(aqpassword\(aq rolepassword=\(aqrolepassword\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.group_remove(groupname, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Removes a group from the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.group_remove \(aqgroupname\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.group_update(groupname, user=None, host=None, port=None, maintenance_db=None, password=None, createdb=False, createuser=False, encrypted=False, replication=False, rolepassword=None, groups=None, runas=None)
Updated a postgres group
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.group_update \(aqusername\(aq user=\(aquser\(aq host=\(aqhostname\(aq port=\(aqport\(aq password=\(aqpassword\(aq rolepassword=\(aqrolepassword\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.owner_to(dbname, ownername, user=None, host=None, port=None, password=None, runas=None)
Set the owner of all schemas, functions, tables, views and sequences to
the given username.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.owner_to \(aqdbname\(aq \(aqusername\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.psql_query(query, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Run an SQL\-Query and return the results as a list. This command
only supports SELECT statements.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.psql_query \(aqselect * from pg_stat_activity\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.user_create(username, user=None, host=None, port=None, maintenance_db=None, password=None, createdb=False, createuser=False, encrypted=False, superuser=False, replication=False, rolepassword=None, groups=None, runas=None)
Creates a Postgres user.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.user_create \(aqusername\(aq user=\(aquser\(aq host=\(aqhostname\(aq port=\(aqport\(aq password=\(aqpassword\(aq rolepassword=\(aqrolepassword\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.user_exists(name, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Checks if a user exists on the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.user_exists \(aqusername\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.user_list(user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Return a dict with information about users of a Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.user_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.user_remove(username, user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Removes a user from the Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.user_remove \(aqusername\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.user_update(username, user=None, host=None, port=None, maintenance_db=None, password=None, createdb=False, createuser=False, encrypted=False, replication=False, rolepassword=None, groups=None, runas=None)
Creates a Postgres user.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.user_create \(aqusername\(aq user=\(aquser\(aq host=\(aqhostname\(aq port=\(aqport\(aq password=\(aqpassword\(aq rolepassword=\(aqrolepassword\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.postgres.version(user=None, host=None, port=None, maintenance_db=None, password=None, runas=None)
Return the version of a Postgres server.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq postgres.version
.ft P
.fi
.UNINDENT
.SS salt.modules.poudriere
.sp
Support for poudriere
.INDENT 0.0
.TP
.B salt.modules.poudriere.bulk_build(jail, pkg_file, keep=False)
Run bulk build on poudriere server.
.sp
Return number of pkg builds, failures, and errors, on error dump to CLI
.sp
CLI Example:
.sp
.nf
.ft C
salt \-N buildbox_group poudriere.bulk_build 90amd64 /root/pkg_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.create_jail(name, arch, version=\(aq9.0\-RELEASE\(aq)
Creates a new poudriere jail if one does not exist
.sp
\fINOTE\fP creating a new jail will take some time the master is not hanging
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq poudriere.create_jail 90amd64 amd64
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.create_ports_tree()
Not working need to run portfetch non interactive
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.delete_jail(name)
Deletes poudriere jail with \fIname\fP
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.delete_jail 90amd64
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.is_jail(name)
Return True if jail exists False if not
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.is_jail <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.list_jails()
Return a list of current jails managed by poudriere
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.list_jails
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.list_ports()
Return a list of current port trees managed by poudriere
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.list_ports
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.make_pkgng_aware(jname)
Make jail \fBjname\fP pkgng aware
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.make_pkgng_aware <jail name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.parse_config(config_file=None)
Returns a dict of poudriere main configuration definitions
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.parse_config
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.poudriere.version()
Return poudriere version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq poudriere.version
.ft P
.fi
.UNINDENT
.SS salt.modules.ps
.sp
A salt interface to psutil, a system and process library.
See \fI\%http://code.google.com/p/psutil\fP.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
psutil Python module
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.boot_time()
Return the boot time in number of seconds since the epoch began.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.boot_time
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.cached_physical_memory()
Return the amount cached memory.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.cached_physical_memory
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.cpu_percent(interval=0.1, per_cpu=False)
Return the percent of time the CPU is busy.
.INDENT 7.0
.TP
.B interval
the number of seconds to sample CPU usage over
.TP
.B per_cpu
if True return an array of CPU percent busy for each CPU, otherwise
aggregate all percents into one number
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.cpu_percent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.cpu_times(per_cpu=False)
Return the percent of time the CPU spends in each state,
e.g. user, system, idle, nice, iowait, irq, softirq.
.INDENT 7.0
.TP
.B per_cpu
if True return an array of percents for each CPU, otherwise aggregate
all percents into one number
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.cpu_times
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.disk_io_counters()
Return disk I/O statisitics.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.disk_io_counters
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.disk_partition_usage(all=False)
Return a list of disk partitions plus the mount point, filesystem and usage
statistics.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.disk_partition_usage
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.disk_partitions(all=False)
Return a list of disk partitions and their device, mount point, and
filesystem type.
.INDENT 7.0
.TP
.B all
if set to False, only return local, physical partitions (hard disk,
USB, CD/DVD partitions).  If True, return all filesystems.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.disk_partitions
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.disk_usage(path)
Given a path, return a dict listing the total available space as well as
the free space, and used space.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.disk_usage /home
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.get_pid_list()
Return a list of process ids (PIDs) for all running processes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.get_pid_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.network_io_counters()
Return network I/O statisitics.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.network_io_counters
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.num_cpus()
Return the number of CPUs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.num_cpus
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.physical_memory_buffers()
Return the amount of physical memory buffers.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.physical_memory_buffers
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.physical_memory_usage()
Return a dict that describes free and available physical memory.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq ps.physical_memory_usage
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.top(num_processes=5, interval=3)
Return a list of top CPU consuming processes during the interval.
num_processes = return the top N CPU consuming processes
interval = the number of seconds to sample CPU usage over
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq ps.top

salt \(aq*\(aq ps.top 5 10
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.total_physical_memory()
Return the total number of bytes of physical memory.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.total_physical_memory
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ps.virtual_memory_usage()
Return a dict that describes free and available memory, both physical
and virtual.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ps.virtual_memory_usage
.ft P
.fi
.UNINDENT
.SS salt.modules.publish
.sp
Publish a command from a minion to a target
.INDENT 0.0
.TP
.B salt.modules.publish.full_data(tgt, fun, arg=None, expr_form=\(aqglob\(aq, returner=\(aq\(aq, timeout=5)
Return the full data about the publication, this is invoked in the same
way as the publish function
.sp
CLI Example:
.sp
.nf
.ft C
salt system.example.com publish.full_data \(aq*\(aq cmd.run \(aqls \-la /tmp\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.publish.publish(tgt, fun, arg=None, expr_form=\(aqglob\(aq, returner=\(aq\(aq, timeout=5)
Publish a command from the minion out to other minions, publications need
to be enabled on the Salt master and the minion needs to have permission
to publish the command. The Salt master will also prevent a recursive
publication loop, this means that a minion cannot command another minion
to command another minion as that would create an infinite command loop.
.sp
The expr_form argument is used to pass a target other than a glob into
the execution, the available options are:
glob
pcre
grain
grain_pcre
pillar
ipcidr
range
compound
.sp
The arguments sent to the minion publish function are separated with
commas. This means that for a minion executing a command with multiple
args it will look like this:
.sp
.nf
.ft C
salt system.example.com publish.publish \(aq*\(aq user.add \(aqfoo,1020,1020\(aq
salt system.example.com publish.publish \(aqos:Fedora\(aq network.interfaces \(aq\(aq grain
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt system.example.com publish.publish \(aq*\(aq cmd.run \(aqls \-la /tmp\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.publish.runner(fun, arg=None)
Execute a runner on the master and return the data from the runner
function
.sp
CLI Example:
.sp
.nf
.ft C
salt publish.runner manage.down
.ft P
.fi
.UNINDENT
.SS salt.modules.puppet
.sp
Execute puppet routines
.INDENT 0.0
.TP
.B salt.modules.puppet.fact(name)
Run facter for a specific fact
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq puppet.fact kernel
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.puppet.facts()
Run facter and return the results
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq puppet.facts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.puppet.noop(*args, **kwargs)
Execute a puppet noop run and return a dict with the stderr, stdout,
return code, etc. Usage is the same as for puppet.run.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq puppet.noop

salt \(aq*\(aq puppet.noop tags=basefiles::edit,apache::server

salt \(aq*\(aq puppet.noop debug

salt \(aq*\(aq puppet.noop apply /a/b/manifest.pp modulepath=/a/b/modules tags=basefiles::edit,apache::server
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.puppet.run(*args, **kwargs)
Execute a puppet run and return a dict with the stderr, stdout,
return code, etc. The first positional argument given is checked as a
subcommand. Following positional arguments should be ordered with arguments
required by the subcommand first, followed by non\-keyvalue pair options.
Tags are specified by a tag keyword and comma separated list of values. \-\-
\fI\%http://projects.puppetlabs.com/projects/1/wiki/Using_Tags\fP
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq puppet.run

salt \(aq*\(aq puppet.run tags=basefiles::edit,apache::server

salt \(aq*\(aq puppet.run debug

salt \(aq*\(aq puppet.run apply /a/b/manifest.pp modulepath=/a/b/modules tags=basefiles::edit,apache::server
.ft P
.fi
.UNINDENT
.SS salt.modules.pw_group
.sp
Manage groups on FreeBSD
.INDENT 0.0
.TP
.B salt.modules.pw_group.add(name, gid=None, system=False)
Add the specified group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.add foo 3456
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_group.chgid(name, gid)
Change the gid for a named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_group.delete(name)
Remove the named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.delete foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_group.getent(refresh=False)
Return info on all groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_group.info(name)
Return information about a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.info foo
.ft P
.fi
.UNINDENT
.SS salt.modules.pw_user
.sp
Manage users with the useradd command
.INDENT 0.0
.TP
.B salt.modules.pw_user.add(name, uid=None, gid=None, groups=None, home=True, shell=None, unique=True, system=False, fullname=\(aq\(aq, roomnumber=\(aq\(aq, workphone=\(aq\(aq, homephone=\(aq\(aq, **kwargs)
Add a user to the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.add name <uid> <gid> <groups> <home> <shell>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chfullname(name, fullname)
Change the user\(aqs Full Name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chfullname foo "Foo Bar"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chgid(name, gid)
Change the default group of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chgroups(name, groups, append=False)
Change the groups this user belongs to, add append to append the specified
groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgroups foo wheel,root True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chhome(name, home, persist=False)
Change the home directory of the user, pass true for persist to copy files
to the new home dir
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhome foo /home/users/foo True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chhomephone(name, homephone)
Change the user\(aqs Home Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhomephone foo "7735551234"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chroomnumber(name, roomnumber)
Change the user\(aqs Room Number
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chroomnumber foo 123
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chshell(name, shell)
Change the default shell of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chshell foo /bin/zsh
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chuid(name, uid)
Change the uid for a named user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chuid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.chworkphone(name, workphone)
Change the user\(aqs Work Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chworkphone foo "7735550123"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.delete(name, remove=False, force=False)
Remove a user from the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.delete name remove=True force=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.getent()
Return the list of all info for all users
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.info(name)
Return user information
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.pw_user.list_groups(name)
Return a list of groups the named user belongs to
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.list_groups foo
.ft P
.fi
.UNINDENT
.SS salt.modules.qemu_img
.SS Qemu\-img Command Wrapper
.sp
The qemu img command is wrapped for specific functions
.INDENT 0.0
.TP
.B depends
qemu\-img
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.qemu_img.make_image(location, size, fmt)
Create a blank virtual machine image file of the specified size in
megabytes. The image can be created in any format supported by qemu
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu_img.make_image /tmp/image.qcow 2048 qcow2
salt \(aq*\(aq qemu_img.make_image /tmp/image.raw 10240 raw
.ft P
.fi
.UNINDENT
.SS salt.modules.qemu_nbd
.SS Qemu Command Wrapper
.sp
The qemu system comes with powerful tools, such as qemu\-img and qemu\-nbd which
are used here to build up kvm images.
.INDENT 0.0
.TP
.B salt.modules.qemu_nbd.clear(mnt)
Pass in the mnt dict returned from nbd_mount to unmount and disconnect
the image from nbd. If all of the partitions are unmounted return an
empty dict, otherwise return a dict containing the still mounted
partitions
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu_nbd.clear \(aq{/mnt/foo: /dev/nbd0p1}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.qemu_nbd.connect(image)
Activate nbd for an image file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu_nbd.connect /tmp/image.raw
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.qemu_nbd.init(image)
Mount the named image via qemu\-nbd and return the mounted roots
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu_nbd.init /srv/image.qcow2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.qemu_nbd.mount(nbd)
Pass in the nbd connection device location, mount all partitions and return
a dict of mount points
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq qemu_nbd.mount /dev/nbd0
.ft P
.fi
.UNINDENT
.SS salt.modules.quota
.sp
Module for managing quotas on POSIX\-like systems.
.INDENT 0.0
.TP
.B salt.modules.quota.get_mode(device)
Report whether the quota system for this device is on or off
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.get_mode
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.off(device)
Turns off the quota system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.off
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.on(device)
Turns on the quota system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.on
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.report(mount)
Report on quotas for a specific volume
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.report /media/data
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.set_(device, **kwargs)
Calls out to setquota, for a specific user or group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.set /media/data user=larry block\-soft\-limit=1048576
salt \(aq*\(aq quota.set /media/data group=painters file\-hard\-limit=1000
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.stats()
Runs the quotastats command, and returns the parsed output
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.stats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.quota.warn()
Runs the warnquota command, to send warning emails to users who
are over their quota limit.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq quota.warn
.ft P
.fi
.UNINDENT
.SS salt.modules.rabbitmq
.sp
Module to provide RabbitMQ compatibility to Salt.
Todo: A lot, need to add cluster support, logging, and minion configuration
data.
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.add_user(name, password, runas=None)
Add a rabbitMQ user via rabbitmqctl user_add <user> <password>
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.add_user rabbit_user password
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.add_vhost(vhost, runas=None)
Adds a vhost via rabbitmqctl add_vhost.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq add_vhost \(aq<vhost_name>\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.change_password(name, password, runas=None)
Changes a user\(aqs password.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.change_password rabbit_user password
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.clear_password(name, runas=None)
Removes a user\(aqs password.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.clear_password rabbit_user
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.delete_user(name, runas=None)
Deletes a user via rabbitmqctl delete_user.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.delete_user rabbit_user
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.delete_vhost(vhost, runas=None)
Deletes a vhost rabbitmqctl delete_vhost.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.delete_vhost \(aq<vhost_name>\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.list_user_permissions(name, user=None)
List permissions for a user via rabbitmqctl list_user_permissions
.sp
Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.list_user_permissions \(aquser\(aq.
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.list_users(runas=None)
Return a list of users based off of rabbitmqctl user_list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.list_users
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.list_vhosts(runas=None)
Return a list of vhost based on rabbitmqctl list_vhosts.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.list_vhosts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.set_permissions(vhost, user, conf=\(aq.*\(aq, write=\(aq.*\(aq, read=\(aq.*\(aq, runas=None)
Sets permissions for vhost via rabbitmqctl set_permissions
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.set_permissions \(aqmyvhost\(aq \(aqmyuser\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.user_exists(name, runas=None)
Return whether the user exists based on rabbitmqctl list_users.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.user_exists rabbit_user
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rabbitmq.vhost_exists(name, runas=None)
Return whether the vhost exists based on rabbitmqctl list_vhosts.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rabbitmq.vhost_exists rabbit_host
.ft P
.fi
.UNINDENT
.SS salt.modules.rbenv
.sp
Manage ruby installations with rbenv.
.INDENT 0.0
.TP
.B salt.modules.rbenv.default(ruby=None, runas=None)
Returns or sets the currently defined default ruby.
.INDENT 7.0
.TP
.B ruby=None
The version to set as the default. Should match one of
the versions listed by rbenv.versions.
Leave blank to return the current default.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.default
# 2.0.0\-p0

salt \(aq*\(aq rbenv.default 2.0.0\-p0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.install(runas=None, path=None)
Install Rbenv systemwide
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.install
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.install_ruby(ruby, runas=None)
Install a ruby implementation.
.INDENT 7.0
.TP
.B ruby
The version of Ruby to install, should match one of the
versions listed by rbenv.list
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.install_ruby 2.0.0\-p0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.is_installed(runas=None)
Check if Rbenv is installed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.is_installed
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.list_(runas=None)
List the installable versions of ruby.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.uninstall_ruby(ruby, runas=None)
Uninstall a ruby implementation.
.INDENT 7.0
.TP
.B ruby
The version of ruby to uninstall. Should match one of
the versions listed by rbenv.versions
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.uninstall_ruby 2.0.0\-p0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.update(runas=None, path=None)
Updates the current versions of Rbenv and Ruby\-Build
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.update
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rbenv.versions(runas=None)
List the installed versions of ruby.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rbenv.versions
.ft P
.fi
.UNINDENT
.SS salt.modules.reg
.sp
Manage the registry on Windows
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
winreg Python module
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class salt.modules.reg.Registry
Delay \(aq_winreg\(aq usage until this module is used
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.reg.create_key(hkey, path, key, value=None)
Create a registry key
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq reg.create_key HKEY_CURRENT_USER \(aqSOFTWARE\eSalt\(aq \(aqversion\(aq \(aq0.97\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.reg.delete_key(hkey, path, key)
Delete a registry key
.sp
Note: This cannot delete a key with subkeys
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq reg.delete_key HKEY_CURRENT_USER \(aqSOFTWARE\eSalt\(aq \(aqversion\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.reg.read_key(hkey, path, key)
Read registry key value
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq reg.read_key HKEY_LOCAL_MACHINE \(aqSOFTWARE\eSalt\(aq \(aqversion\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.reg.set_key(hkey, path, key, value)
Set a registry key
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq reg.set_key HKEY_CURRENT_USER \(aqSOFTWARE\eSalt\(aq \(aqversion\(aq \(aq0.97\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.ret
.sp
Module to integrate with the returner system and retrieve data sent to a salt
returner.
.INDENT 0.0
.TP
.B salt.modules.ret.get_fun(returner, fun)
Return info about last time fun was called on each minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ret.get_fun mysql network.interfaces
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ret.get_jid(returner, jid)
Return the information for a specified job id
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ret.get_jid redis 20421104181954700505
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ret.get_jids(returner)
Return a list of all job ids
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ret.get_jids mysql
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ret.get_minions(returner)
Return a list of all minions
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ret.get_minions mysql
.ft P
.fi
.UNINDENT
.SS salt.modules.rh_ip
.sp
The networking module for RHEL/Fedora based distros
.INDENT 0.0
.TP
.B salt.modules.rh_ip.apply_network_settings(**settings)
Apply global network configuration.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.apply_network_settings
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.build_bond(iface, **settings)
Create a bond script in /etc/modprobe.d with the passed settings
and load the bonding kernel module.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.build_bond bond0 mode=balance\-alb
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.build_interface(iface, iface_type, enabled, **settings)
Build an interface script for a network interface.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.build_interface eth0 eth <settings>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.build_network_settings(**settings)
Build the global network script.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.build_network_settings <settings>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.build_routes(iface, **settings)
Build an route script for a network interface.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.build_routes eth0 <settings>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.down(iface, iface_type)
Shutdown a network interface
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.down eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.get_bond(iface)
Return the content of a bond script
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.get_bond bond0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.get_interface(iface)
Return the contents of an interface script
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.get_interface eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.get_network_settings()
Return the contents of the global network script.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.get_network_settings
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.get_routes(iface)
Return the contents of the interface routes script.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.get_routes eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_ip.up(iface, iface_type)
Start up a network interface
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ip.up eth0
.ft P
.fi
.UNINDENT
.SS salt.modules.rh_service
.sp
Service support for RHEL\-based systems. This interface uses the service and
chkconfig commands, and for upstart support uses helper functions from the
upstart module, as well as the \fBstart\fP, \fBstop\fP, and \fBstatus\fP commands.
.INDENT 0.0
.TP
.B salt.modules.rh_service.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.disabled(name)
Check to see if the named service is disabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.enabled(name)
Check to see if the named service is enabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.get_all(limit=\(aq\(aq)
Return all installed services. Use the \fBlimit\fP param to restrict results
to services of that type.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
salt \(aq*\(aq service.get_all limit=upstart
salt \(aq*\(aq service.get_all limit=sysvinit
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.get_disabled(limit=\(aq\(aq)
Return the disabled services. Use the \fBlimit\fP param to restrict results
to services of that type.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
salt \(aq*\(aq service.get_disabled limit=upstart
salt \(aq*\(aq service.get_disabled limit=sysvinit
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.get_enabled(limit=\(aq\(aq)
Return the enabled services. Use the \fBlimit\fP param to restrict results
to services of that type.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
salt \(aq*\(aq service.get_enabled limit=upstart
salt \(aq*\(aq service.get_enabled limit=sysvinit
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.reload_(name, **kwargs)
Reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.status(name, sig=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rh_service.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.rpm
.sp
Support for rpm
.INDENT 0.0
.TP
.B salt.modules.rpm.file_dict(*packages)
List the files that belong to a package, sorted by group. Not specifying
any packages will return a list of _every_ file on the system\(aqs rpm
database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.file_list httpd
salt \(aq*\(aq lowpkg.file_list httpd postfix
salt \(aq*\(aq lowpkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rpm.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs rpm database (not generally
recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.file_list httpd
salt \(aq*\(aq lowpkg.file_list httpd postfix
salt \(aq*\(aq lowpkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rpm.list_pkgs(*packages)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rpm.verify(*package)
Runs an rpm \-Va on a system, and returns the results in a dict
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq lowpkg.verify
.ft P
.fi
.UNINDENT
.SS salt.modules.rvm
.sp
Manage ruby installations and gemsets with RVM, the Ruby Version Manager.
.INDENT 0.0
.TP
.B salt.modules.rvm.do(ruby, command, runas=None)
Execute a command in an RVM controlled environment.
.INDENT 7.0
.TP
.B ruby:
The ruby to use.
.TP
.B command:
The command to execute.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.do 2.0.0 <command>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_copy(source, destination, runas=None)
Copy all gems from one gemset to another.
.INDENT 7.0
.TP
.B source
The name of the gemset to copy, complete with ruby version.
.TP
.B destination
The destination gemset.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_copy foobar bazquo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_create(ruby, gemset, runas=None)
Creates a gemset.
.INDENT 7.0
.TP
.B ruby
The ruby version to create the gemset for.
.TP
.B gemset
The name of the gemset to create.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_create 2.0.0 foobar
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_delete(ruby, gemset, runas=None)
Deletes a gemset.
.INDENT 7.0
.TP
.B ruby
The ruby version the gemset belongs to.
.TP
.B gemset
The gemset to delete.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_delete 2.0.0 foobar
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_empty(ruby, gemset, runas=None)
Remove all gems from a gemset.
.INDENT 7.0
.TP
.B ruby
The ruby version the gemset belongs to.
.TP
.B gemset
The gemset to empty.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_empty 2.0.0 foobar
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_list(ruby=\(aqdefault\(aq, runas=None)
List all gemsets for the given ruby.
.INDENT 7.0
.TP
.B ruby
default
The ruby version to list the gemsets for
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.gemset_list_all(runas=None)
List all gemsets for all installed rubies.
.sp
Note that you must have set a default ruby before this can work.
.INDENT 7.0
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.gemset_list_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.get(version=\(aqstable\(aq, runas=None)
Update RVM.
.INDENT 7.0
.TP
.B version
stable
Which version of RVM to install, e.g. stable or head.
.TP
.B ruby
The version of ruby to reinstall.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.get
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.install(runas=None)
Install RVM system wide.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.install
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.install_ruby(ruby, runas=None)
Install a ruby implementation.
.INDENT 7.0
.TP
.B ruby
The version of ruby to install.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.install_ruby 1.9.3\-p385
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.is_installed(runas=None)
Check if RVM is installed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.is_installed
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.list_(runas=None)
List all rvm installed rubies.
.INDENT 7.0
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.reinstall_ruby(ruby, runas=None)
Reinstall a ruby implementation.
.INDENT 7.0
.TP
.B ruby
The version of ruby to reinstall.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.reinstall_ruby 1.9.3\-p385
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.rubygems(ruby, version, runas=None)
Installs a specific rubygems version in the given ruby.
.INDENT 7.0
.TP
.B ruby
The ruby to install rubygems for.
.TP
.B version
The version of rubygems to install or \(aqremove\(aq to use the version that ships with 1.9
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.rubygems 2.0.0 1.8.24
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.set_default(ruby, runas=None)
Set the default ruby.
.INDENT 7.0
.TP
.B ruby
The version of ruby to make the default.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.set_default 2.0.0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.rvm.wrapper(ruby_string, wrapper_prefix, runas=None, *binaries)
Install RVM wrapper scripts.
.INDENT 7.0
.TP
.B ruby_string
Ruby/gemset to install wrappers for.
.TP
.B wrapper_prefix
What to prepend to the name of the generated wrapper binaries.
.TP
.B runas
None
The user to run rvm as.
.TP
.B binaries
None
The names of the binaries to create wrappers for. When nothing is given, wrappers for ruby, gem, rake, irb, rdoc, ri and testrb are generated.
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq rvm.wrapper <ruby_string> <wrapper_prefix>
.ft P
.fi
.UNINDENT
.SS salt.modules.s3
.sp
Connection module for Amazon S3
.INDENT 0.0
.TP
.B configuration
This module is not usable until the following are specified
either in a pillar or in the minion\(aqs config file:
.sp
.nf
.ft C
s3.keyid: GKTADJGHEIQSXMKKRBJ08H
s3.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
.ft P
.fi
.sp
A service_url may also be specified in the configuration:
.sp
.nf
.ft C
s3.service_url: s3.amazonaws.com
.ft P
.fi
.sp
If a service_url is not specified, the default is s3.amazonaws.com. This
may appear in various documentation as an "endpoint". A comprehensive list
for Amazon S3 may be found at:
.sp
.nf
.ft C
http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region
.ft P
.fi
.sp
The service_url will form the basis for the final endpoint that is used to
query the service.
.sp
This module should be usable to query other S3\-like services, such as
Eucalyptus.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.s3.delete(bucket, path=None, action=None, key=None, keyid=None, service_url=None)
Delete a bucket, or delete an object from a bucket.
.sp
CLI Example to delete a bucket:
.sp
.nf
.ft C
salt myminion s3.delete mybucket
.ft P
.fi
.sp
CLI Example to delete an object from a bucket:
.sp
.nf
.ft C
salt myminion s3.delete mybucket remoteobject
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.s3.get(bucket=None, path=None, return_bin=False, action=None, local_file=None, key=None, keyid=None, service_url=None)
List the contents of a bucket, or return an object from a bucket. Set
return_bin to True in order to retrieve an object wholesale. Otherwise,
Salt will attempt to parse an XML response.
.sp
CLI Example to list buckets:
.sp
.nf
.ft C
salt myminion s3.get
.ft P
.fi
.sp
CLI Example to list the contents of a bucket:
.sp
.nf
.ft C
salt myminion s3.get mybucket
.ft P
.fi
.sp
CLI Example to return the binary contents of an object:
.sp
.nf
.ft C
salt myminion s3.get mybucket myfile.png return_bin=True
.ft P
.fi
.sp
CLI Example to save the binary contents of an object to a local file:
.sp
.nf
.ft C
salt myminion s3.get mybucket myfile.png local_file=/tmp/myfile.png
.ft P
.fi
.sp
It is also possible to perform an action on a bucket. Currently, S3
supports the following actions:
.sp
.nf
.ft C
acl
cors
lifecycle
policy
location
logging
notification
tagging
versions
requestPayment
versioning
website
.ft P
.fi
.sp
To perform an action on a bucket:
.sp
.nf
.ft C
salt myminion s3.get mybucket myfile.png action=acl
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.s3.head(bucket, path=None, key=None, keyid=None, service_url=None)
Return the metadata for a bucket, or an object in a bucket.
.sp
CLI Examples:
.sp
.nf
.ft C
salt myminion s3.head mybucket
salt myminion s3.head mybucket myfile.png
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.s3.put(bucket, path=None, return_bin=False, action=None, local_file=None, key=None, keyid=None, service_url=None)
Create a new bucket, or upload an object to a bucket.
.sp
CLI Example to create a bucket:
.sp
.nf
.ft C
salt myminion s3.put mybucket
.ft P
.fi
.sp
CLI Example to upload an object to a bucket:
.sp
.nf
.ft C
salt myminion s3.put mybucket remotepath local_path=/path/to/file
.ft P
.fi
.UNINDENT
.SS salt.modules.saltutil
.sp
The Saltutil module is used to manage the state of the salt minion itself. It
is used to manage minion modules as well as automate updates to the salt minion
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
esky Python module for update functionality
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.find_job(jid)
Return the data for a specific job id
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.find_job <job id>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.is_running(fun)
If the named function is running return the data associated with it/them.
The argument can be a glob
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.is_running state.highstate
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.kill_job(jid)
Sends a kill signal (SIGKILL 9) to the named salt job\(aqs process
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.kill_job <job id>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.refresh_modules()
Signal the minion to refresh the module and grain data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.refresh_modules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.refresh_pillar()
Signal the minion to refresh the pillar data.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.refresh_pillar
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.regen_keys()
Used to regenerate the minion keys.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.regen_keys
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.revoke_auth()
The minion sends a request to the master to revoke its own key, note that
the minion session will be revoked and the minion may not be able to return
the result o this command back to the master.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.revoke_key
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.running()
Return the data on all running salt processes on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.running
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.signal_job(jid, sig)
Sends a signal to the named salt job\(aqs process
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.signal_job <job id> 15
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_all(env=None, refresh=True)
Sync down all of the dynamic modules from the file server for a specific
environment
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_grains(env=None, refresh=True)
Sync the grains from the _grains directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _grains directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_grains
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_modules(env=None, refresh=True)
Sync the modules from the _modules directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _modules directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_modules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_outputters(env=None, refresh=True)
Sync the outputters from the _outputters directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _outputters directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_outputters
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_renderers(env=None, refresh=True)
Sync the renderers from the _renderers directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _renderers directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_renderers
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_returners(env=None, refresh=True)
Sync the returners from the _returners directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _returners directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_returners
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.sync_states(env=None, refresh=True)
Sync the states from the _states directory on the salt master file
server. This function is environment aware, pass the desired environment
to grab the contents of the _states directory, base is the default
environment.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.sync_states
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.term_job(jid)
Sends a termination signal (SIGTERM 15) to the named salt job\(aqs process
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.term_job <job id>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.saltutil.update(version=None)
Update the salt minion from the URL defined in opts[\(aqupdate_url\(aq]
.sp
This feature requires the minion to be running a bdist_esky build.
.sp
The version number is optional and will default to the most recent version
available at opts[\(aqupdate_url\(aq].
.sp
Returns details about the transaction upon completion.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq saltutil.update 0.10.3
.ft P
.fi
.UNINDENT
.SS salt.modules.selinux
.sp
Execute calls on selinux
.INDENT 0.0
.TP
.B salt.modules.selinux.getenforce()
Return the mode selinux is running in
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.getenforce
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.selinux.getsebool(boolean)
Return the information on a specific selinux boolean
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.getsebool virt_use_usb
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.selinux.list_sebool()
Return a structure listing all of the selinux booleans on the system and
what state they are in
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.list_sebool
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.selinux.setenforce(mode)
Set the SELinux enforcing mode
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.setenforce enforcing
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.selinux.setsebool(boolean, value, persist=False)
Set the value for a boolean
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.setsebool virt_use_usb off
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.selinux.setsebools(pairs, persist=False)
Set the value of multiple booleans
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq selinux.setsebools \(aq{virt_use_usb: on, squid_use_tproxy: off}\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.service
.sp
The default service module, if not otherwise specified salt will fall back
to this basic module
.INDENT 0.0
.TP
.B salt.modules.service.available(name)
Return if the specified service is available
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.available
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.get_all()
Return a list of all available services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.reload_(name)
Restart the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.restart(name, **kwargs)
Restart the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.status(name, sig=None)
Return the status for a service, returns the PID or an empty string if the
service is running or not, pass a signature to use to find the service via
ps
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name> [service signature]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.service.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.shadow
.sp
Manage the shadow file
.INDENT 0.0
.TP
.B salt.modules.shadow.info(name)
Return information for the specified user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_date(name, date)
sets the value for the date the password was last changed to the epoch
(January 1, 1970). See man chage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_date username 0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_inactdays(name, inactdays)
Set the number of days of inactivity after a password has expired before
the account is locked. See man chage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_inactdays username 7
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_maxdays(name, maxdays)
Set the maximum number of days during which a password is valid.
See man chage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_maxdays username 90
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_mindays(name, mindays)
Set the minimum number of days between password changes. See man chage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_mindays username 7
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_password(name, password, use_usermod=False)
Set the password for a named user. The password must be a properly defined
hash. The password hash can be generated with this command:
.sp
\fBpython \-c "import crypt; print crypt.crypt(\(aqpassword\(aq,
\(aq$6$SALTsalt\(aq)"\fP
.sp
\fBSALTsalt\fP is the 8\-character crpytographic salt. Valid characters in the
salt are \fB.\fP, \fB/\fP, and any alphanumeric character.
.sp
Keep in mind that the $6 represents a sha512 hash, if your OS is using a
different hashing algorithm this needs to be changed accordingly
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_password root \(aq$1$UYCIxa628.9qXjpQCjM4a..\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.shadow.set_warndays(name, warndays)
Set the number of days of warning before a password change is required.
See man chage.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_warndays username 7
.ft P
.fi
.UNINDENT
.SS salt.modules.smartos_imgadm
.sp
Module for running imgadm command on SmartOS
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.avail(search=None)
Return a list of available images
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.avail [percona]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.delete(uuid=None)
Remove an installed image
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.delete e42f8c84\-bbea\-11e2\-b920\-078fab2aab1f
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.get(uuid=None)
Return info on an installed image
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.get e42f8c84\-bbea\-11e2\-b920\-078fab2aab1f
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.import_image(uuid=None)
Import an image from the repository
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.import_image e42f8c84\-bbea\-11e2\-b920\-078fab2aab1f
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.list_installed()
Return a list of installed images
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.list_installed
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.show(uuid=None)
Show manifest of a given image
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.show e42f8c84\-bbea\-11e2\-b920\-078fab2aab1f
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.update_installed()
Gather info on unknown images (locally installed)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.update_installed()
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_imgadm.version()
Return imgadm version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq imgadm.version
.ft P
.fi
.UNINDENT
.SS salt.modules.smartos_vmadm
.sp
Module for managing VMs on SmartOS
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.destroy(uuid=None)
Hard power down the virtual machine, this is equivalent to pulling the power
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.destroy <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.get_macs(uuid=None)
Return a list off MAC addresses from the named VM
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_macs <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.init(**kwargs)
Initialize a new VM
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.init image_uuid=\(aq...\(aq alias=\(aq...\(aq [...]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.list_active_vms()
Return a list of uuids for active virtual machine on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_active_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.list_inactive_vms()
Return a list of uuids for inactive virtual machine on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_inactive_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.list_vms()
Return a list of virtual machine names on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.reboot(uuid=None)
Reboot a domain via ACPI request
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.reboot <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.setmem(uuid, memory)
Change the amount of memory allocated to VM.
<memory> is to be specified in MB.
.sp
Note for KVM : this would require a restart of the VM.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.setmem <uuid> 512
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.shutdown(uuid=None)
Send a soft shutdown signal to the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.shutdown <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.start(uuid=None)
Start a defined domain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.start <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.vm_info(uuid=None)
Return a dict with information about the specified VM on this CN
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_info <uuid>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smartos_vmadm.vm_virt_type(uuid=None)
Return VM virtualization type : OS or KVM
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_virt_type <uuid>
.ft P
.fi
.UNINDENT
.SS salt.modules.smf
.sp
Service support for Solaris 10 and 11, should work with other systems
that use SMF also. (e.g. SmartOS)
.INDENT 0.0
.TP
.B salt.modules.smf.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.disabled(name)
Check to see if the named service is disabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.enabled(name)
Check to see if the named service is enabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.get_all()
Return all installed services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.get_disabled()
Return the disabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.get_enabled()
Return the enabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.restart(name)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.status(name, sig=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.smf.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.solaris_group
.sp
Manage groups on Solaris
.INDENT 0.0
.TP
.B salt.modules.solaris_group.add(name, gid=None, system=False)
Add the specified group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.add foo 3456
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_group.chgid(name, gid)
Change the gid for a named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_group.delete(name)
Remove the named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.delete foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_group.getent(refresh=False)
Return info on all groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_group.info(name)
Return information about a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.info foo
.ft P
.fi
.UNINDENT
.SS salt.modules.solarispkg
.sp
Package support for Solaris
.INDENT 0.0
.TP
.B salt.modules.solarispkg.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.install(name=None, refresh=False, sources=None, **kwargs)
Install the passed package. Can install packages from the following
sources:
.sp
.nf
.ft C
* Locally (package already exists on the minion
* HTTP/HTTPS server
* FTP server
* Salt master
.ft P
.fi
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example, installing a datastream pkg that already exists on the
minion:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "/dir/on/minion/<pkg filename>"}]\(aq
salt \(aq*\(aq pkg.install sources=\(aq[{"SMClgcc346": "/var/spool/pkg/gcc\-3.4.6\-sol10\-sparc\-local.pkg"}]\(aq
.ft P
.fi
.sp
CLI Example, installing a datastream pkg that exists on the salt master:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "salt://pkgs/<pkg filename>"}]\(aq
salt \(aq*\(aq pkg.install sources=\(aq[{"SMClgcc346": "salt://pkgs/gcc\-3.4.6\-sol10\-sparc\-local.pkg"}]\(aq
.ft P
.fi
.sp
CLI Example, installing a datastream pkg that exists on a HTTP server:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "http://packages.server.com/<pkg filename>"}]\(aq
salt \(aq*\(aq pkg.install sources=\(aq[{"SMClgcc346": "http://packages.server.com/gcc\-3.4.6\-sol10\-sparc\-local.pkg"}]\(aq
.ft P
.fi
.sp
If working with solaris zones and you want to install a package only in the
global zone you can pass \(aqcurrent_zone_only=True\(aq to salt to have the
package only installed in the global zone. (Behind the scenes this is
passing \(aq\-G\(aq to the pkgadd command.) Solaris default when installing a
package in the global zone is to install it in all zones. This overrides
that and installs the package only in the global.
.sp
CLI Example, installing a datastream package only in the global zone:
.sp
.nf
.ft C
salt \(aqglobal_zone\(aq pkg.install sources=\(aq[{"SMClgcc346": "/var/spool/pkg/gcc\-3.4.6\-sol10\-sparc\-local.pkg"}]\(aq current_zone_only=True
.ft P
.fi
.sp
By default salt automatically provides an adminfile, to automate package
installation, with these options set:
.INDENT 7.0
.INDENT 3.5
email=
instance=quit
partial=nocheck
runlevel=nocheck
idepend=nocheck
rdepend=nocheck
space=nocheck
setuid=nocheck
conflict=nocheck
action=nocheck
basedir=default
.UNINDENT
.UNINDENT
.sp
You can override any of these options in two ways. First you can optionally
pass any of the options as a kwarg to the module/state to override the
default value or you can optionally pass the \(aqadmin_source\(aq option
providing your own adminfile to the minions.
.sp
Note: You can find all of the possible options to provide to the adminfile
by reading the admin man page:
.sp
.nf
.ft C
man \-s 4 admin
.ft P
.fi
.sp
CLI Example \- Overriding the \(aqinstance\(aq adminfile option when calling the
module directly:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "salt://pkgs/<pkg filename>"}]\(aq instance="overwrite"
.ft P
.fi
.sp
CLI Example \- Overriding the \(aqinstance\(aq adminfile option when used in a
state:
.sp
.nf
.ft C
SMClgcc346:
  pkg.installed:
    \- sources:
      \- SMClgcc346: salt://srv/salt/pkgs/gcc\-3.4.6\-sol10\-sparc\-local.pkg
    \- instance: overwrite
.ft P
.fi
.sp
Note: the ID declaration is ignored, as the package name is read from the
"sources" parameter.
.sp
CLI Example \- Providing your own adminfile when calling the module
directly:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install sources=\(aq[{"<pkg name>": "salt://pkgs/<pkg filename>"}]\(aq admin_source=\(aqsalt://pkgs/<adminfile filename>\(aq
.ft P
.fi
.sp
CLI Example \- Providing your own adminfile when using states:
.sp
.nf
.ft C
<pkg name>:
  pkg.installed:
    \- sources:
      \- <pkg name>: salt://pkgs/<pkg filename>
    \- admin_source: salt://pkgs/<adminfile filename>
.ft P
.fi
.sp
Note: the ID declaration is ignored, as the package name is read from the
"sources" parameter.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.sp
NOTE: As package repositories are not presently supported for Solaris
pkgadd, this function will always return an empty string for a given
package.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.remove(name=None, pkgs=None, **kwargs)
Remove packages with pkgrm
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
By default salt automatically provides an adminfile, to automate package
removal, with these options set:
.sp
.nf
.ft C
email=
instance=quit
partial=nocheck
runlevel=nocheck
idepend=nocheck
rdepend=nocheck
space=nocheck
setuid=nocheck
conflict=nocheck
action=nocheck
basedir=default
.ft P
.fi
.sp
You can override any of these options in two ways. First you can optionally
pass any of the options as a kwarg to the module/state to override the
default value or you can optionally pass the \(aqadmin_source\(aq option
providing your own adminfile to the minions.
.sp
Note: You can find all of the possible options to provide to the adminfile
by reading the admin man page:
.sp
.nf
.ft C
man \-s 4 admin
.ft P
.fi
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove SUNWgit
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solarispkg.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.solaris_shadow
.sp
Manage the password database on Solaris systems
.INDENT 0.0
.TP
.B salt.modules.solaris_shadow.info(name)
Return information for the specified user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_shadow.set_maxdays(name, maxdays)
Set the maximum number of days during which a password is valid. See man
passwd.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_maxdays username 90
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_shadow.set_mindays(name, mindays)
Set the minimum number of days between password changes. See man passwd.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_mindays username 7
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_shadow.set_password(name, password)
Set the password for a named user. The password must be a properly defined
hash, the password hash can be generated with this command:
\fBopenssl passwd \-1 <plaintext password>\fP
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_password root $1$UYCIxa628.9qXjpQCjM4a..
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_shadow.set_warndays(name, warndays)
Set the number of days of warning before a password change is required.
See man passwd.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_warndays username 7
.ft P
.fi
.UNINDENT
.SS salt.modules.solaris_user
.sp
Manage users with the useradd command
.INDENT 0.0
.TP
.B salt.modules.solaris_user.add(name, uid=None, gid=None, groups=None, home=None, shell=None, unique=True, system=False, fullname=\(aq\(aq, roomnumber=\(aq\(aq, workphone=\(aq\(aq, homephone=\(aq\(aq, createhome=True)
Add a user to the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.add name <uid> <gid> <groups> <home> <shell>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chfullname(name, fullname)
Change the user\(aqs Full Name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chfullname foo "Foo Bar"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chgid(name, gid)
Change the default group of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chgroups(name, groups, append=False)
Change the groups this user belongs to, add append to append the specified
groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgroups foo wheel,root True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chhome(name, home, persist=False)
Change the home directory of the user, pass true for persist to copy files
to the new home dir
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhome foo /home/users/foo True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chhomephone(name, homephone)
Change the user\(aqs Home Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhomephone foo "7735551234"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chroomnumber(name, roomnumber)
Change the user\(aqs Room Number
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chroomnumber foo 123
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chshell(name, shell)
Change the default shell of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chshell foo /bin/zsh
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chuid(name, uid)
Change the uid for a named user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chuid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.chworkphone(name, workphone)
Change the user\(aqs Work Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chworkphone foo "7735550123"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.delete(name, remove=False, force=False)
Remove a user from the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.delete name remove=True force=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.getent()
Return the list of all info for all users
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.info(name)
Return user information
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solaris_user.list_groups(name)
Return a list of groups the named user belongs to
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.list_groups foo
.ft P
.fi
.UNINDENT
.SS salt.modules.solr
.SS Apache Solr Salt Module
.sp
Author: Jed Glazner
Version: 0.2.1
Modified: 12/09/2011
.sp
This module uses HTTP requests to talk to the apache solr request handlers
to gather information and report errors. Because of this the minion doesn\(aqt
necessarily need to reside on the actual slave.  However if you want to
use the signal function the minion must reside on the physical solr host.
.sp
This module supports multi\-core and standard setups.  Certain methods are
master/slave specific.  Make sure you set the solr.type. If you have
questions or want a feature request please ask.
.SS Coming Features in 0.3
.INDENT 0.0
.IP 1. 3
Add command for checking for replication failures on slaves
.IP 2. 3
Improve match_index_versions since it\(aqs pointless on busy solr masters
.IP 3. 3
Add additional local fs checks for backups to make sure they succeeded
.UNINDENT
.SS Override these in the minion config
.INDENT 0.0
.TP
.B solr.cores
A list of core names eg [\(aqcore1\(aq,\(aqcore2\(aq].
An empty list indicates non\-multicore setup.
.TP
.B solr.baseurl
The root level URL to access solr via HTTP
.TP
.B solr.request_timeout
The number of seconds before timing out an HTTP/HTTPS/FTP request. If
nothing is specified then the python global timeout setting is used.
.TP
.B solr.type
Possible values are \(aqmaster\(aq or \(aqslave\(aq
.TP
.B solr.backup_path
The path to store your backups. If you are using cores and you can specify
to append the core name to the path in the backup method.
.TP
.B solr.num_backups
For versions of solr >= 3.5. Indicates the number of backups to keep. This
option is ignored if your version is less.
.TP
.B solr.init_script
The full path to your init script with start/stop options
.TP
.B solr.dih.options
A list of options to pass to the DIH.
.UNINDENT
.SS Required Options for DIH
.INDENT 0.0
.TP
.B clean
False
Clear the index before importing
.TP
.B commit
True
Commit the documents to the index upon completion
.TP
.B optimize
True
Optimize the index after commit is complete
.TP
.B verbose
True
Get verbose output
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.abort_import(handler, host=None, core_name=None, verbose=False)
MASTER ONLY
Aborts an existing import command to the specified handler.
This command can only be run if the minion is configured with
solr.type=master
.INDENT 7.0
.TP
.B handler
str
The name of the data import handler.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core
str (None)
The core the handler belongs to.
.TP
.B verbose
boolean (False)
Run the command with verbose output.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.abort_import dataimport None music {\(aqclean\(aq:True}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.backup(host=None, core_name=None, append_core_to_path=False)
Tell solr make a backup.  This method can be mis\-leading since it uses the
backup API.  If an error happens during the backup you are not notified.
The status: \(aqOK\(aq in the response simply means that solr received the
request successfully.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.TP
.B append_core_to_path
boolean (False)
If True add the name of the core to the backup path. Assumes that
minion backup path is not None.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.backup music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.core_status(host=None, core_name=None)
MULTI\-CORE HOSTS ONLY
Get the status for a given core or all cores if no core is specified
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str
The name of the core to reload
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.core_status None music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.delta_import(handler, host=None, core_name=None, options=None, extra=None)
Submits an import command to the specified handler using specified options.
This command can only be run if the minion is configured with
solr.type=master
.INDENT 7.0
.TP
.B handler
str
The name of the data import handler.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core
str (None)
The core the handler belongs to.
.TP
.B options
dict (__opts__)
A list of options such as clean, optimize commit, verbose, and
pause_replication. leave blank to use __opts__ defaults. options will
be merged with __opts__
.TP
.B extra
dict ([])
Extra name value pairs to pass to the handler. eg ["name=value"]
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.delta_import dataimport None music {\(aqclean\(aq:True}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.full_import(handler, host=None, core_name=None, options=None, extra=None)
MASTER ONLY
Submits an import command to the specified handler using specified options.
This command can only be run if the minion is configured with
solr.type=master
.INDENT 7.0
.TP
.B handler
str
The name of the data import handler.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core
str (None)
The core the handler belongs to.
.TP
.B options
dict (__opts__)
A list of options such as clean, optimize commit, verbose, and
pause_replication. leave blank to use __opts__ defaults. options will
be merged with __opts__
.TP
.B extra
dict ([])
Extra name value pairs to pass to the handler. e.g. ["name=value"]
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.full_import dataimport None music {\(aqclean\(aq:True}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.import_status(handler, host=None, core_name=None, verbose=False)
Submits an import command to the specified handler using specified options.
This command can only be run if the minion is configured with
solr.type: \(aqmaster\(aq
.INDENT 7.0
.TP
.B handler
str
The name of the data import handler.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core
str (None)
The core the handler belongs to.
.TP
.B verbose
boolean (False)
Specifies verbose output
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.import_status dataimport None music False
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.is_replication_enabled(host=None, core_name=None)
SLAVE CALL
Check for errors, and determine if a slave is replicating or not.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.is_replication_enabled music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.lucene_version(core_name=None)
Gets the lucene version that solr is using. If you are running a multi\-core
setup you should specify a core name since all the cores run under the same
servlet container, they will all have the same version.
.INDENT 7.0
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return: dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.lucene_version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.match_index_versions(host=None, core_name=None)
SLAVE CALL
Verifies that the master and the slave versions are in sync by
comparing the index version. If you are constantly pushing updates
the index the master and slave versions will seldom match. A solution
to this is pause indexing every so often to allow the slave to replicate
and then call this method before allowing indexing to resume.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.match_index_versions music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.optimize(host=None, core_name=None)
Search queries fast, but it is a very expensive operation. The ideal
process is to run this with a master/slave configuration.  Then you
can optimize the master, and push the optimized index to the slaves.
If you are running a single solr instance, or if you are going to run
this on a slave be aware than search performance will be horrible
while this command is being run. Additionally it can take a LONG time
to run and your HTTP request may timeout. If that happens adjust your
timeout settings.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.optimize music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.ping(host=None, core_name=None)
Does a health check on solr, makes sure solr can talk to the indexes.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.ping music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.reload_core(host=None, core_name=None)
MULTI\-CORE HOSTS ONLY
Load a new core from the same configuration as an existing registered core.
While the "new" core is initializing, the "old" one will continue to accept
requests. Once it has finished, all new request will go to the "new" core,
and the "old" core will be unloaded.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str
The name of the core to reload
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.reload_core None music

{\(aqsuccess\(aq:bool, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.reload_import_config(handler, host=None, core_name=None, verbose=False)
MASTER ONLY
re\-loads the handler config XML file.
This command can only be run if the minion is a \(aqmaster\(aq type
.INDENT 7.0
.TP
.B handler
str
The name of the data import handler.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core
str (None)
The core the handler belongs to.
.TP
.B verbose
boolean (False)
Run the command with verbose output.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.reload_import_config dataimport None music {\(aqclean\(aq:True}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.replication_details(host=None, core_name=None)
Get the full replication details.
.INDENT 7.0
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.replication_details music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.set_is_polling(polling, host=None, core_name=None)
SLAVE CALL
Prevent the slaves from polling the master for updates.
.INDENT 7.0
.TP
.B polling
boolean
True will enable polling. False will disable it.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.set_is_polling False
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.set_replication_enabled(status, host=None, core_name=None)
MASTER ONLY
Sets the master to ignore poll requests from the slaves. Useful when you
don\(aqt want the slaves replicating during indexing or when clearing the
index.
.INDENT 7.0
.TP
.B status
boolean
Sets the replication status to the specified state.
.TP
.B host
str (None)
The solr host to query. __opts__[\(aqhost\(aq] is default.
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to set the status on all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.set_replication_enabled false, None, music
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.signal(signal=None)
Signals Apache Solr to start, stop, or restart. Obviously this is only
going to work if the minion resides on the solr host. Additionally Solr
doesn\(aqt ship with an init script so one must be created.
.INDENT 7.0
.TP
.B signal
str (None)
The command to pass to the apache solr init valid values are \(aqstart\(aq,
\(aqstop\(aq, and \(aqrestart\(aq
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.signal restart
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.solr.version(core_name=None)
Gets the solr version for the core specified.  You should specify a core
here as all the cores will run under the same servlet container and so will
all have the same version.
.INDENT 7.0
.TP
.B core_name
str (None)
The name of the solr core if using cores. Leave this blank if you are
not using cores or if you want to check all cores.
.UNINDENT
.sp
Return : dict<str,obj>:
.sp
.nf
.ft C
{\(aqsuccess\(aq:boolean, \(aqdata\(aq:dict, \(aqerrors\(aq:list, \(aqwarnings\(aq:list}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq solr.version
.ft P
.fi
.UNINDENT
.SS salt.modules.sqlite3
.sp
Support for SQLite3
.INDENT 0.0
.TP
.B salt.modules.sqlite3.fetch(db=None, sql=None)
Retrieve data from an sqlite3 db (returns all rows, be careful!)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.fetch /root/test.db \(aqSELECT * FROM test;\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.indexes(db=None)
Show all indices in the database, for people with poor spelling skills
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.indexes /root/test.db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.indices(db=None)
Show all indices in the database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.indices /root/test.db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.modify(db=None, sql=None)
Issue an SQL query to sqlite3 (with no return data), usually used
to modify the database in some way (insert, delete, create, etc)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.modify /root/test.db \(aqCREATE TABLE test(id INT, testdata TEXT);\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.sqlite_version()
Return version of sqlite
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.sqlite_version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.tables(db=None)
Show all tables in the database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.tables /root/test.db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sqlite3.version()
Return version of pysqlite
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sqlite3.version
.ft P
.fi
.UNINDENT
.SS salt.modules.ssh
.sp
Manage client ssh components
.INDENT 0.0
.TP
.B salt.modules.ssh.auth_keys(user, config=\(aq.ssh/authorized_keys\(aq)
Return the authorized keys for the specified user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.auth_keys root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.check_key(user, key, enc, comment, options, config=\(aq.ssh/authorized_keys\(aq)
Check to see if a key needs updating, returns "update", "add" or "exists"
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.check_key <user> <key> <enc> <comment> <options>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.check_key_file(user, keysource, config=\(aq.ssh/authorized_keys\(aq, env=\(aqbase\(aq)
Check a keyfile from a source destination against the local keys and
return the keys to change
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq root salt://ssh/keyfile
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.check_known_host(user, hostname, key=None, fingerprint=None, config=\(aq.ssh/known_hosts\(aq)
Check the record in known_hosts file, either by its value or by fingerprint
(it\(aqs enough to set up either key or fingerprint, you don\(aqt need to set up
both).
.sp
If provided key or fingerprint doesn\(aqt match with stored value, return
"update", if no value is found for a given host, return "add", otherwise
return "exists".
.sp
If neither key, nor fingerprint is defined, then additional validation is
not performed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.check_known_host <user> <hostname> key=\(aqAAAA...FAaQ==\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.get_known_host(user, hostname, config=\(aq.ssh/known_hosts\(aq)
Return information about known host from the configfile, if any.
If there is no such key, return None.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.get_known_host <user> <hostname>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.host_keys(keydir=None)
Return the minion\(aqs host keys
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.host_keys
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.recv_known_host(hostname, enc=None, port=None, hash_hostname=False)
Retrieve information about host public key from remote server
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.recv_known_host <hostname> enc=<enc> port=<port>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.rm_auth_key(user, key, config=\(aq.ssh/authorized_keys\(aq)
Remove an authorized key from the specified user\(aqs authorized key file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.rm_auth_key <user> <key>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.rm_known_host(user, hostname, config=\(aq.ssh/known_hosts\(aq)
Remove all keys belonging to hostname from a known_hosts file.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.rm_known_host <user> <hostname>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.set_auth_key(user, key, enc=\(aqssh\-rsa\(aq, comment=\(aq\(aq, options=None, config=\(aq.ssh/authorized_keys\(aq)
Add a key to the authorized_keys file. The "key" parameter must only be the
string of text that is the encoded key. If the key begins with "ssh\-rsa"
or ends with \fI\%user@host\fP, remove those from the key before passing it to this
function.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.set_auth_key <user> \(aq<key>\(aq enc=\(aqdsa\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.set_auth_key_from_file(user, source, config=\(aq.ssh/authorized_keys\(aq, env=\(aqbase\(aq)
Add a key to the authorized_keys file, using a file as the source.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.set_auth_key_from_file <user>                salt://ssh_keys/<user>.id_rsa.pub
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.ssh.set_known_host(user, hostname, fingerprint=None, port=None, enc=None, hash_hostname=True, config=\(aq.ssh/known_hosts\(aq)
Download SSH public key from remote host "hostname", optionally validate
its fingerprint against "fingerprint" variable and save the record in the
known_hosts file.
.sp
If such a record does already exists in there, do nothing.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq ssh.set_known_host <user> fingerprint=\(aqxx:xx:..:xx\(aq                  enc=\(aqssh\-rsa\(aq config=\(aq.ssh/known_hosts\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.state
.sp
Control the state system on the minion
.INDENT 0.0
.TP
.B salt.modules.state.clear_cache()
Clear out cached state files, forcing even cache runs to refresh the cache
on the next state execution.
.sp
Remember that the state cache is completely disabled by default, this
execution only applies if cache=True is used in states
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.clear_cache
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.high(data)
Execute the compound calls stored in a single set of high data
This function is mostly intended for testing the state system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.high \(aq{"vim": {"pkg": ["installed"]}}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.highstate(test=None, **kwargs)
Retrive the state data from the salt master for this minion and execute it
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.highstate
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.low(data)
Execute a single low data call
This function is mostly intended for testing the state system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.low \(aq{"state": "pkg", "fun": "installed", "name": "vi"}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.running()
Return a dict of state return data if a state function is already running.
This function is used to prevent multiple state calls from being run at
the same time.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.running
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.show_highstate()
Retrieve the highstate data from the salt master and display it
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_highstate
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.show_lowstate()
List out the low data that will be applied to this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_lowstate
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.show_sls(mods, env=\(aqbase\(aq, test=None, **kwargs)
Display the state data from a specific sls or list of sls files on the
master
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_sls core,edit.vim dev
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.show_top()
Return the top data that the minion will use for a highstate
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_top
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.single(fun, name, test=None, **kwargs)
Execute a single state function with the named kwargs, returns False if
insufficient data is sent to the command
.sp
By default, the values of the kwargs will be parsed as YAML. So, you can
specify lists values, or lists of single entry key\-value maps, as you
would in a YAML salt file. Alternatively, JSON format of keyword values
is also supported.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.single pkg.installed name=vim
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.sls(mods, env=\(aqbase\(aq, test=None, exclude=None, **kwargs)
Execute a set list of state modules from an environment, default
environment is base
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.sls core,edit.vim dev
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.template(tem)
Execute the information stored in a template file on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.template \(aq<Path to template on the minion>\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.template_str(tem)
Execute the information stored in a string from an sls template
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.template_str \(aq<Template String>\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.state.top(topfn, test=None, **kwargs)
Execute a specific top file instead of the default
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq state.top reverse_top.sls
.ft P
.fi
.UNINDENT
.SS salt.modules.status
.sp
Module for returning various status data about a minion.
These data can be useful for compiling into stats later.
.INDENT 0.0
.TP
.B salt.modules.status.all_status()
Return a composite of all status data and info for this minion.
Warning: There is a LOT here!
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.all_status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.cpuinfo()
Return the CPU info for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.cpuinfo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.cpustats()
Return the CPU stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.cpustats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.custom()
Return a custom composite of status data and info for this minion,
based on the minion config file. An example config like might be:
.sp
.nf
.ft C
status.cpustats.custom: [ \(aqcpu\(aq, \(aqctxt\(aq, \(aqbtime\(aq, \(aqprocesses\(aq ]
.ft P
.fi
.sp
Where status refers to status.py, cpustats is the function
where we get our data, and custom is this function It is followed
by a list of keys that we want returned.
.sp
This function is meant to replace all_status(), which returns
anything and everything, which we probably don\(aqt want.
.sp
By default, nothing is returned. Warning: Depending on what you
include, there can be a LOT here!
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.custom
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.diskstats()
Return the disk stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.diskstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.diskusage(*args)
Return the disk usage for this minion
.sp
Usage:
.sp
.nf
.ft C
salt \(aq*\(aq status.diskusage [paths and/or filesystem types]
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.diskusage         # usage for all filesystems
salt \(aq*\(aq status.diskusage / /tmp  # usage for / and /tmp
salt \(aq*\(aq status.diskusage ext?    # usage for ext[234] filesystems
salt \(aq*\(aq status.diskusage / ext?  # usage for / and all ext filesystems
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.loadavg()
Return the load averages for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.loadavg
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.meminfo()
Return the CPU stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.meminfo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.netdev()
Return the network device stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.netdev
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.netstats()
Return the network stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.netstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.pid(sig)
Return the PID or an empty string if the process is running or not.
Pass a signature to use to find the process via ps.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.pid <sig>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.procs()
Return the process data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.procs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.uptime()
Return the uptime for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.uptime
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.vmstats()
Return the virtual memory stats for this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.vmstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.status.w()
Return a list of logged in users for this minion, using the w command
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.w
.ft P
.fi
.UNINDENT
.SS salt.modules.supervisord
.sp
Provide the service module for system supervisord or supervisord in a virtualenv
.INDENT 0.0
.TP
.B salt.modules.supervisord.add(name, user=None, conf_file=None, bin_env=None)
Activates any updates in config for process/group.
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.add <name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.custom(command, user=None, conf_file=None, bin_env=None)
Run any custom supervisord command
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.custom "mstop \(aq*gunicorn*\(aq"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.remove(name, user=None, conf_file=None, bin_env=None)
Removes process/group from active config
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.remove <name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.reread(user=None, conf_file=None, bin_env=None)
Reload the daemon\(aqs configuration files
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.reread
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.restart(name=\(aqall\(aq, user=None, conf_file=None, bin_env=None)
Restart the named service.
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.restart <service>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.start(name=\(aqall\(aq, user=None, conf_file=None, bin_env=None)
Start the named service.
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.start <service>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.status(name=None, user=None, conf_file=None, bin_env=None)
List programs and its state
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.status_raw(name=None, user=None, conf_file=None, bin_env=None)
Display the raw output of status
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.status_raw
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.stop(name=\(aqall\(aq, user=None, conf_file=None, bin_env=None)
Stop the named service.
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.stop <service>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.supervisord.update(user=None, conf_file=None, bin_env=None)
Reload config and add/remove as necessary
.INDENT 7.0
.TP
.B user
user to run supervisorctl as
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq supervisord.update
.ft P
.fi
.UNINDENT
.SS salt.modules.svn
.sp
Subversion SCM
.INDENT 0.0
.TP
.B salt.modules.svn.add(cwd, targets, user=None, *opts)
Add files to be tracked by the Subversion working\-copy checkout
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files and directories to pass to the command as arguments
.TP
.B user
None
Run svn as a user other than what the minion runs as
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.add /path/to/repo /path/to/new/file
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.checkout(cwd, remote, target=None, user=None, username=None, *opts)
Download a working copy of the remote Subversion repository
directory or file
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B remote
None
URL to checkout
.TP
.B target
None
The name to give the file or directory working copy
Default: svn uses the remote basename
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.checkout /path/to/repo svn://remote/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.commit(cwd, targets=None, msg=None, user=None, username=None, *opts)
Commit the current directory, files, or directories to
the remote Subversion repository
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files and directories to pass to the command as arguments
Default: svn uses \(aq.\(aq
.TP
.B msg
None
Message to attach to the commit log
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.commit /path/to/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.diff(cwd, targets=None, user=None, username=None, *opts)
Return the diff of the current directory, files, or directories from
the remote Subversion repository
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files and directories to pass to the command as arguments
Default: svn uses \(aq.\(aq
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.diff /path/to/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.info(cwd, targets=None, user=None, username=None, fmt=\(aqstr\(aq)
Display the Subversion information from the checkout.
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files, directories, and URLs to pass to the command as arguments
svn uses \(aq.\(aq by default
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.TP
.B fmt
str
How to fmt the output from info.
(str, xml, list, dict)
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.info /path/to/svn/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.remove(cwd, targets, msg=None, user=None, username=None, *opts)
Remove files and directories from the Subversion repository
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files, directories, and URLs to pass to the command as arguments
.TP
.B msg
None
Message to attach to the commit log
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.remove /path/to/repo /path/to/repo/remove
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.status(cwd, targets=None, user=None, username=None, *opts)
Display the status of the current directory, files, or
directories in the Subversion repository
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files, directories, and URLs to pass to the command as arguments
Default: svn uses \(aq.\(aq
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.status /path/to/repo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.svn.update(cwd, targets=None, user=None, *opts)
Update the current directory, files, or directories from
the remote Subversion repository
.INDENT 7.0
.TP
.B cwd
The path to the Subversion repository
.TP
.B targets
None
files and directories to pass to the command as arguments
Default: svn uses \(aq.\(aq
.TP
.B user
None
Run svn as a user other than what the minion runs as
.TP
.B username
None
Connect to the Subversion server as another user
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq svn.update /path/to/repo
.ft P
.fi
.UNINDENT
.SS salt.modules.sysbench
.sp
The \(aqsysbench\(aq module is used to analyse the
performance of the minions, right from the master!
It measures various system parameters such as
CPU, Memory, FileI/O, Threads and Mutex.
.INDENT 0.0
.TP
.B salt.modules.sysbench.cpu()
Tests for the CPU performance of minions.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq sysbench.cpu
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysbench.fileio()
This tests for the file read and write operations
Various modes of operations are
.INDENT 7.0
.IP \(bu 2
sequential write
.IP \(bu 2
sequential rewrite
.IP \(bu 2
sequential read
.IP \(bu 2
random read
.IP \(bu 2
random write
.IP \(bu 2
random read and write
.UNINDENT
.sp
The test works with 32 files with each file being 1Gb in size
The test consumes a lot of time. Be patient!
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq sysbench.fileio
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysbench.memory()
This tests the memory for read and write operations.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq sysbench.memory
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysbench.mutex()
Tests the implementation of mutex
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq sysbench.mutex
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysbench.ping()
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysbench.threads()
This tests the performance of the processor\(aqs scheduler
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sysbench.threads
.ft P
.fi
.UNINDENT
.SS salt.modules.sysmod
.sp
The sys module provides information about the available functions on the
minion.
.INDENT 0.0
.TP
.B salt.modules.sysmod.argspec(module=\(aq\(aq)
Return the argument specification of functions in Salt execution
modules.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sys.argspec pkg.install
salt \(aq*\(aq sys.argspec sys
salt \(aq*\(aq sys.argspec
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysmod.doc(*args, **kwargs)
Return the docstrings for all modules. Optionally, specify a module or a
function to narrow the selection.
.sp
The strings are aggregated into a single document on the master for easy
reading.
.sp
Multiple modules/functions can be specified.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sys.doc
salt \(aq*\(aq sys.doc sys
salt \(aq*\(aq sys.doc sys.doc
salt \(aq*\(aq sys.doc network.traceroute user.info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysmod.list_functions(*args, **kwargs)
List the functions for all modules. Optionally, specify a module or modules
from which to list.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sys.list_functions
salt \(aq*\(aq sys.list_functions sys
salt \(aq*\(aq sys.list_functions sys user
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysmod.list_modules()
List the modules loaded on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sys.list_modules
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.sysmod.reload_modules()
Tell the minion to reload the execution modules
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq sys.reload_modules
.ft P
.fi
.UNINDENT
.SS salt.modules.systemd
.sp
Provide the service module for systemd
.INDENT 0.0
.TP
.B salt.modules.systemd.available(name)
Check that the given service is available taking into account
template units.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.available sshd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.disable(name, **kwargs)
Disable the named service to not start when the system boots
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.disabled(name)
Return if the named service is disabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.enable(name, **kwargs)
Enable the named service to start when the system boots
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.enabled(name)
Return if the named service is enabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.force_reload(name)
Force\-reload the specified service with systemd
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.force_reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.get_all()
Return a list of all available services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.get_disabled()
Return a list of all disabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.get_enabled()
Return a list of all enabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.reload_(name)
Reload the specified service with systemd
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.restart(name)
Restart the specified service with systemd
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.start(name)
Start the specified service with systemd
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.status(name, sig=None)
Return the status for a service via systemd, returns a bool
whether the service is running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.stop(name)
Stop the specified service with systemd
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.systemd.systemctl_reload()
Reloads systemctl, an action needed whenever unit files are updated.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.systemctl_reload
.ft P
.fi
.UNINDENT
.SS salt.modules.system
.sp
Support for reboot, shutdown, etc
.INDENT 0.0
.TP
.B salt.modules.system.halt()
Halt a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.halt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.system.init(runlevel)
Change the system runlevel on sysV compatible systems
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.init 3
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.system.poweroff()
Poweroff a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.poweroff
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.system.reboot()
Reboot the system using the \(aqreboot\(aq command
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.reboot
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.system.shutdown()
Shutdown a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.shutdown
.ft P
.fi
.UNINDENT
.SS salt.modules.test
.sp
Module for running arbitrary tests
.INDENT 0.0
.TP
.B salt.modules.test.arg(*args, **kwargs)
Print out the data passed into the function \fB*args\fP and \fB\(gakwargs\fP, this
is used to both test the publication data and cli argument passing, but
also to display the information available within the publication data.
Returns {"args": args, "kwargs": kwargs}.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.arg 1 "two" 3.1 txt="hello" wow=\(aq{a: 1, b: "hello"}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.arg_repr(*args, **kwargs)
Print out the data passed into the function \fB*args\fP and \fB\(gakwargs\fP, this
is used to both test the publication data and cli argument passing, but
also to display the information available within the publication data.
Returns {"args": repr(args), "kwargs": repr(kwargs)}.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.arg_repr 1 "two" 3.1 txt="hello" wow=\(aq{a: 1, b: "hello"}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.collatz(start)
Execute the collatz conjecture from the passed starting number,
returns the sequence and the time it took to compute. Used for
performance tests.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.collatz 3
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.conf_test()
Return the value for test.foo in the minion configuration file, or return
the default value
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.conf_test
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.cross_test(func, args=None)
Execute a minion function via the __salt__ object in the test
module, used to verify that the minion functions can be called
via the __salt__ module.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.cross_test file.gid_to_group 0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.echo(text)
Return a string \- used for testing the connection
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.echo \(aqfoo bar baz quo qux\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.fib(num)
Return a Fibonacci sequence up to the passed number, and the
timeit took to compute in seconds. Used for performance tests
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.fib 3
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.get_opts()
Return the configuration options passed to this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.get_opts
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.kwarg(**kwargs)
Print out the data passed into the function \fB**kwargs\fP, this is used to
both test the publication data and cli kwarg passing, but also to display
the information available within the publication data.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.kwarg num=1 txt="two" env=\(aq{a: 1, b: "hello"}\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.not_loaded()
List the modules that were not loaded by the salt loader system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.not_loaded
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.outputter(data)
Test the outputter, pass in data to return
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.outputter foobar
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.ping()
Just used to make sure the minion is up and responding
Return True
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.provider(module)
Pass in a function name to discover what provider is being used
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.provider service
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.providers()
Return a dict of the provider names and the files that provided them
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.providers
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.rand_sleep(max=60)
Sleep for a random number of seconds, used to test long\-running commands
and minions returning at differing intervals
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.rand_sleep 60
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.retcode(code=42)
Test that the returncode system is functioning correctly
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.retcode 42
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.sleep(length)
Instruct the minion to initiate a process that will sleep for a given
period of time.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.sleep 20
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.tty(device, echo=None)
Echo a string to a specific tty
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.tty tty0 \(aqThis is a test\(aq
salt \(aq*\(aq test.tty pts3 \(aqThis is a test\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.version()
Return the version of salt on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.version
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.versions_information()
Returns versions of components used by salt as a dict
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.versions_information
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.test.versions_report()
Returns versions of components used by salt
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq test.versions_report
.ft P
.fi
.UNINDENT
.SS salt.modules.timezone
.sp
Module for managing timezone on POSIX\-like systems.
.INDENT 0.0
.TP
.B salt.modules.timezone.get_hwclock()
Get current hardware clock setting (UTC or localtime)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.get_hwclock
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.get_offset()
Get current numeric timezone offset from UCT (i.e. \-0700)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.get_offset
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.get_zone()
Get current timezone (i.e. America/Denver)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.get_zone
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.get_zonecode()
Get current timezone (i.e. PST, MDT, etc)
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.get_zonecode
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.set_hwclock(clock)
Sets the hardware clock to be either UTC or localtime
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.set_hwclock UTC
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.set_zone(timezone)
Unlinks, then symlinks /etc/localtime to the set timezone.
.sp
The timezone is crucial to several system processes, each of which SHOULD
be restarted (for instance, whatever you system uses as its cron and
syslog daemons). This will not be magically done for you!
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.set_zone \(aqAmerica/Denver\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.timezone.zone_compare(timezone)
Checks the md5sum between the given timezone, and the one set in
/etc/localtime. Returns True if they match, and False if not. Mostly useful
for running state checks.
.sp
Example:
.sp
.nf
.ft C
salt \(aq*\(aq timezone.zone_compare \(aqAmerica/Denver\(aq
.ft P
.fi
.UNINDENT
.SS salt.modules.tls
.sp
A salt module for SSL/TLS.
Can create a Certificate Authority (CA)
or use Self\-Signed certificates.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
PyOpenSSL Python module
.UNINDENT
.TP
.B configuration
Add the following values in /etc/salt/minion for the CA module
to function properly:
.sp
.nf
.ft C
ca.cert_base_path: \(aq/etc/pki\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tls.create_ca(ca_name, bits=2048, days=365, CN=\(aqlocalhost\(aq, C=\(aqUS\(aq, ST=\(aqUtah\(aq, L=\(aqSalt Lake City\(aq, O=\(aqSalt Stack\(aq, OU=None, emailAddress=\(aqxyz@pdq.net\(aq)
Create a Certificate Authority (CA)
.INDENT 7.0
.TP
.B ca_name
name of the CA
.TP
.B bits
number of RSA key bits, default is 2048
.TP
.B days
number of days the CA will be valid, default is 365
.TP
.B CN
common name in the request, default is "localhost"
.TP
.B C
country, default is "US"
.TP
.B ST
state, default is "Utah"
.TP
.B L
locality, default is "Centerville", the city where SaltStack originated
.TP
.B O
organization, default is "Salt Stack"
.TP
.B OU
organizational unit, default is None
.TP
.B emailAddress
email address for the CA owner, default is \fI\%'xyz@pdq.net\fP\(aq
.UNINDENT
.sp
Writes out a CA certificate based upon defined config values. If the file
already exists, the function just returns assuming the CA certificate
already exists.
.sp
If the following values were set:
.sp
ca.cert_base_path=\(aq/etc/pki/koji\(aq
ca_name=\(aqkoji\(aq
.sp
the resulting CA would be written in the following location:
.sp
.nf
.ft C
/etc/pki/koji/koji_ca_cert.crt
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tls.create_ca test_ca
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tls.create_ca_signed_cert(ca_name, CN, days=365)
Create a Certificate (CERT) signed by a
named Certificate Authority (CA)
.INDENT 7.0
.TP
.B ca_name
name of the CA
.TP
.B CN
common name matching the certificate signing request
.TP
.B days
number of days certificate is valid, default is 365 (1 year)
.UNINDENT
.sp
Writes out a Certificate (CERT) If the file already
exists, the function just returns assuming the CERT already exists.
.sp
The CN \fImust\fP match an existing CSR generated by create_csr. If it
does not, this method does nothing.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tls.create_ca_signed_cert test localhost
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tls.create_csr(ca_name, bits=2048, CN=\(aqlocalhost\(aq, C=\(aqUS\(aq, ST=\(aqUtah\(aq, L=\(aqSalt Lake City\(aq, O=\(aqSalt Stack\(aq, OU=None, emailAddress=\(aqxyz@pdq.net\(aq)
Create a Certificate Signing Request (CSR) for a
particular Certificate Authority (CA)
.INDENT 7.0
.TP
.B ca_name
name of the CA
.TP
.B bits
number of RSA key bits, default is 2048
.TP
.B CN
common name in the request, default is "localhost"
.TP
.B C
country, default is "US"
.TP
.B ST
state, default is "Utah"
.TP
.B L
locality, default is "Centerville", the city where SaltStack originated
.TP
.B O
organization, default is "Salt Stack"
NOTE: Must the same as CA certificate or an error will be raised
.TP
.B OU
organizational unit, default is None
.TP
.B emailAddress
email address for the request, default is \fI\%'xyz@pdq.net\fP\(aq
.UNINDENT
.sp
Writes out a Certificate Signing Request (CSR) If the file already
exists, the function just returns assuming the CSR already exists.
.sp
If the following values were set:
.sp
ca.cert_base_path=\(aq/etc/pki/koji\(aq
ca_name=\(aqkoji\(aq
CN=\(aqtest.egavas.org\(aq
.sp
the resulting CSR, and corresponding key, would be written in the
following location:
.sp
/etc/pki/koji/certs/test.egavas.org.csr
/etc/pki/koji/certs/test.egavas.org.key
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tls.create_csr test
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tls.create_pkcs12(ca_name, CN, passphrase=\(aq\(aq)
Create a PKCS#12 browser certificate for a particular Certificate (CN)
.INDENT 7.0
.TP
.B ca_name
name of the CA
.TP
.B CN
common name matching the certificate signing request
.TP
.B passphrase
used to unlock the PKCS#12 certificate when loaded into the browser
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tls.create_pkcs12 test localhost
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tls.create_self_signed_cert(tls_dir=\(aqtls\(aq, bits=2048, days=365, CN=\(aqlocalhost\(aq, C=\(aqUS\(aq, ST=\(aqUtah\(aq, L=\(aqSalt Lake City\(aq, O=\(aqSalt Stack\(aq, OU=None, emailAddress=\(aqxyz@pdq.net\(aq)
Create a Self\-Signed Certificate (CERT)
.INDENT 7.0
.TP
.B tls_dir
location appended to the ca.cert_base_path, default is \(aqtls\(aq
.TP
.B bits
number of RSA key bits, default is 2048
.TP
.B CN
common name in the request, default is "localhost"
.TP
.B C
country, default is "US"
.TP
.B ST
state, default is "Utah"
.TP
.B L
locality, default is "Centerville", the city where SaltStack originated
.TP
.B O
organization, default is "Salt Stack"
NOTE: Must the same as CA certificate or an error will be raised
.TP
.B OU
organizational unit, default is None
.TP
.B emailAddress
email address for the request, default is \fI\%'xyz@pdq.net\fP\(aq
.UNINDENT
.sp
Writes out a Self\-Signed Certificate (CERT). If the file already
exists, the function just returns.
.sp
If the following values were set:
.sp
ca.cert_base_path=\(aq/etc/pki/koji\(aq
tls_dir=\(aqkoji\(aq
CN=\(aqtest.egavas.org\(aq
.sp
the resulting CERT, and corresponding key, would be written in the
following location:
.sp
/etc/pki/tls/certs/test.egavas.org.crt
/etc/pki/tls/certs/test.egavas.org.key
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tls.create_self_signed_cert
.ft P
.fi
.UNINDENT
.SS salt.modules.tomcat
.sp
Support for Tomcat
.sp
This module uses the manager webapp to manage Apache tomcat webapps
If the manager webapp is not configured some of the functions won\(aqt work
.sp
The following grains/pillar should be set:
.sp
.nf
.ft C
tomcat\-manager.user: admin user name
tomcat\-manager.passwd: password
.ft P
.fi
.sp
and also configure a user in the conf/tomcat\-users.xml file:
.sp
.nf
.ft C
<?xml version=\(aq1.0\(aq encoding=\(aqutf\-8\(aq?>
<tomcat\-users>
    <role rolename="manager\-script"/>
    <user username="tomcat" password="tomcat" roles="manager\-script"/>
</tomcat\-users>
.ft P
.fi
.sp
Notes:
.INDENT 0.0
.IP \(bu 2
More information about tomcat manager:
\fI\%http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html\fP
.IP \(bu 2
if you use only this module for deployments you\(aqve might want to strict
access to the manager only from localhost for more info:
\fI\%http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html#Configuring_Manager_Application_Access\fP
.IP \(bu 2
Tested on:
.INDENT 2.0
.TP
.B JVM Vendor:
Sun Microsystems Inc.
.TP
.B JVM Version:
1.6.0_43\-b01
.TP
.B OS Architecture:
amd64
.TP
.B OS Name:
Linux
.TP
.B OS Version:
2.6.32\-358.el6.x86_64
.TP
.B Tomcat Version:
Apache Tomcat/7.0.37
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.deploy_war(war, context, force=\(aqno\(aq, url=\(aqhttp://localhost:8080/manager\(aq, env=\(aqbase\(aq, timeout=180)
Deploy a WAR file
.INDENT 7.0
.TP
.B war
absolute path to WAR file (should be accessible by the user running
tomcat) or a path supported by the salt.modules.cp.get_file function
.TP
.B context
the context path to deploy
.TP
.B force
False
set True to deploy the webapp even one is deployed in the context
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B env
base
the environment for WAR file in used by salt.modules.cp.get_file
function
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
cp module
salt \(aq*\(aq tomcat.deploy_war salt://application.war /api
salt \(aq*\(aq tomcat.deploy_war salt://application.war /api no
salt \(aq*\(aq tomcat.deploy_war salt://application.war /api yes http://localhost:8080/manager

minion local file system
salt \(aq*\(aq tomcat.deploy_war /tmp/application.war /api
salt \(aq*\(aq tomcat.deploy_war /tmp/application.war /api no
salt \(aq*\(aq tomcat.deploy_war /tmp/application.war /api yes http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.fullversion()
Return all server information from catalina.sh version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.fullversion
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.leaks(url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Find memory leaks in tomcat
.INDENT 7.0
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.leaks
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.ls(url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
list all the deployed webapps
.INDENT 7.0
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.ls
salt \(aq*\(aq tomcat.ls http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.reload_(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Reload the webapp
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.reload /jenkins
salt \(aq*\(aq tomcat.reload /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.serverinfo(url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
return detailes about the server
.INDENT 7.0
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.serverinfo
salt \(aq*\(aq tomcat.serverinfo http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.sessions(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
return the status of the webapp sessions
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.sessions /jenkins
salt \(aq*\(aq tomcat.sessions /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.signal(signal=None)
Signals catalina to start, stop, securestart, forcestop.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.signal start
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.start(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Start the webapp
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.start /jenkins
salt \(aq*\(aq tomcat.start /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.status(url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Used to test if the tomcat manager is up
.INDENT 7.0
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.status
salt \(aq*\(aq tomcat.status http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.status_webapp(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
return the status of the webapp (stopped | running | missing)
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.status_webapp /jenkins
salt \(aq*\(aq tomcat.status_webapp /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.stop(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Stop the webapp
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.stop /jenkins
salt \(aq*\(aq tomcat.stop /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.undeploy(app, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Undeploy a webapp
.INDENT 7.0
.TP
.B app
the webapp context path
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request
.UNINDENT
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.undeploy /jenkins
salt \(aq*\(aq tomcat.undeploy /jenkins http://localhost:8080/manager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.tomcat.version()
Return server version from catalina.sh version
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq tomcat.version
.ft P
.fi
.UNINDENT
.SS salt.modules.upstart
.sp
Module for the management of upstart systems. The Upstart system only supports
service starting, stopping and restarting.
.sp
Currently (as of Ubuntu 12.04) there is no tool available to disable
Upstart services (like update\-rc.d). This[1] is the recommended way to
disable an Upstart service. So we assume that all Upstart services
that have not been disabled in this manner are enabled.
.sp
But this is broken because we do not check to see that the dependent
services are enabled. Otherwise we would have to do something like
parse the output of "initctl show\-config" to determine if all service
dependencies are enabled to start on boot. For example, see the "start
on" condition for the lightdm service below[2]. And this would be too
hard. So we wait until the upstart developers have solved this
problem. :) This is to say that an Upstart service that is enabled may
not really be enabled.
.sp
Also, when an Upstart service is enabled, should the dependent
services be enabled too? Probably not. But there should be a notice
about this, at least.
.sp
[1] \fI\%http://upstart.ubuntu.com/cookbook/#disabling-a-job-from-automatically-starting\fP
.INDENT 0.0
.TP
.B [2] lightdm
emits login\-session\-start
emits desktop\-session\-start
emits desktop\-shutdown
start on ((((filesystem and runlevel [!06]) and started dbus) and (drm\-device\-added card0 PRIMARY_DEVICE_FOR_DISPLAY=1 or stopped udev\-fallback\-graphics)) or runlevel PREVLEVEL=S)
stop on runlevel [016]
.UNINDENT
.sp
DO NOT use this module on Red Hat systems, as Red Hat systems should use the
rh_service module, since red hat systems support chkconfig
.INDENT 0.0
.TP
.B salt.modules.upstart.disable(name, **kwargs)
Disable the named service from starting on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.disabled(name)
Check to see if the named service is disabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.enabled(name)
Check to see if the named service is enabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.force_reload(name)
Force\-reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.force_reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.full_restart(name, **kwargs)
Do a full restart (stop/start) of the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.full_restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.get_all()
Return all installed services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.get_disabled()
Return the disabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.get_enabled()
Return the enabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.reload_(name)
Reload the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.reload <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.restart(name, **kwargs)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.status(name, sig=None)
Return the status for a service, returns a bool whether the service is
running.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.upstart.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.useradd
.sp
Manage users with the useradd command
.INDENT 0.0
.TP
.B salt.modules.useradd.add(name, uid=None, gid=None, groups=None, home=None, shell=None, unique=True, system=False, fullname=\(aq\(aq, roomnumber=\(aq\(aq, workphone=\(aq\(aq, homephone=\(aq\(aq, createhome=True)
Add a user to the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.add name <uid> <gid> <groups> <home> <shell>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chfullname(name, fullname)
Change the user\(aqs Full Name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chfullname foo "Foo Bar"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chgid(name, gid)
Change the default group of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chgroups(name, groups, append=False)
Change the groups this user belongs to, add append to append the specified
groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgroups foo wheel,root True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chhome(name, home, persist=False)
Change the home directory of the user, pass true for persist to copy files
to the new home dir
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhome foo /home/users/foo True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chhomephone(name, homephone)
Change the user\(aqs Home Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhomephone foo "7735551234"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chroomnumber(name, roomnumber)
Change the user\(aqs Room Number
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chroomnumber foo 123
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chshell(name, shell)
Change the default shell of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chshell foo /bin/zsh
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chuid(name, uid)
Change the uid for a named user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chuid foo 4376
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.chworkphone(name, workphone)
Change the user\(aqs Work Phone
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chworkphone foo "7735550123"
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.delete(name, remove=False, force=False)
Remove a user from the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.delete name remove=True force=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.getent()
Return the list of all info for all users
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.info(name)
Return user information
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.list_groups(name)
Return a list of groups the named user belongs to
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.list_groups foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.useradd.list_users()
Return a list of all users
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.list_users
.ft P
.fi
.UNINDENT
.SS salt.modules.virt
.sp
Work with virtual machines managed by libvirt
.INDENT 0.0
.TP
.B depends
libvirt Python module
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.create(vm_)
Start a defined domain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.create <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.create_xml_path(path)
Start a defined domain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.create_xml_path <path to XML file on the node>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.create_xml_str(xml)
Start a domain based on the XML passed to the function
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.create_xml_str <XML in string format>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.ctrl_alt_del(vm_)
Sends CTRL+ALT+DEL to a VM
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.ctrl_alt_del <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.define_xml_str(xml)
Define a domain based on the XML passed to the function
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.define_xml_str <XML in string format>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.destroy(vm_)
Hard power down the virtual machine, this is equivalent to pulling the
power
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.destroy <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.freecpu()
Return an int representing the number of unallocated cpus on this
hypervisor
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.freecpu
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.freemem()
Return an int representing the amount of memory that has not been given
to virtual machines on this node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.freemem
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.full_info()
Return the node_info, vm_info and freemem
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.full_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.get_disks(vm_)
Return the disks of a named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_disks <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.get_graphics(vm_)
Returns the information on vnc for a given vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_graphics <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.get_macs(vm_)
Return a list off MAC addresses from the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_macs <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.get_nics(vm_)
Return info about the network interfaces of a named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_nics <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.get_xml(vm_)
Returns the XML for a given vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_xml <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.init(name, cpu, mem, image, nic=\(aqdefault\(aq, emulator=\(aqkvm\(aq, **kwargs)
Initialize a new vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aqhypervisor\(aq vm_name 4 512 salt://path/to/image.raw
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.is_hyper()
Returns a bool whether or not this node is a hypervisor of any kind
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.is_hyper
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.is_kvm_hyper()
Returns a bool whether or not this node is a KVM hypervisor
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.is_kvm_hyper
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.is_xen_hyper()
Returns a bool whether or not this node is a XEN hypervisor
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.is_xen_hyper
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.list_active_vms()
Return a list of names for active virtual machine on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_active_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.list_inactive_vms()
Return a list of names for inactive virtual machine on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_inactive_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.list_vms()
Return a list of virtual machine names on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.migrate(vm_, target, ssh=False)
Shared storage migration
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.migrate <vm name> <target hypervisor>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.migrate_non_shared(vm_, target, ssh=False)
Attempt to execute non\-shared storage "all" migration
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.migrate_non_shared <vm name> <target hypervisor>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.migrate_non_shared_inc(vm_, target, ssh=False)
Attempt to execute non\-shared storage "all" migration
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.migrate_non_shared_inc <vm name> <target hypervisor>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.node_info()
Return a dict with information about this node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.node_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.pause(vm_)
Pause the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.pause <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.purge(vm_, dirs=False)
Recursively destroy and delete a virtual machine, pass True for dir\(aqs to
also delete the directories containing the virtual machine disk images \-
USE WITH EXTREME CAUTION!
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.purge <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.reboot(vm_)
Reboot a domain via ACPI request
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.reboot <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.reset(vm_)
Reset a VM by emulating the reset button on a physical machine
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.reset <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.resume(vm_)
Resume the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.resume <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.seed_non_shared_migrate(disks, force=False)
Non shared migration requires that the disks be present on the migration
destination, pass the disks information via this function, to the
migration destination before executing the migration.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.seed_non_shared_migrate <disks>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.set_autostart(vm_, state=\(aqon\(aq)
Set the autostart flag on a VM so that the VM will start with the host
system on reboot.
.sp
CLI Example:
.sp
.nf
.ft C
salt "*" virt.set_autostart <vm name> <on | off>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.setmem(vm_, memory, config=False)
Changes the amount of memory allocated to VM. The VM must be shutdown
for this to work.
.sp
memory is to be specified in MB
If config is True then we ask libvirt to modify the config as well
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.setmem myvm 768
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.setvcpus(vm_, vcpus, config=False)
Changes the amount of vcpus allocated to VM. The VM must be shutdown
for this to work.
.sp
vcpus is an int representing the number to be assigned
If config is True then we ask libvirt to modify the config as well
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.setvcpus myvm 2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.shutdown(vm_)
Send a soft shutdown signal to the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.shutdown <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.start(vm_)
Alias for the obscurely named \(aqcreate\(aq function
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.start <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.undefine(vm_)
Remove a defined vm, this does not purge the virtual machine image, and
this only works if the vm is powered down
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.undefine <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.virt_type()
Returns the virtual machine type as a string
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.virt_type
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.vm_cputime(vm_=None)
Return cputime used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqcputime\(aq <int>
        \(aqcputime_percent\(aq <int>
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_cputime
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.vm_diskstats(vm_=None)
Return disk usage counters used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqrd_req\(aq   : 0,
        \(aqrd_bytes\(aq : 0,
        \(aqwr_req\(aq   : 0,
        \(aqwr_bytes\(aq : 0,
        \(aqerrs\(aq     : 0
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_blockstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.vm_info(vm_=None)
Return detailed information about the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqcpu\(aq: <int>,
        \(aqmaxMem\(aq: <int>,
        \(aqmem\(aq: <int>,
        \(aqstate\(aq: \(aq<state>\(aq,
        \(aqcputime\(aq <int>
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.vm_netstats(vm_=None)
Return combined network counters used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqrx_bytes\(aq   : 0,
        \(aqrx_packets\(aq : 0,
        \(aqrx_errs\(aq    : 0,
        \(aqrx_drop\(aq    : 0,
        \(aqtx_bytes\(aq   : 0,
        \(aqtx_packets\(aq : 0,
        \(aqtx_errs\(aq    : 0,
        \(aqtx_drop\(aq    : 0
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_netstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.virt.vm_state(vm_=None)
Return list of all the vms and their state.
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_state <vm name>
.ft P
.fi
.UNINDENT
.SS salt.modules.virtualenv
.sp
Create virtualenv environments
.INDENT 0.0
.TP
.B salt.modules.virtualenv.create(path, venv_bin=None, no_site_packages=False, system_site_packages=False, distribute=False, clear=False, python=\(aq\(aq, extra_search_dir=\(aq\(aq, never_download=False, prompt=\(aq\(aq, runas=None)
Create a virtualenv
.INDENT 7.0
.TP
.B path
The path to create the virtualenv
.TP
.B venv_bin
\(aqvirtualenv\(aq
The name (and optionally path) of the virtualenv command. This can also
be set globally in the minion config file as \fBvirtualenv.venv_bin\fP.
.TP
.B no_site_packages
False
Passthrough argument given to virtualenv
.TP
.B system_site_packages
False
Passthrough argument given to virtualenv
.TP
.B distribute
False
Passthrough argument given to virtualenv
.TP
.B clear
False
Passthrough argument given to virtualenv
.TP
.B python
(default)
Passthrough argument given to virtualenv
.TP
.B extra_search_dir
(default)
Passthrough argument given to virtualenv
.TP
.B never_download
(default)
Passthrough argument given to virtualenv
.TP
.B prompt
(default)
Passthrough argument given to virtualenv
.TP
.B runas
None
Set ownership for the virtualenv
.UNINDENT
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virtualenv.create /path/to/new/virtualenv
.ft P
.fi
.UNINDENT
.SS salt.modules.win_disk
.sp
Module for gathering disk information on Windows
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
win32api Python module
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_disk.usage()
Return usage information for volumes mounted on this minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq disk.usage
.ft P
.fi
.UNINDENT
.SS salt.modules.win_file
.sp
Manage information about files on the minion, set/read user, group
data
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
win32api
.IP \(bu 2
win32con
.IP \(bu 2
win32security
.IP \(bu 2
ntsecuritycon
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.chgrp(path, group)
Change the group of a file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.chgrp c:\etemp\etest.txt administrators
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.chown(path, user, group)
Chown a file, pass the file the desired user and group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.chown c:\etemp\etest.txt myusername administrators
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.get_gid(path)
Return the id of the group that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_gid c:\etemp\etest.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.get_group(path)
Return the group that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_group c:\etemp\etest.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.get_mode(path)
Return the mode of a file
.sp
Right now we\(aqre just returning 777
because Windows\(aq doesn\(aqt have a mode
like Linux
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_mode /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.get_uid(path)
Return the id of the user that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_uid c:\etemp\etest.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.get_user(path)
Return the user that owns a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.get_user c:\etemp\etest.txt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.gid_to_group(gid)
Convert the group id to the group name on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.gid_to_group S\-1\-5\-21\-626487655\-2533044672\-482107328\-1010
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.group_to_gid(group)
Convert the group to the gid on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.group_to_gid administrators
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.stats(path, hash_type=\(aqmd5\(aq, follow_symlink=False)
Return a dict containing the stats for a given file
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.stats /etc/passwd
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.uid_to_user(uid)
Convert a uid to a user name
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.uid_to_user S\-1\-5\-21\-626487655\-2533044672\-482107328\-1010
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_file.user_to_uid(user)
Convert user name to a uid
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq file.user_to_uid myusername
.ft P
.fi
.UNINDENT
.SS salt.modules.win_groupadd
.sp
Manage groups on Windows
.INDENT 0.0
.TP
.B salt.modules.win_groupadd.add(name, gid=None, system=False)
Add the specified group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.add foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_groupadd.delete(name)
Remove the named group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.delete foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_groupadd.getent(refresh=False)
Return info on all groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_groupadd.info(name)
Return information about a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq group.info foo
.ft P
.fi
.UNINDENT
.SS salt.modules.win_network
.sp
Module for gathering and managing network information
.INDENT 0.0
.TP
.B salt.modules.win_network.dig(host)
Performs a DNS lookup with dig
.sp
Note: dig must be installed on the Windows minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.dig archlinux.org
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.hwaddr(iface)
Return the hardware address (a.k.a. MAC address) for a given interface
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.hwaddr eth0
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.in_subnet(cidr)
Returns True if host is within specified subnet, otherwise False
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.in_subnet 10.0.0.0/16
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.interfaces()
Return a dictionary of information about all the interfaces on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.interfaces
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.ip_addrs(interface=None, include_loopback=False)
Returns a list of IPv4 addresses assigned to the host. 127.0.0.1 is
ignored, unless \(aqinclude_loopback=True\(aq is indicated. If \(aqinterface\(aq is
provided, then only IP addresses from that interface will be returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ip_addrs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.ip_addrs6(interface=None, include_loopback=False)
Returns a list of IPv6 addresses assigned to the host. ::1 is ignored,
unless \(aqinclude_loopback=True\(aq is indicated. If \(aqinterface\(aq is provided,
then only IP addresses from that interface will be returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ip_addrs6
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.netstat()
Return information on open ports and states
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.netstat
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.nslookup(host)
Query DNS for information about a domain or ip address
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.nslookup archlinux.org
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.ping(host)
Performs a ping to a host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.ping archlinux.org
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.subnets()
Returns a list of subnets to which the host belongs
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.subnets
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_network.traceroute(host)
Performs a traceroute to a 3rd party host
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq network.traceroute archlinux.org
.ft P
.fi
.UNINDENT
.SS salt.modules.win_pkg
.sp
A module to manage software on Windows
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
pythoncom
.IP \(bu 2
win32com
.IP \(bu 2
win32con
.IP \(bu 2
win32api
.IP \(bu 2
pywintypes
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.get_repo_data()
Returns the cached winrepo data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.get_repo_data
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.install(name=None, refresh=False, pkgs=None, **kwargs)
Install the passed package
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.install <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.list_available(*names)
Return a list of available versions of the specified package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_available <package name>
salt \(aq*\(aq pkg.list_available <package name01> <package name02>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
salt \(aq*\(aq pkg.list_pkgs versions_as_list=True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.list_upgrades(refresh=True)
List all available package upgrades on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.purge(name=None, pkgs=None, version=None, **kwargs)
Package purges are not supported, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.TP
.B version
The version of the package to be deleted. If this option is used in
combination with the \fBpkgs\fP option below, then this version will be
applied to all targeted packages.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.refresh_db()
Just recheck the repository and return a dict:
.sp
.nf
.ft C
{\(aq<database name>\(aq: Bool}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.remove(name=None, pkgs=None, version=None, **kwargs)
Remove packages.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.TP
.B version
The version of the package to be deleted. If this option is used in
combination with the \fBpkgs\fP option below, then this version will be
applied to all targeted packages.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.upgrade(refresh=True)
Run a full system upgrade
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_pkg.version(*names, **kwargs)
Returns a version if the package is installed, else returns an empty string
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
.ft P
.fi
.UNINDENT
.SS salt.modules.win_service
.sp
Windows Service module.
.INDENT 0.0
.TP
.B salt.modules.win_service.disable(name, **kwargs)
Disable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.disabled(name)
Check to see if the named service is disabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.disabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.enable(name, **kwargs)
Enable the named service to start at boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enable <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.enabled(name)
Check to see if the named service is enabled to start on boot
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.enabled <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.get_all()
Return all installed services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_all
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.get_disabled()
Return the disabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_disabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.get_enabled()
Return the enabled services
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_enabled
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.get_service_name(*args)
The Display Name is what is displayed in Windows when services.msc is
executed.  Each Display Name has an associated Service Name which is the
actual name of the service.  This function allows you to discover the
Service Name by returning a dictionary of Display Names and Service Names,
or filter by adding arguments of Display Names.
.sp
If no args are passed, return a dict of all services where the keys are the
service Display Names and the values are the Service Names.
.sp
If arguments are passed, create a dict of Display Names and Service Names
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.get_service_name

salt \(aq*\(aq service.get_service_name \(aqGoogle Update Service (gupdate)\(aq \(aqDHCP Client\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.getsid(name)
Return the sid for this windows service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.getsid <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.restart(name)
Restart the named service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.restart <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.start(name)
Start the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.start <service name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.status(name, sig=None)
Return the status for a service, returns the PID or an empty string if the
service is running or not, pass a signature to use to find the service via
ps
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.status <service name> [service signature]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_service.stop(name)
Stop the specified service
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq service.stop <service name>
.ft P
.fi
.UNINDENT
.SS salt.modules.win_shadow
.sp
Manage the shadow file
.INDENT 0.0
.TP
.B salt.modules.win_shadow.info(name)
Return information for the specified user
This is just returns dummy data so that salt states can work.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_shadow.set_password(name, password)
Set the password for a named user.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq shadow.set_password root mysecretpassword
.ft P
.fi
.UNINDENT
.SS salt.modules.win_status
.sp
Module for returning various status data about a minion.
These data can be useful for compiling into stats later.
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
pythoncom
.IP \(bu 2
wmi
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_status.procs()
Return the process data
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq status.procs
.ft P
.fi
.UNINDENT
.SS salt.modules.win_system
.sp
Support for reboot, shutdown, etc
.INDENT 0.0
.TP
.B salt.modules.win_system.halt(timeout=5)
Halt a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.halt
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_system.init(runlevel)
Change the system runlevel on sysV compatible systems
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.init 3
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_system.poweroff(timeout=5)
Poweroff a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.poweroff
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_system.reboot(timeout=5)
Reboot the system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.reboot
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_system.shutdown(timeout=5)
Shutdown a running system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.shutdown
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_system.shutdown_hard()
Shutdown a running system with no timeout or warning
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq system.shutdown_hard
.ft P
.fi
.UNINDENT
.SS salt.modules.win_useradd
.sp
Manage Windows users with the net user command
.sp
NOTE: This currently only works with local user accounts, not domain accounts
.INDENT 0.0
.TP
.B salt.modules.win_useradd.add(name, uid=None, gid=None, groups=None, home=False, shell=None, unique=False, system=False, fullname=False, roomnumber=False, workphone=False, homephone=False)
Add a user to the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.add name password
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.addgroup(name, group)
Add user to a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.addgroup username groupname
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.chfullname(name, fullname)
Change the full name of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chfullname user \(aqFirst Last\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.chgroups(name, groups, append=False)
Change the groups this user belongs to, add append to append the specified
groups
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chgroups foo wheel,root True
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.chhome(name, home)
Change the home directory of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chhome foo \e\efileserver\ehome\efoo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.chprofile(name, profile)
Change the profile directory of the user
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.chprofile foo \e\efileserver\eprofiles\efoo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.delete(name, purge=False, force=False)
Remove a user from the minion
NOTE: purge and force have not been implemented on Windows yet
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.delete name
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.getent()
Return the list of all info for all users
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.getent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.info(name)
Return user information
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.info root
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.list_groups(name)
Return a list of groups the named user belongs to
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.list_groups foo
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.removegroup(name, group)
Remove user from a group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.removegroup username groupname
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.win_useradd.setpassword(name, password)
Set a user\(aqs password
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq user.setpassword name password
.ft P
.fi
.UNINDENT
.SS salt.modules.xapi
.sp
This module (mostly) uses the XenAPI to manage Xen virtual machines.
.sp
Big fat warning: the XenAPI used in this file is the one bundled with
Xen Source, NOT XenServer nor Xen Cloud Platform. As a matter of fact it
\fIwill\fP fail under those platforms. From what I\(aqve read, little work is needed
to adapt this code to XS/XCP, mostly playing with XenAPI version, but as
XCP is not taking precedence on Xen Source on many platforms, please keep
compatibility in mind.
.sp
Useful documentation:
.sp
. \fI\%http://downloads.xen.org/Wiki/XenAPI/xenapi-1.0.6.pdf\fP
. \fI\%http://docs.vmd.citrix.com/XenServer/6.0.0/1.0/en_gb/api/\fP
. \fI\%https://github.com/xen-org/xen-api/tree/master/scripts/examples/python\fP
. \fI\%http://xenbits.xen.org/gitweb/?p=xen.git;a=tree;f=tools/python/xen/xm;hb=HEAD\fP
.INDENT 0.0
.TP
.B salt.modules.xapi.create(config_)
Start a defined domain
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.create <path to Xen cfg file>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.destroy(vm_)
Hard power down the virtual machine, this is equivalent to pulling the
power
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.destroy <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.freecpu()
Return an int representing the number of unallocated cpus on this
hypervisor
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.freecpu
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.freemem()
Return an int representing the amount of memory that has not been given
to virtual machines on this node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.freemem
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.full_info()
Return the node_info, vm_info and freemem
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.full_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.get_disks(vm_)
Return the disks of a named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_disks <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.get_macs(vm_)
Return a list off MAC addresses from the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_macs <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.get_nics(vm_)
Return info about the network interfaces of a named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.get_nics <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.is_hyper()
Returns a bool whether or not this node is a hypervisor of any kind
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.is_hyper
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.list_vms()
Return a list of virtual machine names on the minion
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.list_vms
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.migrate(vm_, target, live=1, port=0, node=\-1, ssl=None, change_home_server=0)
Migrates the virtual machine to another hypervisor
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.migrate <vm name> <target hypervisor> [live] [port] [node] [ssl] [change_home_server]
.ft P
.fi
.INDENT 7.0
.TP
.B Optional values:
.INDENT 7.0
.IP \(bu 2
live, use live migration
.IP \(bu 2
port, use a specified port
.IP \(bu 2
node, use specified NUMA node on target
.IP \(bu 2
ssl, use ssl connection for migration
.IP \(bu 2
change_home_server, change home server for managed domains
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.node_info()
Return a dict with information about this node
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.node_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.pause(vm_)
Pause the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.pause <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.reboot(vm_)
Reboot a domain via ACPI request
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.reboot <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.reset(vm_)
Reset a VM by emulating the reset button on a physical machine
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.reset <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.resume(vm_)
Resume the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.resume <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.setmem(vm_, memory)
Changes the amount of memory allocated to VM.
.sp
Memory is to be specified in MB
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.setmem myvm 768
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.setvcpus(vm_, vcpus)
Changes the amount of vcpus allocated to VM.
.sp
vcpus is an int representing the number to be assigned
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.setvcpus myvm 2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.shutdown(vm_)
Send a soft shutdown signal to the named vm
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.shutdown <vm name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.start(config_)
Alias for the obscurely named \(aqcreate\(aq function
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.start <path to Xen cfg file>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vcpu_pin(vm_, vcpu, cpus)
Set which CPUs a VCPU can use.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aqfoo\(aq virt.vcpu_pin domU\-id 2 1
salt \(aqfoo\(aq virt.vcpu_pin domU\-id 2 2\-6
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vm_cputime(vm_=None)
Return cputime used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqcputime\(aq <int>
        \(aqcputime_percent\(aq <int>
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_cputime
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vm_diskstats(vm_=None)
Return disk usage counters used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqio_read_kbs\(aq   : 0,
        \(aqio_write_kbs\(aq  : 0
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_diskstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vm_info(vm_=None)
Return detailed information about the vms.
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_info
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vm_netstats(vm_=None)
Return combined network counters used by the vms on this hyper in a
list of dicts:
.sp
.nf
.ft C
[
    \(aqyour\-vm\(aq: {
        \(aqio_read_kbs\(aq           : 0,
        \(aqio_total_read_kbs\(aq     : 0,
        \(aqio_total_write_kbs\(aq    : 0,
        \(aqio_write_kbs\(aq          : 0
        },
    ...
    ]
.ft P
.fi
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_netstats
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.xapi.vm_state(vm_=None)
Return list of all the vms and their state.
.sp
If you pass a VM name in as an argument then it will return info
for just the named VM, otherwise it will return all VMs.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq virt.vm_state <vm name>
.ft P
.fi
.UNINDENT
.SS salt.modules.yumpkg5
.sp
Support for YUM
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.install(name=None, refresh=False, fromrepo=None, skip_verify=False, pkgs=None, sources=None, **kwargs)
Install the passed package(s), add refresh=True to clean the yum database
before package is installed.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to install packages from a
software repository. To install a package file manually, use the
"sources" option.
.sp
32\-bit packages can be installed on 64\-bit systems by appending
\fB.i686\fP to the end of the package name.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to update the yum database before executing.
.TP
.B skip_verify
Skip the GPG verification check (e.g., \fB\-\-nogpgcheck\fP)
.TP
.B version
Install a specific version of the package, e.g. 1.2.3\-4.el5. Ignored
if "pkgs" or "sources" is passed.
.UNINDENT
.sp
Repository Options:
.INDENT 7.0
.TP
.B fromrepo
Specify a package repository (or repositories) from which to install.
(e.g., \fByum \-\-disablerepo=\(aq*\(aq \-\-enablerepo=\(aqsomerepo\(aq\fP)
.TP
.B enablerepo (ignored if \fBfromrepo\fP is specified)
Specify a disabled package repository (or repositories) to enable.
(e.g., \fByum \-\-enablerepo=\(aqsomerepo\(aq\fP)
.TP
.B disablerepo (ignored if \fBfromrepo\fP is specified)
Specify an enabled package repository (or repositories) to disable.
(e.g., \fByum \-\-disablerepo=\(aqsomerepo\(aq\fP)
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list. A specific version number can be specified
by using a single\-element dict representing the package and its
version.
.INDENT 7.0
.TP
.B CLI Examples::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3\-4.el5"}]\(aq
.UNINDENT
.TP
.B sources
A list of RPM packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.rpm"}, {"bar": "salt://bar.rpm"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
A specific repo can be requested using the \fBfromrepo\fP keyword argument.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package name> fromrepo=epel\-testing
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.list_upgrades(refresh=True, **kwargs)
Check whether or not an upgrade is available for all packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported by yum, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.refresh_db()
Since yum refreshes the database automatically, this runs a yum clean,
so that the next yum operation will have a clean database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.remove(name=None, pkgs=None, **kwargs)
Remove packages with \fByum \-q \-y remove\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.upgrade(refresh=True)
Run a full system upgrade, a yum upgrade
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg5.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.yumpkg
.sp
New in version 0.9.4: This module replaces the "yum" module in previous releases. It is backward
compatible and uses the native yum Python interface instead of the CLI
interface.
.sp
Support for YUM
.INDENT 0.0
.TP
.B depends
.INDENT 7.0
.IP \(bu 2
yum Python module
.IP \(bu 2
rpmUtils Python module
.UNINDENT
.UNINDENT
.sp
This module uses the python interface to YUM. Note that with a default
/etc/yum.conf, this will cause messages to be sent to sent to syslog on
/dev/log, with a log facility of \fBLOG_USER\fP. This is in addition to
whatever is logged to /var/log/yum.log. See the manpage for \fByum.conf(5)\fP for
information on how to use the \fBsyslog_facility\fP and \fBsyslog_device\fP config
parameters to configure how syslog is handled, or take the above defaults into
account when configuring your syslog daemon.
.INDENT 0.0
.TP
.B salt.modules.yumpkg.clean_metadata()
Cleans local yum metadata.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.clean_metadata
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.del_repo(repo, basedir=\(aq/etc/yum.repos.d\(aq, **kwargs)
Delete a repo from <basedir> (default basedir: /etc/yum.repos.d).
.sp
If the .repo file that the repo exists in does not contain any other repo
configuration, the file itself will be deleted.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.del_repo myrepo
salt \(aq*\(aq pkg.del_repo myrepo basedir=/path/to/dir
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.expand_repo_def(repokwargs)
Take a repository definition and expand it to the full pkg repository dict
that can be used for comparison.  This is a helper function to make
certain repo managers sane for comparison in the pkgrepo states.
.sp
There is no use to calling this function via the CLI.
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.file_dict(*packages)
List the files that belong to a package, grouped by package. Not
specifying any packages will return a list of _every_ file on the system\(aqs
rpm database (not generally recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.file_list(*packages)
List the files that belong to a package. Not specifying any packages will
return a list of _every_ file on the system\(aqs rpm database (not generally
recommended).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.file_list httpd
salt \(aq*\(aq pkg.file_list httpd postfix
salt \(aq*\(aq pkg.file_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.get_repo(repo, basedir=\(aq/etc/yum.repos.d\(aq, **kwargs)
Display a repo from <basedir> (default basedir: /etc/yum.repos.d).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.get_repo myrepo
salt \(aq*\(aq pkg.get_repo myrepo basedir=/path/to/dir
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.group_diff(groupname)
Lists packages belonging to a certain group, and which are installed
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_diff \(aqPerl Support\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.group_info(groupname)
Lists packages belonging to a certain group
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_info \(aqPerl Support\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.group_install(name=None, groups=None, skip=None, include=None, **kwargs)
Install the passed package group(s). This is basically a wrapper around
pkg.install, which performs package group resolution for the user. This
function is currently considered "experimental", and should be expected to
undergo changes before it becomes official.
.INDENT 7.0
.TP
.B name
The name of a single package group to install. Note that this option is
ignored if "groups" is passed.
.TP
.B groups
The names of multiple packages which are to be installed.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_install groups=\(aq["Group 1", "Group 2"]\(aq
.ft P
.fi
.TP
.B skip
The name(s), in a list, of any packages that would normally be
installed by the package group ("default" packages), which should not
be installed.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_install \(aqMy Group\(aq skip=\(aq["foo", "bar"]\(aq
.ft P
.fi
.TP
.B include
The name(s), in a list, of any packages which are included in a group,
which would not normally be installed ("optional" packages). Note that
this will nor enforce group membership; if you include packages which
are not members of the specified groups, they will still be installed.
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_install \(aqMy Group\(aq include=\(aq["foo", "bar"]\(aq
.ft P
.fi
.TP
.B other arguments
Because this is essentially a wrapper around pkg.install, any argument
which can be passed to pkg.install may also be included here, and it
will be passed along wholesale.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.group_list()
Lists all groups known by yum on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.group_list
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.install(name=None, refresh=False, skip_verify=False, pkgs=None, sources=None, **kwargs)
Install the passed package(s), add refresh=True to clean the yum database
before package is installed.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to install packages from a
software repository. To install a package file manually, use the
"sources" option.
.sp
32\-bit packages can be installed on 64\-bit systems by appending
\fB.i686\fP to the end of the package name.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to update the yum database before executing.
.TP
.B skip_verify
Skip the GPG verification check. (e.g., \fB\-\-nogpgcheck\fP)
.TP
.B version
Install a specific version of the package, e.g. 1.2.3\-4.el6. Ignored
if "pkgs" or "sources" is passed.
.UNINDENT
.sp
Repository Options:
.INDENT 7.0
.TP
.B fromrepo
Specify a package repository (or repositories) from which to install.
(e.g., \fByum \-\-disablerepo=\(aq*\(aq \-\-enablerepo=\(aqsomerepo\(aq\fP)
.TP
.B enablerepo
Specify a disabled package repository (or repositories) to enable.
(e.g., \fByum \-\-enablerepo=\(aqsomerepo\(aq\fP)
.TP
.B disablerepo
Specify an enabled package repository (or repositories) to disable.
(e.g., \fByum \-\-disablerepo=\(aqsomerepo\(aq\fP)
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list. A specific version number can be specified
by using a single\-element dict representing the package and its
version.
.INDENT 7.0
.TP
.B CLI Examples::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3\-4.el6"}]\(aq
.UNINDENT
.TP
.B sources
A list of RPM packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.rpm"}, {"bar": "salt://bar.rpm"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
A specific repo can be requested using the \fBfromrepo\fP keyword argument.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package name> fromrepo=epel\-testing
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed in a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.list_repos(basedir=\(aq/etc/yum.repos.d\(aq)
Lists all repos in <basedir> (default: /etc/yum.repos.d/).
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_repos
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.list_upgrades(refresh=True)
Check whether or not an upgrade is available for all packages
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.mod_repo(repo, basedir=None, **kwargs)
Modify one or more values for a repo. If the repo does not exist, it will
be created, so long as the following values are specified:
.sp
.nf
.ft C
repo (name by which the yum refers to the repo)
name (a human\-readable name for the repo)
baseurl or mirrorlist (the URL for yum to reference)
.ft P
.fi
.sp
Key/Value pairs may also be removed from a repo\(aqs configuration by setting
a key to a blank value. Bear in mind that a name cannot be deleted, and a
baseurl can only be deleted if a mirrorlist is specified (or vice versa).
.sp
CLI Examples:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.mod_repo reponame enabled=1 gpgcheck=1
salt \(aq*\(aq pkg.mod_repo reponame basedir=/path/to/dir enabled=1
salt \(aq*\(aq pkg.mod_repo reponame baseurl= mirrorlist=http://host.com/
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.purge(name=None, pkgs=None, **kwargs)
Package purges are not supported by yum, this function is identical to
\fBremove()\fP.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.refresh_db()
Since yum refreshes the database automatically, this runs a yum clean,
so that the next yum operation will have a clean database
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.remove(name=None, pkgs=None, **kwargs)
Removes packages using python API for yum.
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.upgrade(refresh=True)
Run a full system upgrade, a yum upgrade
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.verify(*package)
Runs an rpm \-Va on a system, and returns the results in a dict
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.verify
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.yumpkg.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SS salt.modules.zfs
.sp
Module for running ZFS command
.SS salt.modules.zpool
.sp
Module for running ZFS zpool command
.INDENT 0.0
.TP
.B salt.modules.zpool.add(pool_name, vdev)
Add the specified vdev to the given pool
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.add myzpool /path/to/vdev
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.create(pool_name, *vdevs)
Create a new storage pool
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.create myzpool /path/to/vdev1 [/path/to/vdev2] [...]
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.create_file_vdev(size, *vdevs)
Creates file based \fBvirtual devices\fP for a zpool
.sp
\fB*vdevs\fP is a list of full paths for mkfile to create
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.create_file_vdev 7g /path/to/vdev1 [/path/to/vdev2] [...]

Depending on file size this may take a while to return
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.destroy(pool_name)
Destroys a storage pool
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.destroy myzpool
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.exists(pool_name)
Check if a ZFS storage pool is active
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.exists myzpool
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.iostat(name=\(aq\(aq)
Display I/O statistics for the given pools
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.iostat
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.replace(pool_name, old, new)
Replaces old device with new device.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.replace myzpool /path/to/vdev1 /path/to/vdev2
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.scrub(pool_name=None)
Begin a scrub
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.scrub myzpool
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.status(name=\(aq\(aq)
Return the status of the named zpool
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.status
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zpool.zpool_list()
Return a list of all pools in the system with health status and space usage
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq zpool.zpool_list
.ft P
.fi
.UNINDENT
.SS salt.modules.zypper
.sp
Package support for openSUSE via the zypper package manager
.INDENT 0.0
.TP
.B salt.modules.zypper.compare(pkg1=\(aq\(aq, oper=\(aq==\(aq, pkg2=\(aq\(aq)
Compare two version strings.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.compare \(aq0.2.4\-0\(aq \(aq<\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.compare pkg1=\(aq0.2.4\-0\(aq oper=\(aq<\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.install(name=None, refresh=False, pkgs=None, sources=None, **kwargs)
Install the passed package(s), add refresh=True to run \(aqzypper refresh\(aq
before package is installed.
.INDENT 7.0
.TP
.B name
The name of the package to be installed. Note that this parameter is
ignored if either "pkgs" or "sources" is passed. Additionally, please
note that this option can only be used to install packages from a
software repository. To install a package file manually, use the
"sources" option.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install <package name>
.UNINDENT
.TP
.B refresh
Whether or not to refresh the package database before installing.
.TP
.B version
Can be either a version number, or the combination of a comparison
operator (<, >, <=, >=, =) and a version number (ex. \(aq>1.2.3\-4\(aq).
This parameter is ignored if "pkgs" or "sources" is passed.
.UNINDENT
.sp
Multiple Package Installation Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository. Must be
passed as a python list. A specific version number can be specified
by using a single\-element dict representing the package and its
version. As with the \fBversion\fP parameter above, comparison operators
can be used to target a specific version of a package.
.INDENT 7.0
.TP
.B CLI Examples::
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", "bar"]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "1.2.3\-4"}]\(aq
salt \(aq*\(aq pkg.install pkgs=\(aq["foo", {"bar": "<1.2.3\-4"}]\(aq
.UNINDENT
.TP
.B sources
A list of RPM packages to install. Must be passed as a list of dicts,
with the keys being package names, and the values being the source URI
or local path to the package.
.INDENT 7.0
.TP
.B CLI Example::
salt \(aq*\(aq pkg.install sources=\(aq[{"foo": "salt://foo.rpm"},{"bar": "salt://bar.rpm"}]\(aq
.UNINDENT
.UNINDENT
.sp
Returns a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.latest_version(*names, **kwargs)
Return the latest version of the named package available for upgrade or
installation. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
If the latest version of a given package is already installed, an empty
string will be returned for that package.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.latest_version <package name>
salt \(aq*\(aq pkg.latest_version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.list_pkgs(versions_as_list=False, **kwargs)
List the packages currently installed as a dict:
.sp
.nf
.ft C
{\(aq<package_name>\(aq: \(aq<version>\(aq}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_pkgs
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.list_upgrades(refresh=True)
List all available package upgrades on this system
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.list_upgrades
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.perform_cmp(pkg1=\(aq\(aq, pkg2=\(aq\(aq)
Do a cmp\-style comparison on two packages. Return \-1 if pkg1 < pkg2, 0 if
pkg1 == pkg2, and 1 if pkg1 > pkg2. Return None if there was a problem
making the comparison.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.perform_cmp \(aq0.2.4\-0\(aq \(aq0.2.4.1\-0\(aq
salt \(aq*\(aq pkg.perform_cmp pkg1=\(aq0.2.4\-0\(aq pkg2=\(aq0.2.4.1\-0\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.purge(name=None, pkgs=None, **kwargs)
Recursively remove a package and all dependencies which were installed
with it, this will call a \fBzypper \-n remove \-u\fP
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.purge <package name>
salt \(aq*\(aq pkg.purge <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.purge pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.refresh_db()
Just run a \fBzypper refresh\fP, return a dict:
.sp
.nf
.ft C
{\(aq<database name>\(aq: Bool}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.remove(name=None, pkgs=None, **kwargs)
Remove packages with \fBzypper \-n remove\fP
.INDENT 7.0
.TP
.B name
The name of the package to be deleted.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to delete. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.sp
Returns a dict containing the changes.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.remove <package name>
salt \(aq*\(aq pkg.remove <package1>,<package2>,<package3>
salt \(aq*\(aq pkg.remove pkgs=\(aq["foo", "bar"]\(aq
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.upgrade(refresh=True)
Run a full system upgrade, a zypper upgrade
.sp
Return a dict containing the new package names and versions:
.sp
.nf
.ft C
{\(aq<package>\(aq: {\(aqold\(aq: \(aq<old\-version>\(aq,
               \(aqnew\(aq: \(aq<new\-version>\(aq}}
.ft P
.fi
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.upgrade_available(name)
Check whether or not an upgrade is available for a given package
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.upgrade_available <package name>
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.modules.zypper.version(*names, **kwargs)
Returns a string representing the package version or an empty string if not
installed. If more than one package name is specified, a dict of
name/version pairs is returned.
.sp
CLI Example:
.sp
.nf
.ft C
salt \(aq*\(aq pkg.version <package name>
salt \(aq*\(aq pkg.version <package1> <package2> <package3> ...
.ft P
.fi
.UNINDENT
.SH RETURNERS
.sp
By default the return values of the commands sent to the Salt minions are
returned to the salt\-master. But since the commands executed on the Salt
minions are detached from the call on the Salt master, there is no need for
the minion to return the data to the Salt master.
.sp
This is where the returner interface comes in. Returners are modules called
in place of returning the data to the Salt master.
.sp
The returner interface allows the return data to be sent to any system that
can receive data. This means that return data can be sent to a Redis server,
a MongoDB server, a MySQL server, or any system!
.IP "See also"
.sp
\fIFull list of builtin returners\fP
.RE
.SS Using Returners
.sp
All commands will return the command data back to the master. Adding more
returners will ensure that the data is also sent to the specified returner
interfaces.
.sp
Specifying what returners to use is done when the command is invoked:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping \-\-return redis_return
.ft P
.fi
.sp
This command will ensure that the redis_return returner is used.
.sp
It is also possible to specify multiple returners:
.sp
.nf
.ft C
salt \(aq*\(aq test.ping \-\-return mongo_return,redis_return,cassandra_return
.ft P
.fi
.sp
In this scenario all three returners will be called and the data from the
test.ping command will be sent out to the three named returners.
.SS Writing a Returner
.sp
A returner is a module which contains a returner function, the returner
function must accept a single argument. this argument is the return data from
the called minion function. So if the minion function \fBtest.ping\fP is called
the value of the argument will be \fBTrue\fP.
.sp
A simple returner is implemented here:
.sp
.nf
.ft C
import redis
import json

def returner(ret):
    \(aq\(aq\(aq
    Return information to a redis server
    \(aq\(aq\(aq
    # Get a redis connection
    serv = redis.Redis(
                host=\(aqredis\-serv.example.com\(aq,
                port=6379,
                db=\(aq0\(aq)
    serv.sadd("%(id)s:jobs" % ret, ret[\(aqjid\(aq])
    serv.set("%(jid)s:%(id)s" % ret, json.dumps(ret[\(aqreturn\(aq]))
    serv.sadd(\(aqjobs\(aq, ret[\(aqjid\(aq])
    serv.sadd(ret[\(aqjid\(aq], ret[\(aqid\(aq])
.ft P
.fi
.sp
This simple example of a returner set to send the data to a redis server
serializes the data as json and sets it in redis.
.sp
You can place your custom returners in a \fB_returners\fP directory within the
\fBfile_roots\fP specified by the master config file. These custom
returners are distributed when \fI\%state.highstate\fP is run, or by executing the
\fI\%saltutil.sync_returners\fP or \fI\%saltutil.sync_all\fP functions.
.SS Examples
.sp
The collection of built\-in Salt returners can be found here:
\fI\%https://github.com/saltstack/salt/blob/develop/salt/returners\fP
.SH FULL LIST OF BUILTIN RETURNER MODULES
.TS
center;
|l|l|.
_
T{
\fBcarbon_return\fP
T}	T{
Take data from salt and "return" it into a carbon receiver
T}
_
T{
\fBcassandra_return\fP
T}	T{
Return data to a Cassandra ColumnFamily
T}
_
T{
\fBlocal\fP
T}	T{
The local returner is used to test the returner interface, it just prints the
T}
_
T{
\fBmongo_future_return\fP
T}	T{
Return data to a mongodb server
T}
_
T{
\fBmongo_return\fP
T}	T{
Return data to a mongodb server
T}
_
T{
\fBmysql\fP
T}	T{
Return data to a mysql server
T}
_
T{
\fBpostgres\fP
T}	T{
Return data to a postgresql server
T}
_
T{
\fBredis_return\fP
T}	T{
Return data to a redis server
T}
_
T{
\fBsentry_return\fP
T}	T{
Salt returner that report error back to sentry
T}
_
T{
\fBsmtp_return\fP
T}	T{
Return salt data via email
T}
_
T{
\fBsyslog_return\fP
T}	T{
Return data to the host operating system\(aqs syslog facility
T}
_
.TE
.SS salt.returners.carbon_return
.sp
Take data from salt and "return" it into a carbon receiver
.sp
Add the following configuration to your minion configuration files:
.sp
.nf
.ft C
carbon.host: <server ip address>
carbon.port: 2003
.ft P
.fi
.INDENT 0.0
.TP
.B salt.returners.carbon_return.returner(ret)
Return data to a remote carbon server using the text metric protocol
.UNINDENT
.SS salt.returners.cassandra_return
.sp
Return data to a Cassandra ColumnFamily
.sp
Here\(aqs an example Keyspace / ColumnFamily setup that works with this
returner:
.sp
.nf
.ft C
create keyspace salt;
use salt;
create column family returns
  with key_validation_class=\(aqUTF8Type\(aq
  and comparator=\(aqUTF8Type\(aq
  and default_validation_class=\(aqUTF8Type\(aq;
.ft P
.fi
.sp
Required python modules: pycassa
.INDENT 0.0
.TP
.B salt.returners.cassandra_return.returner(ret)
Return data to a Cassandra ColumnFamily
.UNINDENT
.SS salt.returners.local
.sp
The local returner is used to test the returner interface, it just prints the
return data to the console to verify that it is being passed properly
.INDENT 0.0
.TP
.B salt.returners.local.returner(ret)
Print the return data to the terminal to verify functionality
.UNINDENT
.SS salt.returners.mongo_future_return
.sp
Return data to a mongodb server
.sp
Required python modules: pymongo
.sp
This returner will send data from the minions to a MongoDB server. To
configure the settings for your MongoDB server, add the following lines
to the minion config files:
.sp
.nf
.ft C
mongo.db: <database name>
mongo.host: <server ip address>
mongo.user: <MongoDB username>
mongo.password: <MongoDB user password>
mongo.port: 27017
.ft P
.fi
.sp
This mongo returner is being developed to replace the default mongodb returner
in the future and should not be considered API stable yet.
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.get_fun(fun)
Return the most recent jobs that have executed the named function
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.get_jid(jid)
Return the return information associated with a jid
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.get_jids()
Return a list of job ids
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.get_load(jid)
Return the load associated with a given job id
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.get_minions()
Return a list of minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.returner(ret)
Return data to a mongodb server
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_future_return.save_load(jid, load)
Save the load for a given job id
.UNINDENT
.SS salt.returners.mongo_return
.sp
Return data to a mongodb server
.sp
Required python modules: pymongo
.sp
This returner will send data from the minions to a MongoDB server. To
configure the settings for your MongoDB server, add the following lines
to the minion config files:
.sp
.nf
.ft C
mongo.db: <database name>
mongo.host: <server ip address>
mongo.user: <MongoDB username>
mongo.password: <MongoDB user password>
mongo.port: 27017
.ft P
.fi
.INDENT 0.0
.TP
.B salt.returners.mongo_return.get_fun(fun)
Return the most recent jobs that have executed the named function
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_return.get_jid(jid)
Return the return information associated with a jid
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mongo_return.returner(ret)
Return data to a mongodb server
.UNINDENT
.SS salt.returners.mysql
.sp
Return data to a mysql server
.INDENT 0.0
.TP
.B maintainer
Dave Boucha <\fI\%dave@saltstack.com\fP>, Seth House <\fI\%shouse@saltstack.com\fP>
.TP
.B maturity
new
.TP
.B depends
python\-mysqldb
.TP
.B platform
all
.UNINDENT
.sp
To enable this returner the minion will need the python client for mysql
installed and the following values configured in the minion or master
config, these are the defaults:
.sp
.nf
.ft C
mysql.host: \(aqsalt\(aq
mysql.user: \(aqsalt\(aq
mysql.pass: \(aqsalt\(aq
mysql.db: \(aqsalt\(aq
mysql.port: 3306
.ft P
.fi
.sp
Use the following mysql database schema:
.sp
.nf
.ft C
CREATE DATABASE  \(gasalt\(ga
  DEFAULT CHARACTER SET utf8
  DEFAULT COLLATE utf8_general_ci;

USE \(gasalt\(ga;

\-\-
\-\- Table structure for table \(gajids\(ga
\-\-

DROP TABLE IF EXISTS \(gajids\(ga;
CREATE TABLE \(gajids\(ga (
  \(gajid\(ga varchar(255) NOT NULL,
  \(gaload\(ga mediumtext NOT NULL,
  UNIQUE KEY \(gajid\(ga (\(gajid\(ga)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

\-\-
\-\- Table structure for table \(gasalt_returns\(ga
\-\-

DROP TABLE IF EXISTS \(gasalt_returns\(ga;
CREATE TABLE \(gasalt_returns\(ga (
  \(gafun\(ga varchar(50) NOT NULL,
  \(gajid\(ga varchar(255) NOT NULL,
  \(gareturn\(ga mediumtext NOT NULL,
  \(gaid\(ga varchar(255) NOT NULL,
  \(gasuccess\(ga varchar(10) NOT NULL,
  \(gafull_ret\(ga mediumtext NOT NULL,
  KEY \(gaid\(ga (\(gaid\(ga),
  KEY \(gajid\(ga (\(gajid\(ga),
  KEY \(gafun\(ga (\(gafun\(ga)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
.ft P
.fi
.sp
Required python modules: MySQLdb
.INDENT 0.0
.TP
.B salt.returners.mysql.get_fun(fun)
Return a dict of the last function called for all minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.get_jid(jid)
Return the information returned when the specified job id was executed
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.get_jids()
Return a list of all job ids
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.get_load(jid)
Return the load data that marks a specified jid
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.get_minions()
Return a list of minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.returner(ret)
Return data to a mysql server
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.mysql.save_load(jid, load)
Save the load to the specified jid id
.UNINDENT
.SS salt.returners.postgres
.sp
Return data to a postgresql server
.INDENT 0.0
.TP
.B maintainer
None
.TP
.B maturity
New
.TP
.B depends
psycopg2
.TP
.B platform
all
.UNINDENT
.sp
To enable this returner the minion will need the psycopg2 installed and
the following values configured in the minion or master config:
.sp
.nf
.ft C
returner.postgres.host: \(aqsalt\(aq
returner.postgres.user: \(aqsalt\(aq
returner.postgres.passwd: \(aqsalt\(aq
returner.postgres.db: \(aqsalt\(aq
returner.postgres.port: 5432
.ft P
.fi
.sp
Running the following commands as the postgres user should create the database
correctly:
.sp
.nf
.ft C
psql << EOF
CREATE ROLE salt WITH PASSWORD \(aqsalt\(aq;
CREATE DATABASE salt WITH OWNER salt;
EOF

psql \-h localhost \-U salt << EOF
\-\-
\-\- Table structure for table \(aqjids\(aq
\-\-

DROP TABLE IF EXISTS jids;
CREATE TABLE jids (
  jid   bigint PRIMARY KEY,
  load  text NOT NULL
);

\-\-
\-\- Table structure for table \(aqsalt_returns\(aq
\-\-

DROP TABLE IF EXISTS salt_returns;
CREATE TABLE salt_returns (
  fun       text NOT NULL,
  jid       varchar(20) NOT NULL,
  return    text NOT NULL,
  id        text NOT NULL,
  success   boolean
);
CREATE INDEX ON salt_returns (id);
CREATE INDEX ON salt_returns (jid);
CREATE INDEX ON salt_returns (fun);
.ft P
.fi
.sp
Required python modules: psycopg2
.INDENT 0.0
.TP
.B salt.returners.postgres.get_fun(fun)
Return a dict of the last function called for all minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.get_jid(jid)
Return the information returned when the specified job id was executed
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.get_jids()
Return a list of all job ids
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.get_load(jid)
Return the load data that marks a specified jid
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.get_minions()
Return a list of minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.returner(ret)
Return data to a postgres server
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.postgres.save_load(jid, load)
Save the load to the specified jid id
.UNINDENT
.SS salt.returners.redis_return
.sp
Return data to a redis server
.sp
To enable this returner the minion will need the python client for redis
installed and the following values configured in the minion or master
config, these are the defaults:
.INDENT 0.0
.INDENT 3.5
redis.db: \(aq0\(aq
redis.host: \(aqsalt\(aq
redis.port: 6379
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.get_fun(fun)
Return a dict of the last function called for all minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.get_jid(jid)
Return the information returned when the specified job id was executed
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.get_jids()
Return a list of all job ids
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.get_load(jid)
Return the load data that marks a specified jid
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.get_minions()
Return a list of minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.returner(ret)
Return data to a redis data store
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.redis_return.save_load(jid, load)
Save the load to the specified jid
.UNINDENT
.SS salt.returners.sentry_return
.sp
Salt returner that report error back to sentry
.sp
Pillar need something like:
.sp
.nf
.ft C
raven:
  servers:
    \- http://192.168.1.1
    \- https://sentry.example.com
  public_key: deadbeefdeadbeefdeadbeefdeadbeef
  secret_key: beefdeadbeefdeadbeefdeadbeefdead
  project: 1
.ft P
.fi
.sp
and \fI\%http://pypi.python.org/pypi/raven\fP installed
.INDENT 0.0
.TP
.B salt.returners.sentry_return.returner(ret)
If an error occurs, log it to sentry
.UNINDENT
.SS salt.returners.smtp_return
.sp
Return salt data via email
.sp
The following fields can be set in the minion conf file:
.INDENT 0.0
.INDENT 3.5
smtp.from (required)
smtp.to (required)
smtp.host (required)
smtp.username (optional)
smtp.password (optional)
smtp.tls (optional, defaults to False)
smtp.subject (optional, but helpful)
smtp.fields (optional)
.UNINDENT
.UNINDENT
.sp
There are a few things to keep in mind:
.INDENT 0.0
.IP \(bu 2
If a username is used, a password is also required.
.IP \(bu 2
You should at least declare a subject, but you don\(aqt have to.
.IP \(bu 2
smtp.fields lets you include the value(s) of various fields in the subject
line of the email. These are comma\-delimited. For instance:
.INDENT 2.0
.INDENT 3.5
smtp.fields: id,fun
.UNINDENT
.UNINDENT
.sp
...will display the id of the minion and the name of the function in the
subject line. You may also use \(aqjid\(aq (the job id), but it is generally
recommended not to use \(aqreturn\(aq, which contains the entire return data
structure (which can be very large).
.UNINDENT
.INDENT 0.0
.TP
.B salt.returners.smtp_return.returner(ret)
Send an email with the data
.UNINDENT
.SS salt.returners.syslog_return
.sp
Return data to the host operating system\(aqs syslog facility
.sp
Required python modules: syslog, json
.sp
The syslog returner simply reuses the operating system\(aqs syslog
facility to log return data
.INDENT 0.0
.TP
.B salt.returners.syslog_return.returner(ret)
Return data to the local syslog
.UNINDENT
.SH STATE FILE BACKUPS
.sp
In 0.10.2 a new feature was added for backing up files that are replaced by
the file.managed and file.recurse states. The new feature is called the backup
mode. Setting the backup mode is easy, but is can be set in a number of
places.
.sp
The backup_mode can be set in the minion config file:
.sp
.nf
.ft C
backup_mode: minion
.ft P
.fi
.sp
Or it can be set for each file:
.sp
.nf
.ft C
/etc/ssh/sshd_config:
  file.managed:
    \- source: salt://ssh/sshd_config
    \- backup: minion
.ft P
.fi
.SS Backed up Files
.sp
The files will be saved in the minion cachedir under the directory named
\fBfile_backup\fP. The files will be in the location relative to where they
were under the root filesystem and be appended with a timestamp. This should
make them easy to browse.
.SH EXTENDING EXTERNAL SLS DATA
.sp
Sometimes a state defined in one SLS file will need to be modified from a
separate SLS file. A good example of this is when an argument needs to be
overwritten or when a service needs to watch an additional state.
.SS The Extend Declaration
.sp
The standard way to extend is via the extend declaration. The extend
declaration is a top level declaration like \fBinclude\fP and encapsulates ID
declaration data included from other SLS files. A standard extend looks like
this:
.sp
.nf
.ft C
include:
  \- http
  \- ssh

extend:
  apache:
    file:
      \- name: /etc/httpd/conf/httpd.conf
      \- source: salt://http/httpd2.conf
  ssh\-server:
    service:
      \- watch:
        \- file: /etc/ssh/banner

/etc/ssh/banner:
  file.managed:
    \- source: salt://ssh/banner
.ft P
.fi
.sp
A few critical things happened here, first off the SLS files that are going to
be extended are included, then the extend dec is defined. Under the extend dec
2 IDs are extended, the apache ID\(aqs file state is overwritten with a new name
and source. Than the ssh server is extended to watch the banner file in
addition to anything it is already watching.
.SS Extend is a Top Level Declaration
.sp
This means that \fBextend\fP can only be called once in an sls, if if is used
twice then only one of the extend blocks will be read. So this is WRONG:
.sp
.nf
.ft C
include:
  \- http
  \- ssh

extend:
  apache:
    file:
      \- name: /etc/httpd/conf/httpd.conf
      \- source: salt://http/httpd2.conf
# Second extend will overwrite the first!! Only make one
extend:
  ssh\-server:
    service:
      \- watch:
        \- file: /etc/ssh/banner
.ft P
.fi
.SS The Requisite "in" Statement
.sp
Since one of the most common things to do when extending another SLS is to add
states for a service to watch, or anything for a watcher to watch, the
requisite in statement was added to 0.9.8 to make extending the watch and
require lists easier. The ssh\-server extend statement above could be more
cleanly defined like so:
.sp
.nf
.ft C
include:
  \- ssh

/etc/ssh/banner:
  file.managed:
    \- source: salt://ssh/banner
    \- watch_in:
      \- service: ssh\-server
.ft P
.fi
.SS Rules to Extend By
.sp
There are a few rules to remember when extending states:
.INDENT 0.0
.IP 1. 3
Always include the SLS being extended with an include declaration
.IP 2. 3
Requisites (watch and require) are appended to, everything else is
overwritten
.IP 3. 3
extend is a top level declaration, like an ID declaration, cannot be
declared twice in a single SLS
.IP 4. 3
Many IDs can be extended under the extend declaration
.UNINDENT
.SH FAILHARD GLOBAL OPTION
.sp
Normally, when a state fails Salt continues to execute the remainder of the
defined states and will only refuse to execute states that require the failed
state.
.sp
But the situation may exist, where you would want all state execution to stop
if a single state execution fails. The capability to do this is called
\fBfailing hard\fP.
.SS State Level Failhard
.sp
A single state can have a failhard set, this means that if this individual
state fails that all state execution will immediately stop. This is a great
thing to do if there is a state that sets up a critical config file and
setting a require for each state that reads the config would be cumbersome.
A good example of this would be setting up a package manager early on:
.sp
.nf
.ft C
/etc/yum.repos.d/company.repo:
  file.managed:
    \- source: salt://company/yumrepo.conf
    \- user: root
    \- group: root
    \- mode: 644
    \- order: 1
    \- failhard: True
.ft P
.fi
.sp
In this situation, the yum repo is going to be configured before other states,
and if it fails to lay down the config file, than no other states will be
executed.
.SS Global Failhard
.sp
It may be desired to have failhard be applied to every state that is executed,
if this is the case, then failhard can be set in the master configuration
file. Setting failhard in the master configuration file will result in failing
hard when any minion gathering states from the master have a state fail.
.sp
This is NOT the default behavior, normally Salt will only fail states that
require a failed state.
.sp
Using the global failhard is generally not recommended, since it can result
in states not being executed or even checked. It can also be confusing to
see states failhard if an admin is not actively aware that the failhard has
been set.
.sp
To use the global failhard set failhard: True in the master configuration
file.
.SH HIGHSTATE DATA STRUCTURE DEFINITIONS
.SS The Salt State Tree
.INDENT 0.0
.TP
.B Top file
The main state file that instructs minions what environment and modules
to use during state execution.
.sp
Configurable via \fBstate_top\fP.
.IP "See also"
.sp
\fBA detailed description of the top file\fP
.RE
.UNINDENT
.INDENT 0.0
.TP
.B State tree
A collection of \fBSLS\fP files that live under the directory specified
in \fBfile_roots\fP. A state tree can be organized into
\fBSLS modules\fP.
.UNINDENT
.SS Include declaration
.INDENT 0.0
.TP
.B Include declaration
Defines a list of \fImodule reference\fP strings to include in this
\fISLS\fP.
.sp
Occurs only in the top level of the highstate structure.
.UNINDENT
.sp
Example:
.sp
.nf
.ft C
include:
  \- edit.vim
  \- http.server
.ft P
.fi
.SS Module reference
.INDENT 0.0
.TP
.B Module reference
The name of a SLS module defined by a separate SLS file and residing on
the Salt Master. A module named \fBedit.vim\fP is a reference to the SLS
file \fBsalt://edit/vim.sls\fP.
.UNINDENT
.SS ID declaration
.INDENT 0.0
.TP
.B ID declaration
Defines an individual highstate component. Always references a value of
a dictionary containing keys referencing \fIstate declarations\fP and \fIrequisite declarations\fP. Can be overridden by a \fIname declaration\fP or a
\fInames declaration\fP.
.sp
Occurs on the top level or under the \fIextend declaration\fP.
.sp
Must be unique across entire state tree. If the same ID declaration is
used twice, only the first one matched will be used. All subsequent
ID declarations with the same name will be ignored.
.UNINDENT
.IP Note
Naming gotchas
.sp
Until 0.9.6, IDs could \fBnot\fP contain a dot, otherwise highstate summary output was
unpredictable. (It was fixed in versions 0.9.7 and above)
.RE
.SS Extend declaration
.INDENT 0.0
.TP
.B Extend declaration
Extends a \fIname declaration\fP from an included \fBSLS module\fP. The
keys of the extend declaration always define existing \fIID
declarations\fP which have been defined in included
\fBSLS modules\fP.
.sp
Occurs only in the top level and defines a dictionary.
.UNINDENT
.sp
Extend declarations are useful for adding\-to or overriding parts of a
\fIstate declaration\fP that is defined in another \fBSLS\fP file. In the
following contrived example, the shown \fBmywebsite.sls\fP file is \fBinclude\fP
\-ing and \fBextend\fP \-ing the \fBapache.sls\fP module in order to add a \fBwatch\fP
declaration that will restart Apache whenever the Apache configuration file,
\fBmywebsite\fP changes.
.sp
.nf
.ft C
include:
  \- apache

extend:
  apache:
    service:
      \- watch:
        \- file: mywebsite

mywebsite:
  file:
    \- managed
.ft P
.fi
.IP "See also"
.sp
watch_in and require_in
.sp
Sometimes it is more convenient to use the \fIwatch_in\fP or
\fIrequire_in\fP syntax instead of extending another \fBSLS\fP
file.
.sp
\fBState Requisites\fP
.RE
.SS State declaration
.INDENT 0.0
.TP
.B State declaration
A list which contains one string defining the \fIfunction
declaration\fP and any number of \fIfunction arg declaration\fP
dictionaries.
.sp
Can, optionally, contain a number of additional components like the
name override components â€” \fIname\fP and
\fInames\fP. Can also contain \fIrequisite
declarations\fP.
.sp
Occurs under an \fIID declaration\fP.
.UNINDENT
.SS Requisite declaration
.INDENT 0.0
.TP
.B Requisite declaration
A list containing \fIrequisite references\fP.
.sp
Used to build the action dependency tree. While Salt states are made to
execute in a deterministic order, this order is managed by requiring
and watching other Salt states.
.sp
Occurs as a list component under a \fIstate declaration\fP or as a
key under an \fIID declaration\fP.
.UNINDENT
.SS Requisite reference
.INDENT 0.0
.TP
.B Requisite reference
A single key dictionary. The key is the name of the referenced
\fIstate declaration\fP and the value is the ID of the referenced
\fIID declaration\fP.
.sp
Occurs as a single index in a \fIrequisite declaration\fP list.
.UNINDENT
.SS Function declaration
.INDENT 0.0
.TP
.B Function declaration
The name of the function to call within the state. A state declaration
can contain only a single function declaration.
.sp
For example, the following state declaration calls the \fBinstalled\fP function in the \fBpkg\fP state module:
.sp
.nf
.ft C
httpd:
  pkg.installed
.ft P
.fi
.sp
The function can be declared inline with the state as a shortcut, but
the actual data structure is better referenced in this form:
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
.ft P
.fi
.sp
Where the function is a string in the body of the state declaration.
Technically when the function is declared in dot notation the compiler
converts it to be a string in the state declaration list. Note that the
use of the first example more than once in an ID declaration is invalid
yaml.
.sp
INVALID:
.sp
.nf
.ft C
httpd:
  pkg.installed
  service.running
.ft P
.fi
.sp
When passing a function without arguments and another state declaration
within a single ID declaration, then the long or "standard" format
needs to be used since otherwise it does not represent a valid data
structure.
.sp
VALID:
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
  service:
    \- running
.ft P
.fi
.sp
Occurs as the only index in the \fIstate declaration\fP list.
.UNINDENT
.SS Function arg declaration
.INDENT 0.0
.TP
.B Function arg declaration
A single key dictionary referencing a Python type which is to be passed
to the named \fIfunction declaration\fP as a parameter. The type must
be the data type expected by the function.
.sp
Occurs under a \fIfunction declaration\fP.
.UNINDENT
.sp
For example in the following state declaration \fBuser\fP, \fBgroup\fP, and
\fBmode\fP are passed as arguments to the \fBmanaged\fP function in the \fBfile\fP state module:
.sp
.nf
.ft C
/etc/http/conf/http.conf:
  file.managed:
    \- user: root
    \- group: root
    \- mode: 644
.ft P
.fi
.SS Name declaration
.INDENT 0.0
.TP
.B Name declaration
Overrides the \fBname\fP argument of a \fIstate declaration\fP. If
\fBname\fP is not specified the \fIID declaration\fP satisfies the
\fBname\fP argument.
.sp
The name is always a single key dictionary referencing a string.
.UNINDENT
.sp
Overriding \fBname\fP is useful for a variety of scenarios.
.sp
For example, avoiding clashing ID declarations. The following two state
declarations cannot both have \fB/etc/motd\fP as the ID declaration:
.sp
.nf
.ft C
motd_perms:
  file.managed:
    \- name: /etc/motd
    \- mode: 644

motd_quote:
  file.append:
    \- name: /etc/motd
    \- text: "Of all smells, bread; of all tastes, salt."
.ft P
.fi
.sp
Another common reason to override \fBname\fP is if the ID declaration is long and
needs to be referenced in multiple places. In the example below it is much
easier to specify \fBmywebsite\fP than to specify
\fB/etc/apache2/sites\-available/mywebsite.com\fP multiple times:
.sp
.nf
.ft C
mywebsite:
  file.managed:
    \- name: /etc/apache2/sites\-available/mywebsite.com
    \- source: salt://mywebsite.com

a2ensite mywebsite.com:
  cmd.wait:
    \- unless: test \-L /etc/apache2/sites\-enabled/mywebsite.com
    \- watch:
      \- file: mywebsite

apache2:
  service:
    \- running
    \- watch:
      \- file: mywebsite
.ft P
.fi
.SS Names declaration
.INDENT 0.0
.TP
.B Names declaration
Expands the contents of the containing \fIstate declaration\fP into
multiple state declarations, each with its own name.
.UNINDENT
.sp
For example, given the following state declaration:
.sp
.nf
.ft C
python\-pkgs:
  pkg.installed:
    \- names:
      \- python\-django
      \- python\-crypto
      \- python\-yaml
.ft P
.fi
.sp
Once converted into the lowstate data structure the above state
declaration will be expanded into the following three state declarations:
.sp
.nf
.ft C
python\-django:
  pkg.installed

python\-crypto:
  pkg.installed

python\-yaml:
  pkg.installed
.ft P
.fi
.SS Large example
.sp
Here is the layout in yaml using the names of the highdata structure
components.
.sp
.nf
.ft C
<Include Declaration>:
  \- <Module Reference>
  \- <Module Reference>

<Extend Declaration>:
  <ID Declaration>:
    [<overrides>]


# standard declaration

<ID Declaration>:
  <State Declaration>:
    \- <Function>
    \- <Function Arg>
    \- <Function Arg>
    \- <Function Arg>
    \- <Name>: <name>
    \- <Requisite Declaration>:
      \- <Requisite Reference>
      \- <Requisite Reference>


# inline function and names

<ID Declaration>:
  <State Declaration>.<Function>:
    \- <Function Arg>
    \- <Function Arg>
    \- <Function Arg>
    \- <Names>:
      \- <name>
      \- <name>
      \- <name>
    \- <Requisite Declaration>:
      \- <Requisite Reference>
      \- <Requisite Reference>


# multiple states for single id

<ID Declaration>:
  <State Declaration>:
    \- <Function>
    \- <Function Arg>
    \- <Name>: <name>
    \- <Requisite Declaration>:
      \- <Requisite Reference>
  <State Declaration>:
    \- <Function>
    \- <Function Arg>
    \- <Names>:
      \- <name>
      \- <name>
    \- <Requisite Declaration>:
      \- <Requisite Reference>
.ft P
.fi
.SH INCLUDE AND EXCLUDE
.sp
Salt sls files can include other sls files and exclude sls files that have been
otherwise included. This allows for an sls file to easily extend or manipulate
other sls files.
.SS Include
.sp
When other sls files are included, everything defined in the included sls file
will be added to the state run. When including define a list of sls formulas
to include:
.sp
.nf
.ft C
include:
  \- http
  \- libvirt
.ft P
.fi
.sp
The include statement will include sls formulas from the same environment
that the including sls formula is in. But the environment can be explicitly
defined in the configuration to override the running environment, therefore
if an sls formula needs to be included from an external environment named "dev"
the following syntax is used:
.sp
.nf
.ft C
include:
  \- dev: http
.ft P
.fi
.SS Relative Include
.sp
In Salt 0.16.0 the capability to include sls formulas which are relative to
the running sls formula was added, simply precede the formula name with a
\fI.\fP:
.sp
.nf
.ft C
include:
  \- .virt
  \- .virt.hyper
.ft P
.fi
.SS Exclude
.sp
The exclude statement, added in Salt 0.10.3 allows an sls to hard exclude
another sls file or a specific id. The component is excluded after the
high data has been compiled, so nothing should be able to override an
exclude.
.sp
Since the exclude can remove an id or an sls the type of component to
exclude needs to be defined. an exclude statement that verifies that the
running highstate does not contain the \fIhttp\fP sls and the \fI/etc/vimrc\fP id
would look like this:
.sp
.nf
.ft C
exclude:
  \- sls: http
  \- id: /etc/vimrc
.ft P
.fi
.SH STATE ENFORCEMENT
.sp
Salt offers an optional interface to manage the configuration or "state" of the
Salt minions. This interface is a fully capable mechanism used to enforce the
state of systems from a central manager.
.sp
The Salt state system is made to be accurate, simple, and fast. And like the
rest of the Salt system, Salt states are highly modular.
.SS State management
.sp
State management, also frequently called software configuration management
(SCM), is a program that puts and keeps a system into a predetermined state. It
installs software packages, starts or restarts services, or puts configuration
files in place and watches them for changes.
.sp
Having a state management system in place allows you to easily and reliably
configure and manage a few servers or a few thousand servers. It allows you to
keep that configuration under version control.
.sp
Salt States is an extension of the Salt Modules that we discussed in the
previous \fBremote execution\fP tutorial. Instead
of calling one\-off executions the state of a system can be easily defined and
then enforced.
.SS Understanding the Salt State System Components
.sp
The Salt state system is comprised of a number of components. As a user, an
understanding of the SLS and renderer systems are needed. But as a developer,
an understanding of Salt states and how to write the states is needed as well.
.SS Salt SLS System
.INDENT 0.0
.TP
.B SLS
The primary system used by the Salt state system is the SLS system. SLS
stands for \fBS\fPa\fBL\fPt \fBS\fPtate.
.sp
The Salt States are files which contain the information about how to
configure Salt minions. The states are laid out in a directory tree and
can be written in many different formats.
.sp
The contents of the files and they way they are laid out is intended to
be as simple as possible while allowing for maximum flexibility. The
files are laid out in states and contains information about how the
minion needs to be configured.
.UNINDENT
.SS SLS File Layout
.sp
SLS files are laid out in the Salt file server. A simple layout can look like
this:
.sp
.nf
.ft C
top.sls
ssh.sls
sshd_config
users/init.sls
users/admin.sls
salt/init.sls
salt/master.sls
.ft P
.fi
.sp
This example shows the core concepts of file layout. The top file is a key
component and is used with Salt matchers to match SLS states with minions.
The \fB.sls\fP files are states. The rest of the files are seen by the Salt
master as just files that can be downloaded.
.sp
The states are translated into dot notation, so the \fBssh.sls\fP file is
seen as the ssh state, the \fBusers/admin.sls\fP file is seen as the
users.admin states.
.sp
The init.sls files are translated to be the state name of the parent
directory, so the \fBsalt/init.sls\fP file translates to the Salt state.
.sp
The plain files are visible to the minions, as well as the state files. In
Salt, everything is a file; there is no "magic translation" of files and file
types. This means that a state file can be distributed to minions just like a
plain text or binary file.
.SS SLS Files
.sp
The Salt state files are simple sets of data. Since the SLS files are just data
they can be represented in a number of different ways. The default format is
yaml generated from a Jinja template. This allows for the states files to have
all the language constructs of Python and the simplicity of yaml. State files
can then be complicated Jinja templates that translate down to yaml, or just
plain and simple yaml files!
.sp
The State files are constructed data structures in a simple format. The format
allows for many real activates to be expressed in very little text, while
maintaining the utmost in readability and usability.
.sp
Here is an example of a Salt State:
.sp
.nf
.ft C
vim:
  pkg:
    \- installed

salt:
  pkg:
    \- latest
  service.running:
    \- require:
      \- file: /etc/salt/minion
      \- pkg: salt
    \- names:
      \- salt\-master
      \- salt\-minion
    \- watch:
      \- file: /etc/salt/minion

/etc/salt/minion:
  file.managed:
    \- source: salt://salt/minion
    \- user: root
    \- group: root
    \- mode: 644
    \- require:
      \- pkg: salt
.ft P
.fi
.sp
This short stanza will ensure that vim is installed, Salt is installed and up
to date, the salt\-master and salt\-minion daemons are running and the Salt
minion configuration file is in place. It will also ensure everything is
deployed in the right order and that the Salt services are restarted when the
watched file updated.
.SS The Top File
.sp
The top file is the mapping for the state system. The top file specifies which
minions should have which modules applied and which environments they should
draw the states from.
.sp
The top file works by specifying the environment, containing matchers with
lists of Salt states sent to the matching minions:
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- salt
    \- users
    \- users.admin
  \(aqsaltmaster.*\(aq:
    \- match: pcre
    \- salt.master
.ft P
.fi
.sp
This simple example uses the base environment, which is built into the default
Salt setup, and then all minions will have the modules salt, users and
users.admin since \(aq*\(aq will match all minions. Then the regular expression
matcher will match all minions\(aq with an id matching saltmaster.* and add the
salt.master state.
.SS Renderer System
.sp
The Renderer system is a key component to the state system. SLS files are
representations of Salt "high data" structures. All Salt cares about when
reading an SLS file is the data structure that is produced from the file.
.sp
This allows Salt states to be represented by multiple types of files. The
Renderer system can be used to allow different formats to be used for SLS
files.
.sp
The available renderers can be found in the renderers directory in the Salt
source code:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/renderers\fP
.sp
By default SLS files are rendered using Jinja as a templating engine, and yaml
as the serialization format. Since the rendering system can be extended simply
by adding a new renderer to the renderers directory, it is possible that any
structured file could be used to represent the SLS files.
.sp
In the future XML will be added, as well as many other formats.
.SH STATE SYSTEM LAYERS
.sp
The Salt state system is comprised of multiple layers. While using Salt does
not require an understanding of the state layers, a deeper understanding of
how Salt compiles and manages states can be very beneficial.
.SS Function Call
.sp
The lowest layer of functionality in the state system is the direct state
function call. State executions are executions of single state functions at
the core. These individual functions are defined in state modules and can
be called directly via the \fBstate.single\fP command.
.sp
.nf
.ft C
salt \(aq*\(aq state.single pkg.installed name=\(aqvim\(aq
.ft P
.fi
.SS Low Chunk
.sp
The low chunk is the bottom of the Salt state compiler. This is a data
representation of a single function call. The low chunk is sent to the state
caller and used to execute a single state function.
.sp
A single low chunk can be executed manually via the \fBstate.low\fP command.
.sp
.nf
.ft C
salt \(aq*\(aq state.low \(aq{name: vim, state: pkg, fun: installed}\(aq
.ft P
.fi
.sp
The passed data reflects what the state execution system gets after compiling
the data down from sls formulas.
.SS Low State
.sp
The \fILow State\fP layer is the list of low chunks "evaluated" in order. To see
what the low state looks like for a highstate, run:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_lowstate
.ft P
.fi
.sp
This will display the raw lowstate in the order which each low chunk will be
evaluated. The order of evaluation is not necessarily the order of execution,
since requisites are evaluated at runtime. Requisite execution and evaluation
is finite; this means that the order of execution can be ascertained with 100%
certainty based on the order of the low state.
.SS High Data
.sp
High data is the data structure represented in YAML via SLS files. The High
data structure is created by merging the data components rendered inside sls
files (or other render systems). The High data can be easily viewed by
executing the \fBstate.show_highstate\fP or \fBstate.show_sls\fP functions. Since
this data is a somewhat complex data structure, it may be easier to read using
the json, yaml, or pprint outputters:
.sp
.nf
.ft C
salt \(aq*\(aq state.show_highstate \-\-out yaml
salt \(aq*\(aq state.show_sls edit.vim \-\-out pprint
.ft P
.fi
.SS SLS
.sp
Above "High Data", the logical layers are no longer technically required to be
executed, or to be executed in a hierarchy. This means that how the High data
is generated is optional and very flexible. The SLS layer allows for many
mechanisms to be used to render sls data from files or to use the fileserver
backend to generate sls and file data from external systems.
.sp
The SLS layer can be called directly to execute individual sls formulas.
.IP Note
SLS Formulas have historically been called "SLS files". This is because a
single SLS was only constituted in a single file. Now the term
"SLS Formula" better expresses how a compartmentalized SLS can be expressed
in a much more dynamic way by combining pillar and other sources, and the
SLS can be dynamically generated.
.RE
.sp
To call a single SLS formula named \fBedit.vim\fP, execute \fBstate.sls\fP:
.sp
.nf
.ft C
salt \(aq*\(aq state.sls edit.vim
.ft P
.fi
.SS HighState
.sp
Calling SLS directly logically assigns what states should be executed from the
context of the calling minion. The Highstate layer is used to allow for full
contextual assignment of what is executed where to be tied to groups of, or
individual, minions entirely from the master. This means that the environment of
a minion, and all associated execution data pertinent to said minion, can be
assigned from the master without needing to execute or configure anything on
the target minion. This also means that the minion can independently retrieve
information about its complete configuration from the master.
.sp
To execute the High State call \fBstate.highstate\fP:
.sp
.nf
.ft C
salt \(aq*\(aq state.highstate
.ft P
.fi
.SS OverState
.sp
The overstate layer expresses the highest functional layer of Salt\(aqs automated
logic systems. The Overstate allows for stateful and functional orchestration
of routines from the master. The overstate defines in data execution stages
which minions should execute states, or functions, and in what order using
requisite logic.
.SH ORDERING STATES
.sp
When creating Salt SLS files, it is often important to ensure that they run in
a specific order. While states will always execute in the same order, that
order is not necessarily defined the way you want it.
.sp
A few tools exist in Salt to set up the correct state ordering. These tools
consist of requisite declarations and order options.
.IP Note
Salt does \fBnot\fP execute \fIstate declarations\fP in
the order they appear in the source.
.RE
.SS Requisite Statements
.IP Note
This document represents behavior exhibited by Salt requisites as of
version 0.9.7 of Salt.
.RE
.sp
Often when setting up states any single action will require or depend on
another action. Salt allows you to build relationships between states with
requisite statements. A requisite statement ensure that the named state is
evaluated before the state requiring it. There are two types of requisite
statements in Salt, \fBrequire\fP and \fBwatch\fP.
.sp
These requisite statements are applied to a specific state declaration:
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
  file.managed:
    \- name: /etc/httpd/conf/httpd.conf
    \- source: salt://httpd/httpd.conf
    \- require:
      \- pkg: httpd
.ft P
.fi
.sp
In this example we use the \fBrequire\fP requisite to declare that the file
/etc/httpd/conf/httpd.conf should only be set up if the pkg state executes
successfully.
.sp
The requisite system works by finding the states that are required and
executing them before the state that requires them. Then the required states
can be evaluated to see if they have executed correctly.
.IP Note
Requisite matching
.sp
Requisites match on both the ID Declaration and the \fBname\fP parameter.
Therefore, if you are using the \fBpkgs\fP or \fBsources\fP argument to install
a list of packages in a pkg state, it\(aqs important to note that you cannot
have a requisite that matches on an individual package in the list.
.RE
.SS Multiple Requisites
.sp
The requisite statement is passed as a list, allowing for the easy addition of
more requisites. Both requisite types can also be separately declared:
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
  service.running:
    \- enable: True
    \- watch:
      \- file: /etc/httpd/conf/httpd.conf
    \- require:
      \- pkg: httpd
      \- user: httpd
      \- group: httpd
  file.managed:
    \- name: /etc/httpd/conf/httpd.conf
    \- source: salt://httpd/httpd.conf
    \- require:
      \- pkg: httpd
  user:
    \- present
  group:
    \- present
.ft P
.fi
.sp
In this example the httpd service is only going to be started if the package,
user, group and file are executed successfully.
.SS The Require Requisite
.sp
The foundation of the requisite system is the \fBrequire\fP requisite. The
require requisite ensures that the required state(s) are executed before the
requiring state. So, if a state is declared that sets down a vimrc, then it
would be pertinent to make sure that the vimrc file would only be set down if
the vim package has been installed:
.sp
.nf
.ft C
vim:
  pkg:
    \- installed
  file.managed:
    \- source: salt://vim/vimrc
    \- require:
      \- pkg: vim
.ft P
.fi
.sp
In this case, the vimrc file will only be applied by Salt if and after the vim
package is installed.
.SS The Watch Requisite
.sp
The \fBwatch\fP requisite is more advanced than the \fBrequire\fP requisite. The
watch requisite executes the same logic as require (therefore if something is
watched it does not need to also be required) with the addition of executing
logic if the required states have changed in some way.
.sp
The watch requisite checks to see if the watched states have returned any
changes. If the watched state returns changes, and the watched states execute
successfully, then the watching state will execute a function that reacts to
the changes in the watched states.
.sp
Perhaps an example can better explain the behavior:
.sp
.nf
.ft C
redis:
  pkg:
    \- latest
  file.managed:
    \- source: salt://redis/redis.conf
    \- name: /etc/redis.conf
    \- require:
      \- pkg: redis
  service.running:
    \- enable: True
    \- watch:
      \- file: /etc/redis.conf
      \- pkg: redis
.ft P
.fi
.sp
In this example the redis service will only be started if the file
/etc/redis.conf is applied, and the file is only applied if the package is
installed. This is normal require behavior, but if the watched file changes,
or the watched package is installed or upgraded, then the redis service is
restarted.
.SS Watch and the mod_watch Function
.sp
The watch requisite is based on the \fBmod_watch\fP function. Python state
modules can include a function called \fBmod_watch\fP which is then called
if the watch call is invoked. When \fBmod_watch\fP is called depends on the
execution of the watched state, which:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
If no changes then just run the watching state itself as usual.
\fBmod_watch\fP is not called. This behavior is same as using a \fBrequire\fP.
.IP \(bu 2
If changes then run the watching state \fIAND\fP if that changes nothing then
react by calling \fBmod_watch\fP.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
When reacting, in the case of the service module the underlying service is
restarted. In the case of the cmd state the command is executed.
.sp
The \fBmod_watch\fP function for the service state looks like this:
.sp
.nf
.ft C
def mod_watch(name, sig=None, reload=False, full_restart=False):
    \(aq\(aq\(aq
    The service watcher, called to invoke the watch command.

    name
        The name of the init or rc script used to manage the service

    sig
        The string to search for when looking for the service process with ps
    \(aq\(aq\(aq
    if __salt__[\(aqservice.status\(aq](name, sig):
        if \(aqservice.reload\(aq in __salt__ and reload:
            restart_func = __salt__[\(aqservice.reload\(aq]
        elif \(aqservice.full_restart\(aq in __salt__ and full_restart:
            restart_func = __salt__[\(aqservice.full_restart\(aq]
        else:
            restart_func = __salt__[\(aqservice.restart\(aq]
    else:
        restart_func = __salt__[\(aqservice.start\(aq]

    result = restart_func(name)
    return {\(aqname\(aq: name,
            \(aqchanges\(aq: {name: result},
            \(aqresult\(aq: result,
            \(aqcomment\(aq: \(aqService restarted\(aq if result else \e
                       \(aqFailed to restart the service\(aq
           }
.ft P
.fi
.sp
The watch requisite only works if the state that is watching has a
\fBmod_watch\fP function written. If watch is set on a state that does not have
a \fBmod_watch\fP function (like pkg), then the listed states will behave only
as if they were under a \fBrequire\fP statement.
.sp
Also notice that a \fBmod_watch\fP may accept additional keyword arguments,
which, in the sls file, will be taken from the same set of arguments specified
for the state that includes the \fBwatch\fP requisite. This means, for the
earlier \fBservice.running\fP example above,  you can tell the service to
\fBreload\fP instead of restart like this:
.sp
.nf
.ft C
redis:

  # ... other state declarations omitted ...

    service.running:
      \- enable: True
      \- reload: True
      \- watch:
        \- file: /etc/redis.conf
        \- pkg: redis
.ft P
.fi
.SS The Order Option
.sp
Before using the order option, remember that the majority of state ordering
should be done with a \fIrequisite declaration\fP, and that a requisite
declaration will override an order option.
.sp
The order option is used by adding an order number to a state declaration
with the option \fIorder\fP:
.sp
.nf
.ft C
vim:
  pkg.installed:
    \- order: 1
.ft P
.fi
.sp
By adding the order option to \fI1\fP this ensures that the vim package will be
installed in tandem with any other state declaration set to the order \fI1\fP.
.sp
Any state declared without an order option will be executed after all states
with order options are executed.
.sp
But this construct can only handle ordering states from the beginning.
Sometimes you may want to send a state to the end of the line. To do this,
set the order to \fBlast\fP:
.sp
.nf
.ft C
vim:
  pkg.installed:
    \- order: last
.ft P
.fi
.sp
Remember that requisite statements override the order option. So the order
option should be applied to the highest component of the requisite chain:
.sp
.nf
.ft C
vim:
  pkg.installed:
    \- order: last
    \- require:
      \- file: /etc/vimrc

/etc/vimrc:
  file.managed:
    \- source: salt://edit/vimrc
.ft P
.fi
.SH OVERSTATE SYSTEM
.sp
Often servers need to be set up and configured in a specific order, and systems
should only be set up if systems earlier in the sequence has been set up
without any issues.
.sp
The 0.11.0 release of Salt addresses this problem with a new layer in the state
system called the \fIOver State\fP. The concept of the \fIOver State\fP is managed on
the master, a series of state executions is controlled from the master and
executed in order. If an execution requires that another execution first run
without problems then the state executions will stop.
.sp
The \fIOver State\fP system is used to orchestrate deployment in a smooth and
reliable way across multiple systems in small to large environments.
.SS The Over State SLS
.sp
The overstate system is managed by an sls file located in the root of an
environment. This file uses a data structure like all sls files.
.sp
The overstate sls file configures an unordered list of stages, each stage
defines the minions to execute on and can define what sls files to run
or to execute a state.highstate.
.sp
.nf
.ft C
mysql:
  match: db*
  sls:
    \- mysql.server
    \- drbd
webservers:
  match: web*
  require:
    \- mysql
all:
  match: \(aq*\(aq
  require:
    \- mysql
    \- webservers
.ft P
.fi
.sp
The above defined over state will execute the mysql stage first because it is
required by the webservers stage. The webservers stage will then be executed
only if the mysql stage executes without any issues. The webservers stage
will execute state.highstate on the matched minions, while the mysql stage
will execute state.sls with the named sls files.
.sp
Finally the all stage will execute state.highstate on all systems only if the
mysql and webservers stages complete without failures. The overstate system
checks for any states that return a result of \fIFalse\fP, if the run has any
\fIFalse\fP returns then the overstate will quit.
.SS Adding Functions To Overstate
.sp
In 0.15.0 the ability to execute module functions directly in the overstate
was added. Functions are called as a stage with the function key:
.sp
.nf
.ft C
http:
  function:
    pkg.install:
      \- http
.ft P
.fi
.sp
The list of function arguments are passed after the declared function.
Requisites only functions properly if the given function supports returning
a custom return code.
.SS Executing the Over State
.sp
The over state can be executed from the salt\-run command, calling the
state.over runner function. The function will by default look in the base
environment for the overstate.sls file:
.sp
.nf
.ft C
salt\-run state.over
.ft P
.fi
.sp
To specify the location of the overstate file and the environment to pull from
pass the arguments to the salt\-run command:
.sp
.nf
.ft C
salt\-run state.over base /root/overstate.sls
.ft P
.fi
.sp
Remember, that these calls are made on the master.
.SH STATE PROVIDERS
.sp
New in version 0.9.8.
.sp
Salt predetermines what modules should be mapped to what uses based on the
properties of a system. These determinations are generally made for modules
that provide things like package and service management.
.sp
Sometimes in states, it may be necessary to use an alternative module to
provide the needed functionality. For instance, an older Arch Linux system may
not be running systemd, so instead of using the systemd service module, you can
revert to the default service module:
.sp
.nf
.ft C
httpd:
  service.running:
    \- enable: True
    \- provider: service
.ft P
.fi
.sp
In this instance, the basic \fBservice\fP module will replace
the \fBsystemd\fP module which is used by default on Arch
Linux, and the \fBhttpd\fP service will be managed using
\fBsysvinit\fP.
.IP Note
You can also set a provider globally in the minion config
\fBproviders\fP.
.RE
.SS Arbitrary Module Redirects
.sp
The provider statement can also be used for more powerful means, instead of
overwriting or extending the module used for the named service an arbitrary
module can be used to provide certain functionality.
.sp
.nf
.ft C
emacs:
  pkg.installed:
    \- provider:
      \- pkg: yumpkg5
      \- cmd: customcmd
.ft P
.fi
.sp
In this example the default \fBpkg\fP module is being
redirected to use the \fByumpkg5\fP module (\fByum\fP
via shelling out instead of via the \fByum\fP Python API), but is also
using a custom module to invoke commands. This could be used to dramatically
change the behavior of a given state.
.SH REQUISITES
.sp
The Salt requisite system is used to create relationships between states. The
core idea being that, when one state is dependent somehow on another, that
inter\-dependency can be easily defined.
.sp
Requisites come in two types. Direct requisites, and requisite_ins. The
relationships are directional, so a requisite statement makes the requiring
state declaration depend on the required state declaration:
.sp
.nf
.ft C
vim:
  pkg.installed

/etc/vimrc:
  file.managed:
    \- source: salt://edit/vimrc
    \- require:
      \- pkg: vim
.ft P
.fi
.sp
So in this example, the file \fB/etc/vimrc\fP depends on the vim package.
.sp
Requisite_in statements are the opposite, instead of saying "I depend on
something", requisite_ins say "Someone depends on me":
.sp
.nf
.ft C
vim:
  pkg.installed:
    \- require_in:
      \- file: /etc/vimrc

/etc/vimrc:
  file.managed:
    \- source: salt://edit/vimrc
.ft P
.fi
.sp
So here, with a requisite_in, the same thing is accomplished, but just from
the other way around. The vim package is saying "/etc/vimrc depends on me".
.sp
In the end, a single dependency map is created and everything is executed in a
finite and predictable order.
.IP Note
Requisite matching
.sp
Requisites match on both the ID Declaration and the \fBname\fP parameter.
This means that, in the example above, the \fBrequire_in\fP requisite would
also have been matched if the \fB/etc/vimrc\fP state was written as follows:
.sp
.nf
.ft C
vimrc:
  file.managed:
    \- name: /etc/vimrc
    \- source: salt://edit/vimrc
.ft P
.fi
.RE
.SS Requisite and Requisite in types
.sp
There are three requisite statements that can be used in Salt. the \fBrequire\fP,
\fBwatch\fP and \fBuse\fP requisites. Each requisite also has a corresponding
requisite_in: \fBrequire_in\fP, \fBwatch_in\fP and \fBuse_in\fP. All of the
requisites define specific relationships and always work with the dependency
logic defined above.
.SS Require
.sp
The most basic requisite statement is \fBrequire\fP. The behavior of require is
simple. Make sure that the dependent state is executed before the depending
state, and if the dependent state fails, don\(aqt run the depending state. So in
the above examples the file \fB/etc/vimrc\fP will only be applied after the vim
package is installed and only if the vim package is installed successfully.
.SS Watch
.sp
The watch statement does everything the require statement does, but with a
little more. The watch statement looks into the state modules for a function
called \fBmod_watch\fP. If this function is not available in the corresponding
state module, then watch does the same thing as require. If the \fBmod_watch\fP
function is in the state module, then the watched state is checked to see if
it made any changes to the system, if it has, then \fBmod_watch\fP is called.
.sp
Perhaps the best example of using watch is with a service, when a service
watches other states, then when the other states make changes on the system
the service is reloaded or restarted.
.SS Prereq
.sp
The \fBprereq\fP requisite is a powerful requisite added in 0.16.0. This
requisite allows for actions to be taken based on the expected results of
a state that has not yet been executed. In more practical terms, a service
can be shut down because the \fBprereq\fP knows that underlying code is going to
be updated and the service should be off\-line while the update occurs.
.sp
The motivation to add this requisite was to allow for routines to remove a
system from a load balancer while code is being updated.
.sp
The \fBprereq\fP checks if the required state expects to have any changes by
running the single state with \fBtest=True\fP. If the pre\-required state returns
changes, then the state requiring it will execute.
.sp
.nf
.ft C
graceful\-down:
  cmd.run:
    \- name: service apache graceful
    \- prereq:
      \- file: site\-code

site\-code:
  file.recurse:
    \- name: /opt/site_code
    \- source: salt://site/code
.ft P
.fi
.sp
In this case the apache server will only be shutdown if the site\-code state
expects to deploy fresh code via the file.recurse call, and the site\-code
deployment will only be executed if the graceful\-down run completes
successfully.
.SS Use
.sp
The \fBuse\fP requisite is used to inherit the arguments passed in another
id declaration. This is useful when many files need to have the same defaults.
.sp
The \fBuse\fP statement was developed primarily for the networking states but
can be used on any states in Salt. This made sense for the networking state
because it can define a long list of options that need to be applied to
multiple network interfaces.
.SS Require In
.sp
The \fBrequire_in\fP requisite is the literal reverse of \fBrequire\fP. If
a state declaration needs to be required by another state declaration then
require_in can accommodate it, so these two sls files would be the same in
the end:
.sp
Using \fBrequire\fP
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
  service:
    \- running
    \- require:
      \- pkg: httpd
.ft P
.fi
.sp
Using \fBrequire_in\fP
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
    \- require_in:
      \- service: httpd
  service:
    \- running
.ft P
.fi
.sp
The \fBrequire_in\fP statement is particularly useful when assigning a require
in a separate sls file. For instance it may be common for httpd to require
components used to set up PHP or mod_python, but the HTTP state does not need
to be aware of the additional components that require it when it is set up:
.sp
http.sls
.sp
.nf
.ft C
httpd:
  pkg:
    \- installed
  service:
    \- running
    \- require:
      \- pkg: httpd
.ft P
.fi
.sp
php.sls
.sp
.nf
.ft C
include:
  \- http

php:
  pkg:
    \- installed
    \- require_in:
      \- service: httpd
.ft P
.fi
.sp
mod_python.sls
.sp
.nf
.ft C
include:
  \- http

mod_python:
  pkg:
    \- installed
    \- require_in:
      \- service: httpd
.ft P
.fi
.sp
Now the httpd server will only start if php or mod_python are first verified to
be installed. Thus allowing for a requisite to be defined "after the fact".
.SS Watch In
.sp
Watch in functions the same was as require in, but applies a watch statement
rather than a require statement to the external state declaration.
.SS Prereq In
.sp
The \fBprereq_in\fP requisite in follows the same assignment logic as the
\fBrequire_in\fP requisite in. The \fBprereq_in\fP call simply assigns
\fBprereq\fP to the state referenced. The above example for \fBprereq\fP can
be modified to function in the same way using \fBprereq_in\fP:
.sp
.nf
.ft C
graceful\-down:
  cmd.run:
    \- name: service apache graceful

site\-code:
  file.recurse:
    \- name: /opt/site_code
    \- source: salt://site/code
    \- prereq_in:
      \- cmd: graceful\-down
.ft P
.fi
.SH STARTUP STATES
.sp
Sometimes it may be desired that the salt minion execute a state run when it is
started. This alleviates the need for the master to initiate a state run on a
new minion and can make provisioning much easier.
.sp
As of Salt 0.10.3 the minion config reads options that allow for states to be
executed at startup. The options are \fIstartup_states\fP, \fIsls_list\fP and
\fItop_file\fP.
.sp
The \fIstartup_states\fP option can be passed one of a number of arguments to
define how to execute states. The available options are:
.INDENT 0.0
.TP
.B highstate
Execute \fBstate.highstate\fP
.TP
.B sls
Read in the \fBsls_list\fP option and execute the named sls files
.TP
.B top
Read in the \fBtop_file\fP option and execute states based on that top file
on the Salt Master
.UNINDENT
.SS Examples:
.sp
Execute \fBstate.highstate\fP when starting the minion:
.sp
.nf
.ft C
startup_states: highstate
.ft P
.fi
.sp
Execute the sls files \fIedit.vim\fP and \fIhyper\fP:
.sp
.nf
.ft C
startup_states: sls

sls_list:
  \- edit.vim
  \- hyper
.ft P
.fi
.SH STATE TESTING
.sp
Executing a Salt state run can potentially change many aspects of a system and
it may be desirable to first see what a state run is going to change before
applying the run.
.sp
Salt has a test interface to report on exactly what will be changed, this
interface can be invoked on any of the major state run functions:
.sp
.nf
.ft C
# salt \e* state.highstate test=True
# salt \e* state.sls test=True
# salt \e* state.single test=True
.ft P
.fi
.sp
The test run is mandated by adding the \fBtest=True\fP option to the states. The
return information will show states that will be applied in yellow and the
result is reported as \fINone\fP.
.SS Default Test
.sp
If the value \fItest\fP is set to True in the minion configuration file then states
will default to being executed in test mode. If this value is set then states
can still be run by calling test=False:
.sp
.nf
.ft C
# salt \e* state.highstate test=False
# salt \e* state.sls test=False
# salt \e* state.single test=False
.ft P
.fi
.SH THE TOP FILE
.sp
The top file is used to map what SLS modules get loaded onto what minions via
the state system. The top file creates a few general abstractions. First it
maps what nodes should pull from which environments, next it defines which
matches systems should draw from.
.SS Environments
.INDENT 0.0
.TP
.B Environment
A configuration that allows conceptually organizing state tree
directories. Environments can be made to be self\-contained or state
trees can be made to bleed through environments.
.UNINDENT
.sp
The environments in the top file corresponds with the environments defined in
the \fBfile_roots\fP variable. In a simple, single environment setup
you only have the \fBbase\fP environment, and therefore only one state tree. Here
is a simple example of \fBfile_roots\fP in the master configuration:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt
.ft P
.fi
.sp
This means that the top file will only have one environment to pull from,
here is a simple, single environment top file:
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- core
    \- edit
.ft P
.fi
.sp
This also means that \fB/srv/salt\fP has a state tree. But if you want to use
multiple environments, or partition the file server to serve more than
just the state tree, then the \fBfile_roots\fP option can be expanded:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt/base
  dev:
    \- /srv/salt/dev
  qa:
    \- /srv/salt/qa
  prod:
    \- /srv/salt/prod
.ft P
.fi
.sp
Then our top file could reference the environments:
.sp
.nf
.ft C
dev:
  \(aqwebserver*dev*\(aq:
    \- webserver
  \(aqdb*dev*\(aq:
    \- db
qa:
  \(aqwebserver*qa*\(aq:
    \- webserver
  \(aqdb*qa*\(aq:
    \- db
prod:
  \(aqwebserver*prod*\(aq:
    \- webserver
  \(aqdb*prod*\(aq:
    \- db
.ft P
.fi
.sp
In this setup we have state trees in three of the four environments, and no
state tree in the \fBbase\fP environment. Notice that the targets for the minions
specify environment data. In Salt the master determines who is in what
environment, and many environments can be crossed together. For instance, a
separate global state tree could be added to the \fBbase\fP environment if it
suits your deployment:
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- global
dev:
  \(aqwebserver*dev*\(aq:
    \- webserver
  \(aqdb*dev*\(aq:
    \- db
qa:
  \(aqwebserver*qa*\(aq:
    \- webserver
  \(aqdb*qa*\(aq:
    \- db
prod:
  \(aqwebserver*prod*\(aq:
    \- webserver
  \(aqdb*prod*\(aq:
    \- db
.ft P
.fi
.sp
In this setup all systems will pull the global SLS from the base environment,
as well as pull from their respective environments.
.IP Note
The top files from all defined environments will be compiled into a single
top file for all states.  Top files are environment agnostic.
.RE
.sp
Remember, that since everything is a file in Salt, the environments are
primarily file server environments, this means that environments that have
nothing to do with states can be defined and used to distribute other files.
.sp
A clean and recommended setup for multiple environments would look like this:
.sp
.nf
.ft C
# Master file_roots configuration:
file_roots:
  base:
    \- /srv/salt/base
  dev:
    \- /srv/salt/dev
  qa:
    \- /srv/salt/qa
  prod:
    \- /srv/salt/prod
.ft P
.fi
.sp
Then only place state trees in the dev, qa and prod environments, leaving
the base environment open for generic file transfers. Then the top.sls file
would look something like this:
.sp
.nf
.ft C
dev:
  \(aqwebserver*dev*\(aq:
    \- webserver
  \(aqdb*dev*\(aq:
    \- db
qa:
  \(aqwebserver*qa*\(aq:
    \- webserver
  \(aqdb*qa*\(aq:
    \- db
prod:
  \(aqwebserver*prod*\(aq:
    \- webserver
  \(aqdb*prod*\(aq:
    \- db
.ft P
.fi
.SS Other Ways of Targeting Minions
.sp
In addition to globs, minions can be specified in top files a few other
ways. Some common ones are \fBcompound matches\fP
and \fBnode groups\fP.
.sp
Here is a slightly more complex top file example, showing the different types
of matches you can perform:
.sp
.nf
.ft C
base:
    \(aq*\(aq:
        \- ldap\-client
        \- networking
        \- salt.minion

    \(aqsalt\-master*\(aq:
        \- salt.master

    \(aq^(memcache|web).(qa|prod).loc$\(aq:
        \- match: pcre
        \- nagios.mon.web
        \- apache.server

    \(aqos:Ubuntu\(aq:
        \- match: grain
        \- repos.ubuntu

    \(aqos:(RedHat|CentOS)\(aq:
        \- match: grain_pcre
        \- repos.epel

    \(aqfoo,bar,baz\(aq:
        \- match: list
        \- database

    \(aqsomekey:abc\(aq:
        \- match: pillar
        \- xyz

    \(aqnag1* or G@role:monitoring\(aq:
        \- match: compound
        \- nagios.server
.ft P
.fi
.sp
In this example \fBtop.sls\fP, all minions get the ldap\-client, networking and
salt.minion states. Any minion with an id matching the \fBsalt\-master*\fP glob
will get the salt.master state. Any minion with ids matching the regular
expression \fB^(memcache|web).(qa|prod).loc$\fP will get the nagios.mon.web and
apache.server states. All Ubuntu minions will receive the repos.ubuntu state,
while all RHEL and CentOS minions will receive the repos.epel state. The
minions \fBfoo\fP, \fBbar\fP, and \fBbaz\fP will receive the database state. Any
minion with a pillar named \fBsomekey\fP, having a value of \fBabc\fP will receive
the xyz state.  Finally, minions with ids matching the nag1* glob or with a
grain named \fBrole\fP equal to \fBmonitoring\fP will receive the nagios.server
state.
.SH SLS TEMPLATE VARIABLE REFERENCE
.sp
The template engines available to sls files and file templates come loaded
with a number of context variables. These variables contain information and
functions to assist in the generation of templates.
.SS Salt
.sp
The \fIsalt\fP variable is available to abstract the salt library functions. This
variable is a python dictionary containing all of the functions available to
the running salt minion:
.sp
.nf
.ft C
{% for file in salt[\(aqcmd.run\(aq](ls /opt/to_remove) %}
{{ file }}:
  file.absent
{% endfor %}
.ft P
.fi
.SS Opts
.sp
The \fIopts\fP variable abstracts the contents of the minion\(aqs configuration file
directly to the template. The \fIopts\fP variable is a dictionary.
.sp
.nf
.ft C
{{ opts[\(aqcachedir\(aq] }}
.ft P
.fi
.sp
The \fBconfig.get\fP function also searches for values in the \fIopts\fP dictionary.
.SS Pillar
.sp
The \fIpillar\fP dictionary can be referenced directly:
.sp
.nf
.ft C
{{ pillar[\(aqkey\(aq] }}
.ft P
.fi
.sp
Using the \fBpillar.get\fP function via the \fIsalt\fP variable is generally
recommended since a default can be safely set in the event that the value
is not available in pillar and dictionaries can be traversed directly:
.sp
.nf
.ft C
{{ salt[\(aqpillar.get\(aq](\(aqkey\(aq, \(aqfailover_value\(aq) }}
{{ salt[\(aqpillar.get\(aq](\(aqstuff:more:deeper\(aq) }}
.ft P
.fi
.SS Grains
.sp
The \fIgrains\fP dictionary makes the minion\(aqs grains directly available:
.sp
.nf
.ft C
{{ grains[\(aqos\(aq] }}
.ft P
.fi
.sp
The \fBgrains.get\fP function can be used to traverse deeper grains and set
defaults:
.sp
.nf
.ft C
{{ salt[\(aqgrains.get\(aq](\(aqos\(aq) }}
.ft P
.fi
.SS env
.sp
The \fIenv\fP variable is available in sls files when gathering the sls from
an environment.
.sp
.nf
.ft C
{{ env }}
.ft P
.fi
.SS sls
.sp
The \fIsls\fP variable contains the sls reference value. The sls reference value
is the value used to include the sls in top files or via the include option.
.sp
.nf
.ft C
{{ sls }}
.ft P
.fi
.SH STATE MODULES
.sp
State Modules are the components that map to actual enforcement and management
of Salt states.
.SS States are Easy to Write!
.sp
State Modules should be easy to write and straightforward. The information
passed to the SLS data structures will map directly to the states modules.
.sp
Mapping the information from the SLS data is simple, this example should
illustrate:
.sp
.nf
.ft C
/etc/salt/master: # maps to "name"
  file: # maps to State module filename e.g. https://github.com/saltstack/salt/blob/develop/salt/states/file.py
    \- managed # maps to the managed function in the file State module
    \- user: root # one of many options passed to the manage function
    \- group: root
    \- mode: 644
    \- source: salt://salt/master
.ft P
.fi
.sp
Therefore this SLS data can be directly linked to a module, function and
arguments passed to that function.
.sp
This does issue the burden, that function names, state names and function
arguments should be very human readable inside state modules, since they
directly define the user interface.
.SS Using Custom State Modules
.sp
Place your custom state modules inside a \fB_states\fP directory within the
\fBfile_roots\fP specified by the master config file. These custom
state modules can then be distributed in a number of ways. Custom state modules
are distributed when \fBstate.highstate\fP is
run, or by executing the \fBsaltutil.sync_states\fP or \fBsaltutil.sync_all\fP functions.
.SS Cross Calling Modules
.sp
As with Execution Modules, State Modules can also make use of the \fB__salt__\fP
and \fB__grains__\fP data.
.sp
It is important to note that the real work of state management should not be
done in the state module unless it is needed. A good example is the pkg state
module. This module does not do any package management work, it just calls the
pkg execution module. This makes the pkg state module completely generic, which
is why there is only one pkg state module and many backend pkg execution
modules.
.sp
On the other hand some modules will require that the logic be placed in the
state module, a good example of this is the file module. But in the vast
majority of cases this is not the best approach, and writing specific
execution modules to do the backend work will be the optimal solution.
.SS Return Data
.sp
A State Module must return a dict containing the following keys/values:
.INDENT 0.0
.IP \(bu 2
\fBname:\fP The same value passed to the state as "name".
.IP \(bu 2
\fBchanges:\fP A dict describing the changes made. Each thing changed should
be a key, with its value being another dict with keys called "old" and "new"
containing the old/new values. For example, the pkg state\(aqs \fBchanges\fP dict
has one key for each package changed, with the "old" and "new" keys in its
sub\-dict containing the old and new versions of the package.
.IP \(bu 2
\fBresult:\fP A boolean value. \fITrue\fP if the action was successful, otherwise
\fIFalse\fP.
.IP \(bu 2
\fBcomment:\fP A string containing a summary of the result.
.UNINDENT
.SS Test State
.sp
All states should check for and support \fBtest\fP being passed in the options.
This will return data about what changes would occur if the state were actually
run. An example of such a check could look like this:
.sp
.nf
.ft C
# Return comment of changes if test.
if __opts__[\(aqtest\(aq]:
    ret[\(aqresult\(aq] = None
    ret[\(aqcomment\(aq] = \(aqState Foo will execute with param {0}\(aq.format(bar)
    return ret
.ft P
.fi
.sp
Make sure to test and return before performing any real actions on the minion.
.SS Watcher Function
.sp
If the state being written should support the watch requisite then a watcher
function needs to be declared. The watcher function is called whenever the
watch requisite is invoked and should be generic to the behavior of the state
itself.
.sp
The watcher function should accept all of the options that the normal state
functions accept (as they will be passed into the watcher function).
.sp
A watcher function typically is used to execute state specific reactive
behavior, for instance, the watcher for the service module restarts the
named service and makes it useful for the watcher to make the service
react to changes in the environment.
.sp
The watcher function also needs to return the same data that a normal state
function returns.
.SS Mod_init Interface
.sp
Some states need to execute something only once to ensure that an environment
has been set up, or certain conditions global to the state behavior can be
predefined. This is the realm of the mod_init interface.
.sp
A state module can have a function called \fBmod_init\fP which executes when the
first state of this type is called. This interface was created primarily to
improve the pkg state. When packages are installed the package metadata needs
to be refreshed, but refreshing the package metadata every time a package is
installed is wasteful. The mod_init function for the pkg state sets a flag down
so that the first, and only the first, package installation attempt will refresh
the package database (the package database can of course be manually called to
refresh via the \fBrefresh\fP option in the pkg state).
.sp
The mod_init function must accept the \fBLow State Data\fP for the given
executing state as an argument. The low state data is a dict and can be seen by
executing the state.show_lowstate function. Then the mod_init function must
return a bool. If the return value is True, then the mod_init function will not
be executed again, meaning that the needed behavior has been set up. Otherwise,
if the mod_init function returns False, then the function will be called the
next time.
.sp
A good example of the mod_init function is found in the pkg state module:
.sp
.nf
.ft C
def mod_init(low):
    \(aq\(aq\(aq
    Refresh the package database here so that it only needs to happen once
    \(aq\(aq\(aq
    if low[\(aqfun\(aq] == \(aqinstalled\(aq or low[\(aqfun\(aq] == \(aqlatest\(aq:
        rtag = __gen_rtag()
        if not os.path.exists(rtag):
            open(rtag, \(aqw+\(aq).write(\(aq\(aq)
        return True
    else:
        return False
.ft P
.fi
.sp
The mod_init function in the pkg state accepts the low state data as \fBlow\fP
and then checks to see if the function being called is going to install
packages, if the function is not going to install packages then there is no
need to refresh the package database. Therefore if the package database is
prepared to refresh, then return True and the mod_init will not be called
the next time a pkg state is evaluated, otherwise return False and the mod_init
will be called next time a pkg state is evaluated.
.SH FULL LIST OF BUILTIN STATE MODULES
.TS
center;
|l|l|.
_
T{
\fBalias\fP
T}	T{
Configuration of email aliases.
T}
_
T{
\fBalternatives\fP
T}	T{
Configuration of the alternatives system
T}
_
T{
\fBcmd\fP
T}	T{
Execution of arbitrary commands.
T}
_
T{
\fBcron\fP
T}	T{
Management of cron, the Unix command scheduler.
T}
_
T{
\fBdebconfmod\fP
T}	T{
Management of debconf selections.
T}
_
T{
\fBdisk\fP
T}	T{
Disk monitoring state
T}
_
T{
\fBeselect\fP
T}	T{
Management of Gentoo configuration using eselect
T}
_
T{
\fBfile\fP
T}	T{
Operations on files, directories and symlinks.
T}
_
T{
\fBgem\fP
T}	T{
Installation of Ruby modules packaged as gems.
T}
_
T{
\fBgit\fP
T}	T{
Interaction with Git repositories.
T}
_
T{
\fBgrains\fP
T}	T{
Manage grains on the minion.
T}
_
T{
\fBgroup\fP
T}	T{
Management of user groups.
T}
_
T{
\fBhg\fP
T}	T{
Interaction with Mercurial repositories.
T}
_
T{
\fBhost\fP
T}	T{
Management of addresses and names in hosts file.
T}
_
T{
\fBkeyboard\fP
T}	T{
Management of keyboard layouts
T}
_
T{
\fBkmod\fP
T}	T{
Loading and unloading of kernel modules.
T}
_
T{
\fBlayman\fP
T}	T{
Management of Gentoo Overlays using layman
T}
_
T{
\fBlibvirt\fP
T}	T{
Manage libvirt certs.
T}
_
T{
\fBlocale\fP
T}	T{
Management of languages/locales
T}
_
T{
\fBlvm\fP
T}	T{
Management of Linux logical volumes
T}
_
T{
\fBmakeconf\fP
T}	T{
Management of Gentoo make.conf
T}
_
T{
\fBmdadm\fP
T}	T{
Managing software RAID with mdadm
T}
_
T{
\fBmodule\fP
T}	T{
Execution of Salt modules from within states.
T}
_
T{
\fBmongodb_database\fP
T}	T{
Management of Mongodb databases
T}
_
T{
\fBmongodb_user\fP
T}	T{
Management of Mongodb users
T}
_
T{
\fBmount\fP
T}	T{
Mounting of filesystems.
T}
_
T{
\fBmysql_database\fP
T}	T{
Management of MySQL databases (schemas).
T}
_
T{
\fBmysql_grants\fP
T}	T{
Management of MySQL grants (user permissions).
T}
_
T{
\fBmysql_user\fP
T}	T{
Management of MySQL users.
T}
_
T{
\fBnetwork\fP
T}	T{
Configuration of network interfaces.
T}
_
T{
\fBnpm\fP
T}	T{
A state module to manage installed NPM packages.
T}
_
T{
\fBpecl\fP
T}	T{
Installation of PHP pecl extensions.
T}
_
T{
\fBpip\fP
T}	T{
Installation of Python packages using pip.
T}
_
T{
\fBpkgng\fP
T}	T{
Manage package remote repo using FreeBSD pkgng.
T}
_
T{
\fBpkg\fP
T}	T{
Installation of packages using OS package managers such as yum or apt\-get.
T}
_
T{
\fBpkgrepo\fP
T}	T{
Management of package repos
T}
_
T{
\fBpostgres_database\fP
T}	T{
Management of PostgreSQL databases.
T}
_
T{
\fBpostgres_group\fP
T}	T{
Management of PostgreSQL groups (roles).
T}
_
T{
\fBpostgres_user\fP
T}	T{
Management of PostgreSQL users (roles).
T}
_
T{
\fBquota\fP
T}	T{
Management of POSIX Quotas
T}
_
T{
\fBrabbitmq_user\fP
T}	T{
Manage RabbitMQ Users.
T}
_
T{
\fBrabbitmq_vhost\fP
T}	T{
Manage RabbitMQ Virtual Hosts.
T}
_
T{
\fBrbenv\fP
T}	T{
Managing Ruby installations with rbenv.
T}
_
T{
\fBrvm\fP
T}	T{
Managing Ruby installations and gemsets with Ruby Version Manager (RVM).
T}
_
T{
\fBselinux\fP
T}	T{
Management of SELinux rules.
T}
_
T{
\fBservice\fP
T}	T{
Starting or restarting of services and daemons.
T}
_
T{
\fBssh_auth\fP
T}	T{
Control of entries in SSH authorized_key files.
T}
_
T{
\fBssh_known_hosts\fP
T}	T{
Control of SSH known_hosts entries.
T}
_
T{
\fBstateconf\fP
T}	T{
Stateconf System
T}
_
T{
\fBsupervisord\fP
T}	T{
Interaction with the Supervisor daemon.
T}
_
T{
\fBsvn\fP
T}	T{
Manage SVN repositories
T}
_
T{
\fBsysctl\fP
T}	T{
Configuration of the Linux kernel using sysctrl.
T}
_
T{
\fBtimezone\fP
T}	T{
Management of timezones
T}
_
T{
\fBtomcat\fP
T}	T{
This state uses the manager webapp to manage Apache tomcat webapps
T}
_
T{
\fBuser\fP
T}	T{
Management of user accounts.
T}
_
T{
\fBvirtualenv\fP
T}	T{
Setup of Python virtualenv sandboxes.
T}
_
.TE
.SS salt.states.alias
.SS Configuration of email aliases.
.sp
The mail aliases file can be managed to contain definitions for specific email
aliases:
.sp
.nf
.ft C
username:
  alias.present:
    \- target: user@example.com
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.alias.absent(name)
Ensure that the named alias is absent
.INDENT 7.0
.TP
.B name
The alias to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.alias.present(name, target)
Ensures that the named alias is present with the given target
.INDENT 7.0
.TP
.B name
The local user/address to assign an alias to
.TP
.B target
The forwarding address
.UNINDENT
.UNINDENT
.SS salt.states.alternatives
.SS Configuration of the alternatives system
.sp
Control the alternatives system
.sp
.nf
.ft C
{% set my_hadoop_conf = \(aq/opt/hadoop/conf\(aq %}

{{ my_hadoop_conf }}:
  file.directory

hadoop\-0.20\-conf:
  alternatives.install:
    \- name: hadoop\-0.20\-conf
    \- link: /etc/hadoop\-0.20/conf
    \- path: {{ my_hadoop_conf }}
    \- priority: 30
    \- require:
      \- file: {{ my_hadoop_conf }}

hadoop\-0.20\-conf:
  alternatives.remove:
      \- name: hadoop\-0.20\-conf
      \- path: {{ my_hadoop_conf }}
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.alternatives.install(name, link, path, priority)
Install new alternative for defined <name>
.INDENT 7.0
.TP
.B name
is the master name for this link group
(e.g. pager)
.TP
.B link
is the symlink pointing to /etc/alternatives/<name>.
(e.g. /usr/bin/pager)
.TP
.B path
is the location of the new alternative target.
NB: This file / directory must already exist.
(e.g. /usr/bin/less)
.TP
.B priority
is an integer; options with higher numbers have higher priority in
automatic mode.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.alternatives.remove(name, path)
Removes installed alternative for defined <name> and <path>
or fallback to default alternative, if some defined before.
.INDENT 7.0
.TP
.B name
is the master name for this link group
(e.g. pager)
.TP
.B path
is the location of one of the alternative target files.
(e.g. /usr/bin/less)
.UNINDENT
.UNINDENT
.SS salt.states.cmd
.SS Execution of arbitrary commands.
.sp
The cmd state module manages the enforcement of executed commands, this
state can tell a command to run under certain circumstances.
.sp
A simple example to execute a command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
date > /tmp/salt\-run:
cmd:
    \- run
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Only run if another execution failed, in this case truncate
syslog if there is no disk space:
.sp
.nf
.ft C
> /var/log/messages:
  cmd.run:
    \- unless: echo \(aqfoo\(aq > /tmp/.test
.ft P
.fi
.sp
Note that when executing a command or script, the state (i.e., changed or not)
of the command is unknown to Salt\(aqs state system. Therefore, by default, the
\fBcmd\fP state assumes that any command execution results in a changed state.
.sp
This means that if a \fBcmd\fP state is watched by another state then the
state that\(aqs watching will always be executed due to the \fIchanged\fP state in
the \fBcmd\fP state.
.sp
Many state functions in this module now also accept a \fBstateful\fP argument.
If \fBstateful\fP is specified to be true then it is assumed that the command
or script will determine its own state and communicate it back by following
a simple protocol described below:
.INDENT 0.0
.INDENT 3.5
If there\(aqs nothing in the stdout of the command, then assume no changes.
Otherwise, the stdout must be either in JSON or its \fIlast\fP non\-empty line
must be a string of key=value pairs delimited by spaces(no spaces on the
sides of \fB=\fP).
.sp
If it\(aqs JSON then it must be a JSON object (e.g., {}).
If it\(aqs key=value pairs then quoting may be used to include spaces.
(Python\(aqs shlex module is used to parse the key=value string)
.sp
Two special keys or attributes are recognized in the output:
.sp
.nf
.ft C
changed: bool (i.e., \(aqyes\(aq, \(aqno\(aq, \(aqtrue\(aq, \(aqfalse\(aq, case\-insensitive)
comment: str  (i.e., any string)
.ft P
.fi
.sp
So, only if \(aqchanged\(aq is true then assume the command execution has changed
the state, and any other key values or attributes in the output will be set
as part of the changes.
.sp
If there\(aqs a comment then it will be used as the comment of the state.
.sp
Here\(aqs an example of how one might write a shell script for use with a
stateful command:
.sp
.nf
.ft C
#!/bin/bash
#
echo "Working hard..."

# writing the state line
echo  # an empty line here so the next line will be the last.
echo "changed=yes comment=\(aqsomething has changed\(aq whatever=123"
.ft P
.fi
.sp
And an example salt file using this module:
.sp
.nf
.ft C
Run myscript:
  cmd.run:
    \- name: /path/to/myscript
    \- cwd: /
    \- stateful: true

Run only if myscript changed something:
  cmd.wait:
    \- name: echo hello
    \- cwd: /
    \- watch:
      \- cmd: Run myscript
.ft P
.fi
.sp
Note that if the \fBcmd.wait\fP state also specifies \fBstateful: true\fP
it can then be watched by some other states as well.
.UNINDENT
.UNINDENT
.sp
\fBcmd.wait\fP is not restricted to watching only cmd states. For example
it can also watch a git state for changes
.sp
.nf
.ft C
# Watch for changes to a git repo and rebuild the project on updates
my\-project:
  git.latest:
    \- name: git@github.com/repo/foo
    \- target: /opt/foo
    \- rev: master
  cmd.wait:
    \- name: make install
    \- cwd: /opt/foo
    \- watch:
      \- git: my\-project
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.cmd.call(name, func, args=(), kws=None, onlyif=None, unless=None, **kwargs)
Invoke a pre\-defined Python function with arguments specified in the state
declaration. This function is mainly used by the
\fBsalt.renderers.pydsl\fP renderer.
.sp
The interpretation of \fIonlyif\fP and \fIunless\fP arguments are identical to
those of \fBsalt.states.cmd.run()\fP, and all other arguments(\fIcwd\fP,
\fIrunas\fP, ...) allowed by \fIcmd.run\fP are allowed here, except that their
effects apply only to the commands specified in \fIonlyif\fP and \fIunless\fP
rather than to the function to be invoked.
.sp
In addition the \fIstateful\fP argument has no effects here.
.sp
The return value of the invoked function will be interpreted as follows.
.sp
If it\(aqs a dictionary then it will be passed through to the state system,
which expects it to have the usual structure returned by any salt state
function.
.sp
Otherwise, the return value(denoted as \fBresult\fP in the code below) is
expected to be a JSON serializable object, and this dictionary is returned:
.sp
.nf
.ft C
{ \(aqchanges\(aq: { \(aqretval\(aq: result },
  \(aqresult\(aq: True if result is None else bool(result),
  \(aqcomment\(aq: result if isinstance(result, basestring) else \(aq\(aq
}
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.mod_watch(name, **kwargs)
Execute a cmd function based on a watch call
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.run(name, onlyif=None, unless=None, cwd=None, user=None, group=None, shell=None, env=(), stateful=False, umask=None, quiet=False, timeout=None, **kwargs)
Run a command if certain circumstances are met
.INDENT 7.0
.TP
.B name
The command to execute, remember that the command will execute with the
path and permissions of the salt\-minion.
.TP
.B onlyif
A command to run as a check, run the named command only if the command
passed to the \fBonlyif\fP option returns true
.TP
.B unless
A command to run as a check, only run the named command if the command
passed to the \fBunless\fP option returns false
.TP
.B cwd
The current working directory to execute the command in, defaults to
/root
.TP
.B user
The user name to run the command as
.TP
.B group
The group context to run the command as
.TP
.B shell
The shell to use for execution, defaults to the shell grain
.TP
.B env
Pass in a list or dict of environment variables to be applied to the
command upon execution
.TP
.B stateful
The command being executed is expected to return data about executing
a state
.TP
.B umask
The umask (in octal) to use when running the command.
.TP
.B quiet
The command will be executed quietly, meaning no log entries of the
actual command or its return data
.TP
.B timeout
If the command has not terminated after timeout seconds, send the
subprocess sigterm, and if sigterm is ignored, follow up with sigkill
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.script(name, source=None, template=None, onlyif=None, unless=None, cwd=None, user=None, group=None, shell=None, env=None, stateful=False, umask=None, timeout=None, **kwargs)
Download a script from a remote source and execute it. The name can be the
source or the source value can be defined.
.INDENT 7.0
.TP
.B source
The source script being downloaded to the minion, this source script is
hosted on the salt master server.  If the file is located on the master
in the directory named spam, and is called eggs, the source string is
salt://spam/eggs
.TP
.B template
If this setting is applied then the named templating engine will be
used to render the downloaded file, currently jinja, mako, and wempy
are supported
.TP
.B name
The command to execute, remember that the command will execute with the
path and permissions of the salt\-minion.
.TP
.B onlyif
A command to run as a check, run the named command only if the command
passed to the \fBonlyif\fP option returns true
.TP
.B unless
A command to run as a check, only run the named command if the command
passed to the \fBunless\fP option returns false
.TP
.B cwd
The current working directory to execute the command in, defaults to
/root
.TP
.B user
The user name to run the command as
.TP
.B group
The group context to run the command as
.TP
.B shell
The shell to use for execution, defaults to the shell grain
.TP
.B env
The root directory of the environment for the referencing script. The
environments are defined in the master config file.
.TP
.B umask
The umask (in octal) to use when running the command.
.TP
.B stateful
The command being executed is expected to return data about executing
a state
.TP
.B timeout
If the command has not terminated after timeout seconds, send the
subprocess sigterm, and if sigterm is ignored, follow up with sigkill
.TP
.B args
String of command line args to pass to the script.  Only used if no
args are specified as part of the \fIname\fP argument.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.wait(name, onlyif=None, unless=None, cwd=None, user=None, group=None, shell=None, stateful=False, umask=None, **kwargs)
Run the given command only if the watch statement calls it
.INDENT 7.0
.TP
.B name
The command to execute, remember that the command will execute with the
path and permissions of the salt\-minion.
.TP
.B onlyif
A command to run as a check, run the named command only if the command
passed to the \fBonlyif\fP option returns true
.TP
.B unless
A command to run as a check, only run the named command if the command
passed to the \fBunless\fP option returns false
.TP
.B cwd
The current working directory to execute the command in, defaults to
/root
.TP
.B user
The user name to run the command as
.TP
.B group
The group context to run the command as
.TP
.B shell
The shell to use for execution, defaults to /bin/sh
.TP
.B umask
The umask (in octal) to use when running the command.
.TP
.B stateful
The command being executed is expected to return data about executing
a state
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.wait_call(name, func, args=(), kws=None, onlyif=None, unless=None, stateful=False, **kwargs)
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cmd.wait_script(name, source=None, template=None, onlyif=None, unless=None, cwd=None, user=None, group=None, shell=None, env=None, stateful=False, umask=None, **kwargs)
Download a script from a remote source and execute it only if a watch
statement calls it.
.INDENT 7.0
.TP
.B source
The source script being downloaded to the minion, this source script is
hosted on the salt master server.  If the file is located on the master
in the directory named spam, and is called eggs, the source string is
salt://spam/eggs
.TP
.B template
If this setting is applied then the named templating engine will be
used to render the downloaded file, currently jinja, mako, and wempy
are supported
.TP
.B name
The command to execute, remember that the command will execute with the
path and permissions of the salt\-minion.
.TP
.B onlyif
A command to run as a check, run the named command only if the command
passed to the \fBonlyif\fP option returns true
.TP
.B unless
A command to run as a check, only run the named command if the command
passed to the \fBunless\fP option returns false
.TP
.B cwd
The current working directory to execute the command in, defaults to
/root
.TP
.B user
The user name to run the command as
.TP
.B group
The group context to run the command as
.TP
.B shell
The shell to use for execution, defaults to the shell grain
.TP
.B env
The root directory of the environment for the referencing script. The
environments are defined in the master config file.
.TP
.B umask
The umask (in octal) to use when running the command.
.TP
.B stateful
The command being executed is expected to return data about executing
a state
.UNINDENT
.UNINDENT
.SS salt.states.cron
.SS Management of cron, the Unix command scheduler.
.sp
The cron state module allows for user crontabs to be cleanly managed.
.sp
Cron declarations require a number of parameters. The timing parameters need
to be declared: minute, hour, daymonth, month, and dayweek. The user whose
crontab is to be edited also needs to be defined.
.sp
By default, the timing arguments are all \fB*\fP and the user is root. When
making changes to an existing cron job, the name declaration is the unique
factor, so if an existing cron that looks like this:
.sp
.nf
.ft C
date > /tmp/crontest:
  cron.present:
    \- user: root
    \- minute: 5
.ft P
.fi
.sp
Is changed to this:
.sp
.nf
.ft C
date > /tmp/crontest:
  cron.present:
    \- user: root
    \- minute: 7
    \- hour: 2
.ft P
.fi
.sp
Then the existing cron will be updated, but if the cron command is changed,
then a new cron job will be added to the user\(aqs crontab.
.sp
Additionally, the temporal parameters (minute, hour, etc.) can be randomized by
using \fBrandom\fP instead of using a specific value. For example, by using the
\fBrandom\fP keyword in the \fBminute\fP parameter of a cron state, the same cron
job can be pushed to hundreds or thousands of hosts, and they would each use a
randomly\-generated minute. This can be helpful when the cron job accesses a
network resource, and it is not desirable for all hosts to run the job
concurrently.
.sp
.nf
.ft C
/path/to/cron/script:
  cron.present:
    \- user: root
    \- minute: random
    \- hour: 2
.ft P
.fi
.sp
New in version 0.16.0.
.sp
Since Salt assumes a value of \fB*\fP for unspecified temporal parameters, adding
a parameter to the state and setting it to \fBrandom\fP will change that value
from \fB*\fP to a randomized numeric value. However, if that field in the cron
entry on the minion already contains a numeric value, then using the \fBrandom\fP
keyword will not modify it.
.INDENT 0.0
.TP
.B salt.states.cron.absent(name, user=\(aqroot\(aq, **kwargs)
Verifies that the specified cron job is absent for the specified user; only
the name is matched when removing a cron job.
.INDENT 7.0
.TP
.B name
The command that should be absent in the user crontab.
.TP
.B user
The name of the user who\(aqs crontab needs to be modified, defaults to
the root user
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cron.file(name, source_hash=\(aq\(aq, user=\(aqroot\(aq, template=None, context=None, replace=True, defaults=None, env=None, backup=\(aq\(aq, **kwargs)
Provides file.managed\-like functionality (templating, etc.) for a pre\-made
crontab file, to be assigned to a given user.
.INDENT 7.0
.TP
.B name
The source file to be used as the crontab. This source file can be
hosted on either the salt master server, or on an HTTP or FTP server.
For files hosted on the salt file server, if the file is located on
the master in the directory named spam, and is called eggs, the source
string is salt://spam/eggs.
.sp
If the file is hosted on a HTTP or FTP server then the source_hash
argument is also required
.TP
.B source_hash
This can be either a file which contains a source hash string for
the source, or a source hash string. The source hash string is the
hash algorithm followed by the hash of the file:
md5=e138491e9d5b97023cea823fe17bac22
.TP
.B user
The user to whom the crontab should be assigned. This defaults to
root.
.TP
.B template
If this setting is applied then the named templating engine will be
used to render the downloaded file. Currently, jinja and mako are
supported.
.TP
.B context
Overrides default context variables passed to the template.
.TP
.B replace
If the crontab should be replaced, if False then this command will
be ignored if a crontab exists for the specified user. Default is True.
.TP
.B defaults
Default context passed to the template.
.TP
.B backup
Overrides the default backup mode for the user\(aqs crontab.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.cron.present(name, user=\(aqroot\(aq, minute=\(aq*\(aq, hour=\(aq*\(aq, daymonth=\(aq*\(aq, month=\(aq*\(aq, dayweek=\(aq*\(aq)
Verifies that the specified cron job is present for the specified user.
For more advanced information about what exactly can be set in the cron
timing parameters, check your cron system\(aqs documentation. Most Unix\-like
systems\(aq cron documentation can be found via the crontab man page:
\fBman 5 crontab\fP.
.INDENT 7.0
.TP
.B name
The command that should be executed by the cron job.
.TP
.B user
The name of the user who\(aqs crontab needs to be modified, defaults to
the root user
.TP
.B minute
The information to be set into the minute section, this can be any
string supported by your cron system\(aqs the minute field. Default is
\fB*\fP
.TP
.B hour
The information to be set in the hour section. Default is \fB*\fP
.TP
.B daymonth
The information to be set in the day of month section. Default is \fB*\fP
.TP
.B month
The information to be set in the month section. Default is \fB*\fP
.TP
.B dayweek
The information to be set in the day of week section. Default is \fB*\fP
.UNINDENT
.UNINDENT
.SS salt.states.debconfmod
.SS Management of debconf selections.
.sp
The debconfmod state module manages the enforcement of debconf selections,
this state can set those selections prior to package installation.
.SS Available Functions
.sp
The debconfmod state has two functions, the \fBset\fP and \fBset_file\fP functions
.INDENT 0.0
.TP
.B set
Set debconf selections from the state itself
.TP
.B set_file
Set debconf selections from a file
.UNINDENT
.sp
.nf
.ft C
nullmailer\-debconf:
  debconf.set:
    \- name: nullmailer
    \- data:
        \(aqshared/mailname\(aq: {\(aqtype\(aq: \(aqstring\(aq, \(aqvalue\(aq: \(aqserver.domain.tld\(aq}
        \(aqnullmailer/relayhost\(aq: {\(aqtype\(aq: \(aqstring\(aq, \(aqvalue\(aq: \(aqmail.domain.tld\(aq}
ferm\-debconf:
  debconf.set:
    \- name: ferm
    \- data:
        \(aqferm/enable\(aq: {\(aqtype\(aq: \(aqboolean\(aq, \(aqvalue\(aq: True}
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.debconfmod.set(name, data)
Set debconf selections
.sp
.nf
.ft C
<state_id>:
  debconf.set:
    \- name: <name>
    \- data:
        <question>: {\(aqtype\(aq: <type>, \(aqvalue\(aq: <value>}
        <question>: {\(aqtype\(aq: <type>, \(aqvalue\(aq: <value>}

<state_id>:
  debconf.set:
    \- name: <name>
    \- data:
        <question>: {\(aqtype\(aq: <type>, \(aqvalue\(aq: <value>}
        <question>: {\(aqtype\(aq: <type>, \(aqvalue\(aq: <value>}
.ft P
.fi
.INDENT 7.0
.TP
.B name:
The package name to set answers for.
.TP
.B data:
A set of questions/answers for debconf. Note that everything under
this must be indented twice.
.TP
.B question:
The question the is being pre\-answered
.TP
.B type:
The type of question that is being asked (string, boolean, select, etc.)
.TP
.B value:
The answer to the question
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.debconfmod.set_file(name, source, **kwargs)
Set debconf selections from a file
.sp
.nf
.ft C
<state_id>:
  debconf.set_file:
    \- source: salt://pathto/pkg.selections

<state_id>:
  debconf.set_file:
    \- source: salt://pathto/pkg.selections?env=myenvironment
.ft P
.fi
.INDENT 7.0
.TP
.B source:
The location of the file containing the package selections
.UNINDENT
.UNINDENT
.SS salt.states.disk
.sp
Disk monitoring state
.sp
Monitor the state of disk resources
.INDENT 0.0
.TP
.B salt.states.disk.status(name, max=None, min=None)
Return the current disk usage stats for the named device
.UNINDENT
.SS salt.states.eselect
.SS Management of Gentoo configuration using eselect
.sp
A state module to manage Gentoo configuration via eselect
.sp
.nf
.ft C
profile:
    eselect.set:
        target: hardened/linux/amd64
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.eselect.set_(name, target)
Verify that the given module is set to the given target
.INDENT 7.0
.TP
.B name
The name of the module
.UNINDENT
.UNINDENT
.SS salt.states.file
.SS Operations on files, directories and symlinks.
.sp
Salt States can aggressively manipulate files on a system. There are a number
of ways in which files can be managed.
.sp
Regular files can be enforced with the \fBmanaged\fP function. This function
downloads files from the salt master and places them on the target system.
The downloaded files can be rendered as a jinja, mako, or wempy template,
adding a dynamic component to file management. An example of \fBfile.managed\fP
which makes use of the jinja templating system would look like this:
.sp
.nf
.ft C
/etc/http/conf/http.conf:
  file.managed:
    \- source: salt://apache/http.conf
    \- user: root
    \- group: root
    \- mode: 644
    \- template: jinja
    \- context:
        custom_var: "override"
    \- defaults:
        custom_var: "default value"
        other_var: 123
.ft P
.fi
.sp
The \fBsource\fP parameter can be specified as a list. If this is done, then the
first file to be matched will be the one that is used. This allows you to have
a default file on which to fall back if the desired file does not exist on the
salt fileserver. Here\(aqs an example:
.sp
.nf
.ft C
/etc/foo.conf:
  file.managed:
    \- source:
      \- salt://foo.conf.{{ grains[\(aqfqdn\(aq] }}
      \- salt://foo.conf.fallback
    \- user: foo
    \- group: users
    \- mode: 644
.ft P
.fi
.sp
The \fBsource\fP parameter can also specify a file in another Salt environment.
In this example \fBfoo.conf\fP in the \fBdev\fP environment will be used instead.
.sp
.nf
.ft C
/etc/foo.conf:
  file.managed:
    \- source:
      \- salt://foo.conf?env=dev
    \- user: foo
    \- group: users
    \- mode: 644
.ft P
.fi
.sp
Directories can be managed via the \fBdirectory\fP function. This function can
create and enforce the permissions on a directory. A directory statement will
look like this:
.sp
.nf
.ft C
/srv/stuff/substuf:
  file.directory:
    \- user: fred
    \- group: users
    \- mode: 755
    \- makedirs: True
.ft P
.fi
.sp
If you need to enforce user and/or group ownership or permissions recursively
on the directory\(aqs contents, you can do so by adding a \fBrecurse\fP directive:
.sp
.nf
.ft C
/srv/stuff/substuf:
  file.directory:
    \- user: fred
    \- group: users
    \- mode: 755
    \- makedirs: True
    \- recurse:
      \- user
      \- group
      \- mode
.ft P
.fi
.sp
As a default, \fBmode\fP will resolve to \fBdir_mode\fP and \fBfile_mode\fP, to
specify both directory and file permissions, use this form:
.sp
.nf
.ft C
/srv/stuff/substuf:
  file.directory:
    \- user: fred
    \- group: users
    \- file_mode: 744
    \- dir_mode: 755
    \- makedirs: True
    \- recurse:
      \- user
      \- group
      \- mode
.ft P
.fi
.sp
Symlinks can be easily created; the symlink function is very simple and only
takes a few arguments:
.sp
.nf
.ft C
/etc/grub.conf:
  file.symlink:
    \- target: /boot/grub/grub.conf
.ft P
.fi
.sp
Recursive directory management can also be set via the \fBrecurse\fP
function. Recursive directory management allows for a directory on the salt
master to be recursively copied down to the minion. This is a great tool for
deploying large code and configuration systems. A state using \fBrecurse\fP
would look something like this:
.sp
.nf
.ft C
/opt/code/flask:
  file.recurse:
    \- source: salt://code/flask
    \- include_empty: True
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.file.absent(name)
Verify that the named file or directory is absent, this will work to
reverse any of the functions in the file state module.
.INDENT 7.0
.TP
.B name
The path which should be deleted
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.accumulated(name, filename, text, **kwargs)
Prepare accumulator which can be used in template in file.managed state.
accumulator dictionary becomes available in template.
.INDENT 7.0
.TP
.B name
Accumulator name
.TP
.B filename
Filename which would receive this accumulator (see file.managed state
documentation about \fBname\fP)
.TP
.B text
String or list for adding in accumulator
.TP
.B require_in / watch_in
One of them required for sure we fill up accumulator before we manage
the file. Probably the same as filename
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.append(name, text=None, makedirs=False, source=None, source_hash=None, __env__=\(aqbase\(aq)
Ensure that some text appears at the end of a file
.sp
The text will not be appended again if it already exists in the file. You
may specify a single line of text or a list of lines to append.
.sp
Multi\-line example:
.sp
.nf
.ft C
/etc/motd:
  file.append:
    \- text: |
        Thou hadst better eat salt with the Philosophers of Greece,
        than sugar with the Courtiers of Italy.
        \- Benjamin Franklin
.ft P
.fi
.sp
Multiple lines of text:
.sp
.nf
.ft C
/etc/motd:
  file.append:
    \- text:
      \- Trust no one unless you have eaten much salt with him.
      \- Salt is born of the purest of parents: the sun and the sea.
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.comment(name, regex, char=\(aq#\(aq, backup=\(aq.bak\(aq)
Comment out specified lines in a file.
.INDENT 7.0
.TP
.B name
The full path to the file to be edited
.TP
.B regex
A regular expression used to find the lines that are to be commented;
this pattern will be wrapped in parenthesis and will move any
preceding/trailing \fB^\fP or \fB$\fP characters outside the parenthesis
(e.g., the pattern \fB^foo$\fP will be rewritten as \fB^(foo)$\fP)
Note that you _need_ the leading ^, otherwise each time you run
highstate, another comment char will be inserted.
.TP
.B char
\fB#\fP
The character to be inserted at the beginning of a line in order to
comment it out
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension
.IP Warning
This backup will be overwritten each time \fBsed\fP / \fBcomment\fP /
\fBuncomment\fP is called. Meaning the backup will only be useful
after the first invocation.
.RE
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
/etc/fstab:
  file.comment:
    \- regex: ^bind 127.0.0.1
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.directory(name, user=None, group=None, recurse=None, dir_mode=None, file_mode=None, makedirs=False, clean=False, require=None, exclude_pat=None, **kwargs)
Ensure that a named directory is present and has the right perms
.INDENT 7.0
.TP
.B name
The location to create or manage a directory
.TP
.B user
The user to own the directory; this defaults to the user salt is
running as on the minion
.TP
.B group
The group ownership set for the directory; this defaults to the group
salt is running as on the minion
.TP
.B recurse
Enforce user/group ownership and mode of directory recursively. Accepts
a list of strings representing what you would like to recurse.
Example:
.sp
.nf
.ft C
/var/log/httpd:
    file.directory:
    \- user: root
    \- group: root
    \- dir_mode: 755
    \- file_mode: 644
    \- recurse:
        \- user
        \- group
        \- mode
.ft P
.fi
.TP
.B dir_mode / mode
The permissions mode to set any directories created.
.TP
.B file_mode
The permissions mode to set any files created if \(aqmode\(aq is ran in
\(aqrecurse\(aq. This defaults to dir_mode.
.TP
.B makedirs
If the directory is located in a path without a parent directory, then
the state will fail. If makedirs is set to True, then the parent
directories will be created to facilitate the creation of the named
file.
.TP
.B clean
Make sure that only files that are set up by salt and required by this
function are kept. If this option is set then everything in this
directory will be deleted unless it is required.
.TP
.B require
Require other resources such as packages or files
.TP
.B exclude_pat
When \(aqclean\(aq is set to True, exclude this pattern from removal list
and preserve in the destination.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.exists(name)
Verify that the named file or directory is present or exists.
Ensures pre\-requisites outside of Salt\(aqs purview
(e.g., keytabs, private keys, etc.) have been previously satisfied before
deployment.
.INDENT 7.0
.TP
.B name
Absolute path which must exist
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.managed(name, source=None, source_hash=\(aq\(aq, user=None, group=None, mode=None, template=None, makedirs=False, context=None, replace=True, defaults=None, env=None, backup=\(aq\(aq, show_diff=True, create=True, contents=None, **kwargs)
Manage a given file, this function allows for a file to be downloaded from
the salt master and potentially run through a templating system.
.INDENT 7.0
.TP
.B name
The location of the file to manage
.TP
.B source
The source file to download to the minion, this source file can be
hosted on either the salt master server, or on an HTTP or FTP server.
For files hosted on the salt file server, if the file is located on
the master in the directory named spam, and is called eggs, the source
string is salt://spam/eggs. If source is left blank or None, the file
will be created as an empty file and the content will not be managed
.sp
If the file is hosted on a HTTP or FTP server then the source_hash
argument is also required
.TP
.B source_hash:
This can be either a file which contains a source hash string for
the source, or a source hash string. The source hash string is the
hash algorithm followed by the hash of the file:
md5=e138491e9d5b97023cea823fe17bac22
.sp
The file can contain checksums for several files, in this case every
line must consist of full name of the file and checksum separated by
space:
.sp
Example:
.sp
.nf
.ft C
/etc/rc.conf md5=ef6e82e4006dee563d98ada2a2a80a27
/etc/resolv.conf sha256=c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a
.ft P
.fi
.TP
.B user
The user to own the file, this defaults to the user salt is running as
on the minion
.TP
.B group
The group ownership set for the file, this defaults to the group salt
is running as on the minion
.TP
.B mode
The permissions to set on this file, aka 644, 0775, 4664
.TP
.B template
If this setting is applied then the named templating engine will be
used to render the downloaded file, currently jinja, mako, and wempy
are supported
.TP
.B makedirs
If the file is located in a path without a parent directory, then
the state will fail. If makedirs is set to True, then the parent
directories will be created to facilitate the creation of the named
file.
.TP
.B replace
If this file should be replaced.  If false, this command will
not overwrite file contents but will enforce permissions if the file
exists already.  Default is True.
.TP
.B context
Overrides default context variables passed to the template.
.TP
.B defaults
Default context passed to the template.
.TP
.B backup
Overrides the default backup mode for this specific file.
.TP
.B show_diff
If set to False, the diff will not be shown.
.TP
.B create
Default is True, if create is set to False then the file will only be
managed if the file already exists on the system.
.TP
.B contents
Default is None.  If specified, will use the given string as the
contents of the file.  Should not be used in conjunction with a source
file of any kind.  Ignores hashes and does not use a templating engine.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.patch(name, source=None, hash=None, options=\(aq\(aq, dry_run_first=True, env=\(aqbase\(aq)
Apply a patch to a file. Note: a suitable \fBpatch\fP executable must be
available on the minion when using this state function.
.INDENT 7.0
.TP
.B name
The file to with the patch will be applied.
.TP
.B source
The source patch to download to the minion, this source file must be
hosted on the salt master server. If the file is located in the
directory named spam, and is called eggs, the source string is
salt://spam/eggs. A source is required.
.TP
.B hash
Hash of the patched file. If the hash of the target file matches this
value then the patch is assumed to have been applied. The hash string
is the hash algorithm followed by the hash of the file:
md5=e138491e9d5b97023cea823fe17bac22
.TP
.B options
Extra options to pass to patch.
.TP
.B dry_run_first
\fBTrue\fP
Run patch with \fB\-\-dry\-run\fP first to check if it will apply cleanly.
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
# Equivalent to \(ga\(gapatch \-\-forward /opt/file.txt file.patch\(ga\(ga
/opt/file.txt:
  file.patch:
    \- source: salt://file.patch
    \- hash: md5=e138491e9d5b97023cea823fe17bac22
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.recurse(name, source, clean=False, require=None, user=None, group=None, dir_mode=None, file_mode=None, template=None, context=None, defaults=None, env=None, include_empty=False, backup=\(aq\(aq, include_pat=None, exclude_pat=None, maxdepth=None, **kwargs)
Recurse through a subdirectory on the master and copy said subdirectory
over to the specified path.
.INDENT 7.0
.TP
.B name
The directory to set the recursion in
.TP
.B source
The source directory, this directory is located on the salt master file
server and is specified with the salt:// protocol. If the directory is
located on the master in the directory named spam, and is called eggs,
the source string is salt://spam/eggs
.TP
.B clean
Make sure that only files that are set up by salt and required by this
function are kept. If this option is set then everything in this
directory will be deleted unless it is required.
.TP
.B require
Require other resources such as packages or files
.TP
.B user
The user to own the directory, this defaults to the user salt is
running as on the minion
.TP
.B group
The group ownership set for the directory, this defaults to the group
salt is running as on the minion
.TP
.B dir_mode
The permissions mode to set any directories created
.TP
.B file_mode
The permissions mode to set any files created
.TP
.B template
If this setting is applied then the named templating engine will be
used to render the downloaded file, currently jinja, mako, and wempy
are supported
.TP
.B context
Overrides default context variables passed to the template.
.TP
.B defaults
Default context passed to the template.
.TP
.B include_empty
Set this to True if empty directories should also be created
(default is False)
.TP
.B include_pat
When copying, include only this pattern from the source. Default
is glob match; if prefixed with \(aqE@\(aq, then regexp match.
Example:
.sp
.nf
.ft C
\- include_pat: hello*       :: glob matches \(aqhello01\(aq, \(aqhello02\(aq
                               ... but not \(aqotherhello\(aq
\- include_pat: E@hello      :: regexp matches \(aqotherhello\(aq,
                               \(aqhello01\(aq ...
.ft P
.fi
.TP
.B exclude_pat
When copying, exclude this pattern from the source. If both
include_pat and exclude_pat are supplied, then it will apply
conditions cumulatively. i.e. first select based on include_pat, and
then within that result apply exclude_pat.
.sp
Also, when \(aqclean=True\(aq, exclude this pattern from the removal
list and preserve in the destination.
Example:
.sp
.nf
.ft C
\- exclude_pat: APPDATA*               :: glob matches APPDATA.01,
                                         APPDATA.02,.. for exclusion
\- exclude_pat: E@(APPDATA)|(TEMPDATA) :: regexp matches APPDATA
                                         or TEMPDATA for exclusion
.ft P
.fi
.TP
.B maxdepth
When copying, only copy paths which are depth maxdepth from the source
path.
Example:
.sp
.nf
.ft C
\- maxdepth: 0      :: Only include files located in the source
                      directory
\- maxdepth: 1      :: Only include files located in the source
                      or immediate subdirectories
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.rename(name, source, force=False, makedirs=False)
If the source file exists on the system, rename it to the named file. The
named file will not be overwritten if it already exists unless the force
option is set to True.
.INDENT 7.0
.TP
.B name
The location of the file to rename to
.TP
.B source
The location of the file to move to the location specified with name
.TP
.B force:
If the target location is present then the file will not be moved,
specify "force: True" to overwrite the target file
.TP
.B makedirs:
If the target subdirectories don\(aqt exist create them
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.sed(name, before, after, limit=\(aq\(aq, backup=\(aq.bak\(aq, options=\(aq\-r \-e\(aq, flags=\(aqg\(aq)
Maintain a simple edit to a file
.sp
The file will be searched for the \fBbefore\fP pattern before making the
edit.  In general the \fBlimit\fP pattern should be as specific as possible
and \fBbefore\fP and \fBafter\fP should contain the minimal text to be changed.
.INDENT 7.0
.TP
.B before
A pattern that should exist in the file before the edit.
.TP
.B after
A pattern that should exist in the file after the edit.
.TP
.B limit
An optional second pattern that can limit the scope of the before
pattern.
.TP
.B backup
\(aq.bak\(aq
The extension for the backed\-up version of the file before the edit. If
no backups is desired, pass in the empty string: \(aq\(aq
.TP
.B options
\fB\-r \-e\fP
Any options to pass to the \fBsed\fP command. \fB\-r\fP uses extended
regular expression syntax and \fB\-e\fP denotes that what follows is an
expression that sed will execute.
.TP
.B flags
\fBg\fP
Any flags to append to the sed expression. \fBg\fP specifies the edit
should be made globally (and not stop after the first replacement).
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
# Disable the epel repo by default
/etc/yum.repos.d/epel.repo:
  file.sed:
    \- before: 1
    \- after: 0
    \- limit: ^enabled=

# Remove ldap from nsswitch
/etc/nsswitch.conf:
  file.sed:
    \- before: \(aqldap\(aq
    \- after: \(aq\(aq
    \- limit: \(aq^passwd:\(aq
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.symlink(name, target, force=False, makedirs=False, user=None, group=None, mode=None, **kwargs)
Create a symlink
.sp
If the file already exists and is a symlink pointing to any location other
than the specified target, the symlink will be replaced. If the symlink is
a regular file or directory then the state will return False. If the
regular file or directory is desired to be replaced with a symlink pass
force: True.
.INDENT 7.0
.TP
.B name
The location of the symlink to create
.TP
.B target
The location that the symlink points to
.TP
.B force
If the location of the symlink exists and is not a symlink then the
state will fail, set force to True and any file or directory in the way
of the symlink file will be deleted to make room for the symlink
.TP
.B makedirs
If the location of the symlink does not already have a parent directory
then the state will fail, setting makedirs to True will allow Salt to
create the parent directory
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.touch(name, atime=None, mtime=None, makedirs=False)
Replicate the \(aqnix "touch" command to create a new empty
file or update the atime and mtime of an existing file.
.sp
Note that if you just want to create a file and don\(aqt care about atime or
mtime, you should use \fBfile.managed\fP instead, as it is more
feature\-complete.  (Just leave out the \fBsource\fP/\fBtemplate\fP/\fBcontents\fP
arguments, and it will just create the file and/or check its permissions,
without messing with contents)
.INDENT 7.0
.TP
.B name
name of the file
.TP
.B atime
atime of the file
.TP
.B mtime
mtime of the file
.TP
.B makedirs
whether we should create the parent directory/directories in order to
touch the file
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
/var/log/httpd/logrotate.empty:
  file.touch
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.file.uncomment(name, regex, char=\(aq#\(aq, backup=\(aq.bak\(aq)
Uncomment specified commented lines in a file
.INDENT 7.0
.TP
.B name
The full path to the file to be edited
.TP
.B regex
A regular expression used to find the lines that are to be uncommented.
This regex should not include the comment character. A leading \fB^\fP
character will be stripped for convenience (for easily switching
between comment() and uncomment()).  The regex will be searched for
from the beginning of the line, ignoring leading spaces (we prepend
\(aq^[ t]*\(aq)
.TP
.B char
\fB#\fP
The character to remove in order to uncomment a line
.TP
.B backup
\fB.bak\fP
The file will be backed up before edit with this file extension;
\fBWARNING:\fP each time \fBsed\fP/\fBcomment\fP/\fBuncomment\fP is called will
overwrite this backup
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
/etc/adduser.conf:
  file.uncomment:
    \- regex: EXTRA_GROUPS
.ft P
.fi
.sp
New in version 0.9.5.
.UNINDENT
.SS salt.states.gem
.SS Installation of Ruby modules packaged as gems.
.sp
A state module to manage rubygems. Gems can be set up to be installed
or removed. This module will use RVM if it is installed. In that case,
you can specify what ruby version and gemset to target.
.sp
.nf
.ft C
addressable:
  gem.installed:
    \- runas: rvm
    \- ruby: jruby@jgemset
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.gem.installed(name, ruby=None, runas=None, version=None, rdoc=False, ri=False)
Make sure that a gem is installed.
.INDENT 7.0
.TP
.B name
The name of the gem to install
.TP
.B ruby
None
For RVM installations: the ruby version and gemset to target.
.TP
.B runas
None
The user to run gem as.
.TP
.B version
None
Specify the version to install for the gem.
Doesn\(aqt play nice with multiple gems at once
.TP
.B rdoc
False
Generate RDoc documentation for the gem(s).
.TP
.B ri
False
Generate RI documentation for the gem(s).
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.gem.removed(name, ruby=None, runas=None)
Make sure that a gem is not installed.
.INDENT 7.0
.TP
.B name
The name of the gem to uninstall
.TP
.B ruby
None
For RVM installations: the ruby version and gemset to target.
.TP
.B runas
None
The user to run gem as.
.UNINDENT
.UNINDENT
.SS salt.states.git
.SS Interaction with Git repositories.
.sp
NOTE: This module is under heavy development and the API is subject to change.
It may be replaced with a generic VCS module if this proves viable.
.sp
Important: Before using git over ssh, make sure your remote host fingerprint
exists in "~/.ssh/known_hosts" file. To avoid requiring password
authentication, it is also possible to pass private keys to use explicitly.
.sp
.nf
.ft C
https://github.com/saltstack/salt.git:
  git.latest:
    \- rev: develop
    \- target: /tmp/salt
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.git.latest(name, rev=None, target=None, runas=None, force=None, force_checkout=False, submodules=False, mirror=False, bare=False, remote_name=\(aqorigin\(aq, always_fetch=False, identity=None)
Make sure the repository is cloned to the given directory and is up to date
.INDENT 7.0
.TP
.B name
Address of the remote repository as passed to "git clone"
.TP
.B rev
The remote branch, tag, or revision ID to checkout after
clone / before update
.TP
.B target
Name of the target directory where repository is about to be cloned
.TP
.B runas
Name of the user performing repository management operations
.TP
.B force
Force git to clone into pre\-existing directories (deletes contents)
.TP
.B force_checkout
Force a checkout even if there might be overwritten changes
(Default: False)
.TP
.B submodules
Update submodules on clone or branch change (Default: False)
.TP
.B mirror
True if the repository is to be a mirror of the remote repository.
This implies bare, and thus is incompatible with rev.
.TP
.B bare
True if the repository is to be a bare clone of the remote repository.
This is incompatible with rev, as nothing will be checked out.
.TP
.B remote_name
defines a different remote name.
For the first clone the given name is set to the default remote,
else it is just a additional remote. (Default: \(aqorigin\(aq)
.TP
.B always_fetch
If a tag or branch name is used as the rev a fetch will not occur
until the tag or branch name changes. Setting this to true will force
a fetch to occur. Only applies when rev is set. (Default: False)
.TP
.B identity
A path to a private key to use over SSH
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.git.present(name, bare=True, runas=None, force=False)
Make sure the repository is present in the given directory
.INDENT 7.0
.TP
.B name
Name of the directory where the repository is about to be created
.TP
.B bare
Create a bare repository (Default: True)
.TP
.B runas
Name of the user performing repository management operations
.TP
.B force
Force\-create a new repository into an pre\-existing non\-git directory
(deletes contents)
.UNINDENT
.UNINDENT
.SS salt.states.grains
.SS Manage grains on the minion.
.sp
This state allows for grains to be set. If a grain with the
given name exists, its value is updated to the new value. If
a grain does not yet exist, a new grain is set to the given
value. Grains set or altered this way are stored in the \(aqgrains\(aq
file on the minions, by default at: /etc/salt/grains
.sp
Note: This does NOT override any grains set in the minion file.
.sp
.nf
.ft C
cheese:
  grains.present:
    \- value: edam
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.grains.present(name, value)
Ensure that a grain is set
.INDENT 7.0
.TP
.B name
The grain name
.TP
.B value
The value to set on the grain
.UNINDENT
.UNINDENT
.SS salt.states.group
.SS Management of user groups.
.sp
The group module is used to create and manage unix group settings, groups
can be either present or absent:
.sp
.nf
.ft C
cheese:
  group.present:
    \- gid: 7648
    \- system: True
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.group.absent(name)
Ensure that the named group is absent
.INDENT 7.0
.TP
.B name
The name of the group to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.group.present(name, gid=None, system=False)
Ensure that a group is present
.INDENT 7.0
.TP
.B name
The name of the group to manage
.TP
.B gid
The group id to assign to the named group; if left empty, then the next
available group id will be assigned
.TP
.B system
Whether or not the named group is a system group.  This is essentially
the \(aq\-r\(aq option of \(aqgroupadd\(aq.
.UNINDENT
.UNINDENT
.SS salt.states.hg
.SS Interaction with Mercurial repositories.
.sp
NOTE: This module is currently experimental. Most of this code is copied from
git.py with changes to handle hg.
.sp
Before using hg over ssh, make sure the remote host fingerprint already exists
in ~/.ssh/known_hosts, and the remote host has this host\(aqs public key.
.sp
.nf
.ft C
https://bitbucket.org/example_user/example_repo:
    hg.latest:
      \- rev: tip
      \- target: /tmp/example_repo
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.hg.latest(name, rev=None, target=None, runas=None, force=False)
Make sure the repository is cloned to the given directory and is up to date
.INDENT 7.0
.TP
.B name
Address of the remote repository as passed to "hg clone"
.TP
.B rev
The remote branch, tag, or revision hash to clone/pull
.TP
.B target
Name of the target directory where repository is about to be cloned
.TP
.B runas
Name of the user performing repository management operations
.TP
.B force
Force hg to clone into pre\-existing directories (deletes contents)
.UNINDENT
.UNINDENT
.SS salt.states.host
.SS Management of addresses and names in hosts file.
.sp
The /etc/hosts file can be managed to contain definitions for specific hosts:
.sp
.nf
.ft C
salt\-master:
  host.present:
    \- ip: 192.168.0.42
.ft P
.fi
.sp
Or using the "names:" directive, you can put several names for the same IP.
(Do not try one name with space\-separated values).
.sp
.nf
.ft C
server1:
  host.present:
    \- ip: 192.168.0.42
    \- names:
      \- server1
      \- florida
.ft P
.fi
.sp
NOTE: changing the IP or name(s) in the present() function does not cause an
update to remove the old entry.
.INDENT 0.0
.TP
.B salt.states.host.absent(name, ip)
Ensure that the named host is absent
.INDENT 7.0
.TP
.B name
The host to remove
.TP
.B ip
The ip addr of the host to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.host.present(name, ip)
Ensures that the named host is present with the given ip
.INDENT 7.0
.TP
.B name
The host to assign an ip to
.TP
.B ip
The ip addr to apply to the host
.UNINDENT
.UNINDENT
.SS salt.states.keyboard
.SS Management of keyboard layouts
.sp
The keyboard layout can be managed for the system:
.sp
.nf
.ft C
us:
  keyboard.system
.ft P
.fi
.sp
Or it can be managed for XOrg:
.sp
.nf
.ft C
us:
  keyboard.xorg
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.keyboard.system(name)
Set the keyboard layout for the system
.INDENT 7.0
.TP
.B name
The keyboard layout to use
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.keyboard.xorg(name)
Set the keyboard layout for XOrg
.INDENT 7.0
.TP
.B layout
The keyboard layout to use
.UNINDENT
.UNINDENT
.SS salt.states.kmod
.SS Loading and unloading of kernel modules.
.sp
The Kernel modules on a system can be managed cleanly with the kmod state
module:
.sp
.nf
.ft C
kvm_amd:
  kmod.present
pcspkr:
  kmod.absent
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.kmod.absent(name, persist=False, comment=True)
Verify that the named kernel module is not loaded
.INDENT 7.0
.TP
.B name
The name of the kernel module to verify is not loaded
.TP
.B persist
Delete module from /etc/modules
.TP
.B comment
Don\(aqt remove module from /etc/modules, only comment it
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.kmod.present(name, persist=False)
Ensure that the specified kernel module is loaded
.INDENT 7.0
.TP
.B name
The name of the kernel module to verify is loaded
.TP
.B persist
Also add module to /etc/modules
.UNINDENT
.UNINDENT
.SS salt.states.layman
.SS Management of Gentoo Overlays using layman
.sp
A state module to manage Gentoo package overlays via layman
.sp
.nf
.ft C
sunrise:
    layman.present
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.layman.absent(name)
Verify that the overlay is absent
.INDENT 7.0
.TP
.B name
The name of the overlay to delete
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.layman.present(name)
Verify that the overlay is present
.INDENT 7.0
.TP
.B name
The name of the overlay to add
.UNINDENT
.UNINDENT
.SS salt.states.libvirt
.sp
Manage libvirt certs. This state uses the external pillar in the master to call
for the generation and signing of certificates for systems running libvirt:
.sp
.nf
.ft C
libvirt_keys:
  libvirt.keys
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.libvirt.keys(name, basepath=\(aq/etc/pki\(aq)
Manage libvirt keys.
.INDENT 7.0
.TP
.B name
The name variable used to track the execution
.TP
.B basepath
Defaults to \fI/etc/pki\fP, this is the root location used for libvirt
keys on the hypervisor
.UNINDENT
.UNINDENT
.SS salt.states.locale
.sp
Management of languages/locales
==============================+
.sp
The locale can be managed for the system:
.sp
.nf
.ft C
en_US.UTF\-8:
  locale.system
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.locale.system(name)
Set the locale for the system
.INDENT 7.0
.TP
.B name
The name of the locale to use
.UNINDENT
.UNINDENT
.SS salt.states.lvm
.SS Management of Linux logical volumes
.sp
A state module to manage LVMs
.sp
.nf
.ft C
/dev/sda:
  lvm.pv_present

my_vg:
  lvm.vg_present:
    \- devices: /dev/sda

lvroot:
  lvm.lv_present:
    \- vgname: my_vg
    \- size: 10G
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.lvm.lv_absent(name, vgname=None)
Remove a given existing logical volume from a named existing volume group
.INDENT 7.0
.TP
.B name
The logical volume to remove
.TP
.B vgname
The volume group name
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.lvm.lv_present(name, vgname=None, size=None, extents=None, pv=\(aq\(aq)
Create a new logical volume
.INDENT 7.0
.TP
.B name
The name of the logical volume
.TP
.B vgname
The volume group name for this logical volume
.TP
.B size
The initial size of the logical volume
.TP
.B extents
The number of logical extents to allocate
.TP
.B pv
The physical volume to use
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.lvm.pv_present(name, **kwargs)
Set a physical device to be used as an LVM physical volume
.INDENT 7.0
.TP
.B name
The device name to initialize.
.TP
.B kwargs
Any supported options to pvcreate. See
\fBlinux_lvm\fP for more details.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.lvm.vg_absent(name)
Remove an LVM volume group
.INDENT 7.0
.TP
.B name
The volume group to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.lvm.vg_present(name, devices=None, **kwargs)
Create an LVM volume group
.INDENT 7.0
.TP
.B name
The volume group name to create
.TP
.B devices
A list of devices that will be added to the volume group
.TP
.B kwargs
Any supported options to vgcreate. See
\fBlinux_lvm\fP for more details.
.UNINDENT
.UNINDENT
.SS salt.states.makeconf
.SS Management of Gentoo make.conf
.sp
A state module to manage Gentoo\(aqs make.conf file
.sp
.nf
.ft C
makeopts:
    makeconf.present:
        \- value: \(aq\-j3\(aq
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.makeconf.absent(name)
Verify that the variable is not in the make.conf.
.INDENT 7.0
.TP
.B name
The variable name. This will automatically be converted to all Upper
Case since variables in make.conf are Upper Case
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.makeconf.present(name, value=None, contains=None, excludes=None)
Verify that the variable is in the make.conf and has the provided
settings. If value is set, contains and excludes will be ignored.
.INDENT 7.0
.TP
.B name
The variable name. This will automatically be converted to all Upper
Case since variables in make.conf are Upper Case
.TP
.B value
Enforce that the value of the variable is set to the provided value
.TP
.B contains
Enforce that the value of the variable contains the provided value
.TP
.B excludes
Enforce that the value of the variable does not contain the provided
value.
.UNINDENT
.UNINDENT
.SS salt.states.mdadm
.SS Managing software RAID with mdadm
.sp
A state module for creating or destroying software RAID devices.
.sp
.nf
.ft C
/dev/md0:
  raid.present:
    \- opts: level=1 chunk=256 raid\-devices=2 /dev/xvdd /dev/xvde
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.mdadm.absent(name)
Verify that the raid is absent
.INDENT 7.0
.TP
.B name
The name of raid device to be destroyed
.UNINDENT
.sp
.nf
.ft C
/dev/md0:
  raid:
    \- absent
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mdadm.present(name, opts=None)
Verify that the raid is present
.INDENT 7.0
.TP
.B name
The name of raid device to be created
.TP
.B opts
The mdadm options to use to create the raid. See
\fBmdadm\fP for more information.
Opts can be expressed as a single string of options.
.sp
.nf
.ft C
/dev/md0:
  raid.present:
    \- opts: level=1 chunk=256 raid\-devices=2 /dev/xvdd /dev/xvde
.ft P
.fi
.sp
Or as a list of options.
.sp
.nf
.ft C
/dev/md0:
  raid.present:
    \- opts:
      \- level=1
      \- chunk=256
      \- raid\-devices=2
      \- /dev/xvdd
      \- /dev/xvde
.ft P
.fi
.UNINDENT
.UNINDENT
.SS salt.states.module
.SS Execution of Salt modules from within states.
.sp
Individual module calls can be made via states. to call a single module
function use the run function.
.sp
One issue exists, since the name and fun arguments are present in the state
call data structure and is present in many modules, this argument will need
to be replaced in the sls data with the arguments m_name and m_fun.
.INDENT 0.0
.TP
.B salt.states.module.mod_watch(name, **kwargs)
Run a single module function
.INDENT 7.0
.TP
.B \fBname\fP
The module function to execute
.TP
.B \fBreturner\fP
Specify the returner to send the return of the module execution to
.TP
.B \fB**kwargs\fP
Pass any arguments needed to execute the function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.module.run(name, **kwargs)
Run a single module function
.INDENT 7.0
.TP
.B \fBname\fP
The module function to execute
.TP
.B \fBreturner\fP
Specify the returner to send the return of the module execution to
.TP
.B \fB**kwargs\fP
Pass any arguments needed to execute the function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.module.wait(name, **kwargs)
Run a single module function only if the watch statement calls it
.INDENT 7.0
.TP
.B \fBname\fP
The module function to execute
.TP
.B \fB**kwargs\fP
Pass any arguments needed to execute the function
.UNINDENT
.sp
Note that this function actually does nothing \-\- however, if the \fIwatch\fP
is satisfied, then \fImod_watch\fP (defined at the bottom of this file) will be
run.  In this case, \fImod_watch\fP is an alias for \fIrun()\fP.
.UNINDENT
.SS salt.states.mongodb_database
.sp
Management of Mongodb databases
.sp
Only deletion is supported, creation doesn\(aqt make sense
and can be done using mongodb_user.present
.INDENT 0.0
.TP
.B salt.states.mongodb_database.absent(name, user=None, password=None, host=None, port=None)
Ensure that the named database is absent
.INDENT 7.0
.TP
.B name
The name of the database to remove
.TP
.B user
The user to connect as (must be able to create the user)
.TP
.B password
The password of the user
.TP
.B host
The host to connect to
.TP
.B port
The port to connect to
.UNINDENT
.UNINDENT
.SS salt.states.mongodb_user
.SS Management of Mongodb users
.INDENT 0.0
.TP
.B salt.states.mongodb_user.absent(name, user=None, password=None, host=None, port=None, database=\(aqadmin\(aq)
Ensure that the named user is absent
.INDENT 7.0
.TP
.B name
The name of the user to remove
.TP
.B user
The user to connect as (must be able to create the user)
.TP
.B password
The password of the user
.TP
.B host
The host to connect to
.TP
.B port
The port to connect to
.TP
.B database
The database to create the user in (if the db doesn\(aqt exist, it will be created)
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mongodb_user.present(name, passwd, database=\(aqadmin\(aq, user=None, password=None, host=None, port=None)
Ensure that the user is present with the specified properties
.INDENT 7.0
.TP
.B name
The name of the user to manage
.TP
.B passwd
The password of the user
.TP
.B user
The user to connect as (must be able to create the user)
.TP
.B password
The password of the user
.TP
.B host
The host to connect to
.TP
.B port
The port to connect to
.TP
.B database
The database to create the user in (if the db doesn\(aqt exist, it will be created)
.UNINDENT
.UNINDENT
.SS salt.states.mount
.SS Mounting of filesystems.
.sp
Mount any type of mountable filesystem with the mounted function:
.sp
.nf
.ft C
/mnt/sdb:
  mount.mounted:
    \- device: /dev/sdb1
    \- fstype: ext4
    \- mkmnt: True
    \- opts:
      \- defaults
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.mount.mounted(name, device, fstype, mkmnt=False, opts=None, dump=0, pass_num=0, config=\(aq/etc/fstab\(aq, persist=True)
Verify that a device is mounted
.INDENT 7.0
.TP
.B name
The path to the location where the device is to be mounted
.TP
.B device
The device name, typically the device node, such as /dev/sdb1
.TP
.B fstype
The filesystem type, this will be xfs, ext2/3/4 in the case of classic
filesystems, and fuse in the case of fuse mounts
.TP
.B mkmnt
If the mount point is not present then the state will fail, set mkmnt
to True to create the mount point if it is otherwise not present
.TP
.B opts
A list object of options or a comma delimited list
.TP
.B dump
The dump value to be passed into the fstab, default to 0
.TP
.B pass_num
The pass value to be passed into the fstab, default to 0
.TP
.B config
Set an alternative location for the fstab, default to /etc/fstab
.TP
.B remount
Set if the file system can be remounted with the remount option,
default to True
.TP
.B persist
Set if the mount should be saved in the fstab, default to True
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mount.swap(name, persist=True, config=\(aq/etc/fstab\(aq)
Activates a swap device
.sp
.nf
.ft C
/root/swapfile:
  mount.swap
.ft P
.fi
.UNINDENT
.SS salt.states.mysql_database
.SS Management of MySQL databases (schemas).
.sp
NOTE: This module requires the MySQLdb python module and the proper
settings in the minion config file.
See salt.modules.mysql for more information.
.sp
The mysql_database module is used to create and manage MySQL databases.
Databases can be set as either absent or present.
.sp
.nf
.ft C
frank:
  mysql_database.present
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.mysql_database.absent(name)
Ensure that the named database is absent
.INDENT 7.0
.TP
.B name
The name of the database to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mysql_database.present(name)
Ensure that the named database is present with the specified properties
.INDENT 7.0
.TP
.B name
The name of the database to manage
.UNINDENT
.UNINDENT
.SS salt.states.mysql_grants
.SS Management of MySQL grants (user permissions).
.sp
NOTE: This module requires the MySQLdb python module and the proper
settings in the minion config file.
See salt.modules.mysql for more information.
.sp
The mysql_grants module is used to grant and revoke MySQL permissions.
.sp
The \fBname\fP you pass in purely symbolic and does not have anything to do
with the grant itself.
.sp
The \fBdatabase\fP parameter needs to specify a \(aqpriv_level\(aq in the same
specification as defined in the MySQL documentation:
.INDENT 0.0
.IP \(bu 2
*
.IP \(bu 2
*.*
.IP \(bu 2
db_name.*
.IP \(bu 2
db_name.tbl_name
.IP \(bu 2
etc...
.UNINDENT
.sp
.nf
.ft C
frank_exampledb:
   mysql_grants.present:
    \- grant: select,insert,update
    \- database: exampledb.*
    \- user: frank
    \- host: localhost

frank_otherdb:
  mysql_grants.present:
    \- grant: all privileges
    \- database: otherdb.*
    \- user: frank

restricted_singletable:
  mysql_grants.present:
    \- grant: select
    \- database: somedb.sometable
    \- user: joe
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.mysql_grants.absent(name, grant=None, database=None, user=None, host=\(aqlocalhost\(aq, grant_option=False, escape=True)
Ensure that the grant is absent
.INDENT 7.0
.TP
.B name
The name (key) of the grant to add
.TP
.B grant
The grant priv_type (i.e. select,insert,update OR all privileges)
.TP
.B database
The database priv_level (i.e. db.tbl OR db.*)
.TP
.B user
The user to apply the grant to
.TP
.B host
The network/host that the grant should apply to
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mysql_grants.present(name, grant=None, database=None, user=None, host=\(aqlocalhost\(aq, grant_option=False, escape=True)
Ensure that the grant is present with the specified properties
.INDENT 7.0
.TP
.B name
The name (key) of the grant to add
.TP
.B grant
The grant priv_type (i.e. select,insert,update OR all privileges)
.TP
.B database
The database priv_level (ie. db.tbl OR db.*)
.TP
.B user
The user to apply the grant to
.TP
.B host
The network/host that the grant should apply to
.TP
.B grant_option
Adds the WITH GRANT OPTION to the defined grant. default: False
.TP
.B escape
Defines if the database value gets escaped or not. default: True
.UNINDENT
.UNINDENT
.SS salt.states.mysql_user
.SS Management of MySQL users.
.sp
NOTE: This module requires the MySQLdb python module and the proper
settings in the minion config file.
See salt.modules.mysql for more information.
.sp
The mysql_user module is used to manage MySQL users.
.sp
.nf
.ft C
frank:
  mysql_user.present:
    \- host: localhost
    \- password: bobcat
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.mysql_user.absent(name, host=\(aqlocalhost\(aq)
Ensure that the named user is absent
.INDENT 7.0
.TP
.B name
The name of the user to remove
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.mysql_user.present(name, host=\(aqlocalhost\(aq, password=None, password_hash=None)
Ensure that the named user is present with the specified properties
.INDENT 7.0
.TP
.B name
The name of the user to manage
.TP
.B password
The password
.TP
.B password_hash
The password in hashed form. Be sure to quote the password because
YAML doesn\(aqt like the \fB*\fP:
.sp
.nf
.ft C
SELECT PASSWORD(\(aqmypass\(aq) ==> *6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4
.ft P
.fi
.UNINDENT
.UNINDENT
.SS salt.states.network
.SS Configuration of network interfaces.
.sp
The network module is used to create and manage network settings,
interfaces can be set as either managed or ignored. By default
all interfaces are ignored unless specified.
.sp
Please note that only Redhat\-style networking is currently
supported. This module will therefore only work on RH/CentOS/Fedora.
.sp
.nf
.ft C
system:
    network.system:
      \- enabled: True
      \- hostname: server1.example.com
      \- gateway: 192.168.0.1
      \- gatewaydev: eth0
      \- nozeroconf: True
      \- nisdomain: example.com
      \- require_reboot: True

eth0:
  network.managed:
    \- enabled: True
    \- type: eth
    \- proto: none
    \- ipaddr: 10.1.0.1
    \- netmask: 255.255.255.0
    \- dns:
      \- 8.8.8.8
      \- 8.8.4.4

routes:
  network.routes:
    \- name: eth0
    \- routes:
      \- name: secure_network
        ipaddr: 10.2.0.0
        netmask: 255.255.255.0
        gateway: 10.1.0.3
      \- name: HQ_network
        ipaddr: 10.100.0.0
        netmask: 255.255.0.0
        gateway: 10.1.0.10

eth2:
  network.managed:
    \- type: slave
    \- master: bond0

eth3:
  network.managed:
    \- type: slave
    \- master: bond0

eth4:
  network.managed:
    \- enabled: True
    \- type: eth
    \- proto: dhcp
    \- bridge: br0

bond0:
  network.managed:
    \- type: bond
    \- ipaddr: 10.1.0.1
    \- netmask: 255.255.255.0
    \- dns:
      \- 8.8.8.8
      \- 8.8.4.4
    \- ipv6:
    \- enabled: False
    \- use_in:
      \- network: eth2
      \- network: eth3
    \- require:
      \- network: eth2
      \- network: eth3
    \- mode: 802.3ad
    \- miimon: 100
    \- arp_interval: 250
    \- downdelay: 200
    \- lacp_rate: fast
    \- max_bonds: 1
    \- updelay: 0
    \- use_carrier: on
    \- xmit_hash_policy: layer2
    \- mtu: 9000
    \- autoneg: on
    \- speed: 1000
    \- duplex: full
    \- rx: on
    \- tx: off
    \- sg: on
    \- tso: off
    \- ufo: off
    \- gso: off
    \- gro: off
    \- lro: off

bond0.2:
  network.managed:
    \- type: vlan
    \- ipaddr: 10.1.0.2
    \- use:
      \- network: bond0
    \- require:
      \- network: bond0

bond0.3:
  network.managed:
    \- type: vlan
    \- ipaddr: 10.1.0.3
    \- use:
      \- network: bond0
    \- require:
      \- network: bond0

bond0.10:
  network.managed:
    \- type: vlan
    \- ipaddr: 10.1.0.4
    \- use:
      \- network: bond0
    \- require:
      \- network: bond0

bond0.12:
  network.managed:
    \- type: vlan
    \- ipaddr: 10.1.0.5
    \- use:
      \- network: bond0
    \- require:
      \- network: bond0
br0:
  network.managed:
    \- enabled: True
    \- type: bridge
    \- proto: dhcp
    \- bridge: br0
    \- delay: 0
    \- bypassfirewall: True
    \- use:
      \- network: eth4
    \- require:
      \- network: eth4
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.network.managed(name, type, enabled=True, **kwargs)
Ensure that the named interface is configured properly.
.INDENT 7.0
.TP
.B name
The name of the interface to manage
.TP
.B type
Type of interface and configuration.
.TP
.B enabled
Designates the state of this interface.
.TP
.B kwargs
The IP parameters for this interface.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.network.routes(name, **kwargs)
Manage network interface static routes.
.INDENT 7.0
.TP
.B name
Interface name to apply the route to.
.TP
.B kwargs
Named routes
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.network.system(name, **kwargs)
Ensure that global network settings are configured properly.
.INDENT 7.0
.TP
.B name
Custom name to represent this configuration change.
.TP
.B kwargs
The global parameters for the system.
.UNINDENT
.UNINDENT
.SS salt.states.npm
.sp
A state module to manage installed NPM packages.
.INDENT 0.0
.TP
.B salt.states.npm.bootstrap(name, runas=None)
Bootstraps a node.js application.
.sp
will execute npm install \-\-json on the specified directory
.INDENT 7.0
.TP
.B runas
The user to run NPM with
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.npm.installed(name, dir=None, runas=None, force_reinstall=False, **kwargs)
Verify that the given package is installed and is at the correct version
(if specified).
.INDENT 7.0
.TP
.B dir
The target directory in which to install the package, or None for
global installation
.TP
.B runas
The user to run NPM with
.TP
.B force_reinstall
Install the package even if it is already installed
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.npm.removed(name, dir=None, runas=None, **kwargs)
Verify that the given package is not installed.
.INDENT 7.0
.TP
.B dir
The target directory in which to install the package, or None for
global installation
.TP
.B runas
The user to run NPM with
.UNINDENT
.UNINDENT
.SS salt.states.pecl
.SS Installation of PHP pecl extensions.
.sp
A state module to manage php pecl extensions.
.sp
.nf
.ft C
mongo:
  pecl.installed
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.pecl.installed(name, version=None)
Make sure that a pecl extension is installed.
.INDENT 7.0
.TP
.B name
The pecl extension name to install
.TP
.B version
The pecl extension version to install. This option may be
ignored to install the latest stable version.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pecl.removed(name)
Make sure that a pecl extension is not installed.
.INDENT 7.0
.TP
.B name
The pecl extension name to uninstall
.UNINDENT
.UNINDENT
.SS salt.states.pip
.SS Installation of Python packages using pip.
.sp
A state module to manage system installed python packages
.sp
.nf
.ft C
virtualenvwrapper:
  pip.installed
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.pip.installed(name, pip_bin=None, requirements=None, env=None, bin_env=None, log=None, proxy=None, timeout=None, repo=None, editable=None, find_links=None, index_url=None, extra_index_url=None, no_index=False, mirrors=None, build=None, target=None, download=None, download_cache=None, source=None, upgrade=False, force_reinstall=False, ignore_installed=False, exists_action=None, no_deps=False, no_install=False, no_download=False, install_options=None, user=None, no_chown=False, cwd=None, __env__=\(aqbase\(aq)
Make sure the package is installed
.INDENT 7.0
.TP
.B name
The name of the python package to install
.TP
.B pip_bin
None
Deprecated, use bin_env
.TP
.B env
None
Deprecated, use bin_env
.TP
.B bin_env
None
the pip executable or virtualenv to use
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pip.removed(name, requirements=None, bin_env=None, log=None, proxy=None, timeout=None, user=None, cwd=None, __env__=\(aqbase\(aq)
Make sure that a package is not installed.
.INDENT 7.0
.TP
.B name
The name of the package to uninstall
.TP
.B bin_env
None
the pip executable or virtualenenv to use
.UNINDENT
.UNINDENT
.SS salt.states.pkgng
.SS Manage package remote repo using FreeBSD pkgng.
.sp
Salt can manage the URL pkgng pulls packages from.
ATM the state and module are small so use cases are
typically rather simple:
.sp
.nf
.ft C
pkgng_clients:
  pkgng:
    \- update_packaging_site
    \- name: "http://192.168.0.2"
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.pkgng.update_packaging_site(name)
.UNINDENT
.SS salt.states.pkg
.SS Installation of packages using OS package managers such as yum or apt\-get.
.sp
Salt can manage software packages via the pkg state module, packages can be
set up to be installed, latest, removed and purged. Package management
declarations are typically rather simple:
.sp
.nf
.ft C
vim:
  pkg.installed
.ft P
.fi
.sp
A more involved example involves pulling from a custom repository.
Note that the pkgrepo has a require_in clause.
This is necessary and can not be replaced by a require clause in the pkg.
.sp
.nf
.ft C
base:
  pkgrepo.managed:
    \- humanname: Logstash PPA
    \- name: deb http://ppa.launchpad.net/wolfnet/logstash/ubuntu precise main
    \- dist: precise
    \- file: /etc/apt/sources.list.d/logstash.list
    \- keyid: 28B04E4A
    \- keyserver: keyserver.ubuntu.com
    \- require_in:
      \- pkg: logstash

logstash:
  pkg.installed
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.pkg.installed(name, version=None, refresh=False, fromrepo=None, skip_verify=False, pkgs=None, sources=None, **kwargs)
Verify that the package is installed, and that it is the correct version
(if specified).
.INDENT 7.0
.TP
.B name
The name of the package to be installed. This parameter is ignored if
either "pkgs" or "sources" is used. Additionally, please note that this
option can only be used to install packages from a software repository.
To install a package file manually, use the "sources" option detailed
below.
.TP
.B fromrepo
Specify a repository from which to install
.TP
.B skip_verify
Skip the GPG verification check for the package to be installed
.TP
.B version
Install a specific version of a package. This option is ignored if
either "pkgs" or "sources" is used. Currently, this option is supported
for the following pkg providers: \fBapt\fP,
\fBebuild\fP,
\fBpacman\fP,
\fByumpkg\fP,
\fByumpkg5\fP, and
\fBzypper\fP.
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
httpd:
  pkg.installed:
    \- fromrepo: mycustomrepo
    \- skip_verify: True
    \- version: 2.0.6~ubuntu3
.ft P
.fi
.sp
Multiple Package Installation Options: (not supported in Windows or pkgng)
.INDENT 7.0
.TP
.B pkgs
A list of packages to install from a software repository.
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
mypkgs:
  pkg.installed:
    \- pkgs:
      \- foo
      \- bar
      \- baz
.ft P
.fi
.sp
\fBNOTE:\fP For \fBapt\fP,
\fBebuild\fP,
\fBpacman\fP, \fByumpkg\fP,
\fByumpkg5\fP,
and \fBzypper\fP, version numbers can be specified
in the \fBpkgs\fP argument. Example:
.sp
.nf
.ft C
mypkgs:
  pkg.installed:
    \- pkgs:
      \- foo
      \- bar: 1.2.3\-4
      \- baz
.ft P
.fi
.sp
Additionally, \fBebuild\fP,
\fBpacman\fP and
\fBzypper\fP support the \fB<\fP, \fB<=\fP, \fB>=\fP, and
\fB>\fP operators for more control over what versions will be installed.
Example:
.sp
.nf
.ft C
mypkgs:
  pkg.installed:
    \- pkgs:
      \- foo
      \- bar: \(aq>=1.2.3\-4\(aq
      \- baz
.ft P
.fi
.sp
\fBNOTE:\fP When using comparison operators, the expression must be enclosed
in quotes to avoid a YAML render error.
.INDENT 7.0
.TP
.B sources
A list of packages to install, along with the source URI or local path
from which to install each package. In the example below, \fBfoo\fP,
\fBbar\fP, \fBbaz\fP, etc. refer to the name of the package, as it would
appear in the output of the \fBpkg.version\fP or \fBpkg.list_pkgs\fP salt
CLI commands.
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
mypkgs:
  pkg.installed:
    \- sources:
      \- foo: salt://rpms/foo.rpm
      \- bar: http://somesite.org/bar.rpm
      \- baz: ftp://someothersite.org/baz.rpm
      \- qux: /minion/path/to/qux.rpm
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pkg.latest(name, refresh=False, fromrepo=None, skip_verify=False, pkgs=None, **kwargs)
Verify that the named package is installed and the latest available
package. If the package can be updated this state function will update
the package. Generally it is better for the
\fBinstalled\fP function to be
used, as \fBlatest\fP will update the package
whenever a new package is available.
.INDENT 7.0
.TP
.B name
The name of the package to maintain at the latest available version.
This parameter is ignored if "pkgs" is used.
.TP
.B fromrepo
Specify a repository from which to install
.TP
.B skip_verify
Skip the GPG verification check for the package to be installed
.UNINDENT
.sp
Multiple Package Installation Options:
.sp
(Not yet supported for: Windows, FreeBSD, OpenBSD, MacOS, and Solaris
pkgutil)
.INDENT 7.0
.TP
.B pkgs
A list of packages to maintain at the latest available version.
.UNINDENT
.sp
Usage:
.sp
.nf
.ft C
mypkgs:
  pkg.latest:
    \- pkgs:
      \- foo
      \- bar
      \- baz
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pkg.purged(name, pkgs=None, **kwargs)
Verify that a package is not installed, calling \fBpkg.purge\fP if necessary
to purge the package.
.INDENT 7.0
.TP
.B name
The name of the package to be purged.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to purge. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pkg.removed(name, pkgs=None, **kwargs)
Verify that a package is not installed, calling \fBpkg.remove\fP if necessary
to remove the package.
.INDENT 7.0
.TP
.B name
The name of the package to be removed.
.UNINDENT
.sp
Multiple Package Options:
.INDENT 7.0
.TP
.B pkgs
A list of packages to remove. Must be passed as a python list. The
\fBname\fP parameter will be ignored if this option is passed.
.UNINDENT
.sp
New in version 0.16.0.
.UNINDENT
.SS salt.states.pkgrepo
.SS Management of package repos
.sp
Package repositories can be managed with the pkgrepo state:
.sp
.nf
.ft C
base:
  pkgrepo.managed:
    \- humanname: CentOS\-$releasever \- Base
    \- mirrorlist: http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os
    \- comments:
        \- \(aq#http://mirror.centos.org/centos/$releasever/os/$basearch/\(aq
    \- gpgcheck: 1
    \- gpgkey: file:///etc/pki/rpm\-gpg/RPM\-GPG\-KEY\-CentOS\-6
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.pkgrepo.absent(name, **kwargs)
This function deletes the specified repo on the system, if it exists. It
is essentially a wrapper around pkg.del_repo.
.INDENT 7.0
.TP
.B name
The name of the package repo, as it would be referred to when running
the regular package manager commands.
.TP
.B ppa
On Ubuntu, you can take advantage of Personal Package Archives on
Launchpad simply by specifying the user and archive name.
.INDENT 7.0
.INDENT 3.5
EXAMPLE: ppa: wolfnet/logstash
.UNINDENT
.UNINDENT
.TP
.B ppa_auth
For Ubuntu PPAs there can be private PPAs that require authentication
to access. For these PPAs the username/password can be specified.  This
is required for matching if the name format uses the "ppa:" specifier
and is private (requires username/password to access, which is encoded
in the URI)
.INDENT 7.0
.INDENT 3.5
EXAMPLE: ppa_auth: username:password
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.pkgrepo.managed(name, **kwargs)
This function manages the configuration on a system that points to the
repositories for the system\(aqs package manager.
.INDENT 7.0
.TP
.B name
The name of the package repo, as it would be referred to when running
the regular package manager commands.
.UNINDENT
.sp
For yum\-based systems, take note of the following configuration values:
.INDENT 7.0
.TP
.B humanname
On yum\-based systems, this is stored as the "name" value in the .repo
file in /etc/yum.repos.d/. On yum\-based systems, this is required.
.TP
.B baseurl
On yum\-based systems, baseurl refers to a direct URL to be used for
this yum repo.
One of baseurl or mirrorlist is required.
.TP
.B mirrorlist
a URL which contains a collection of baseurls to choose from. On
yum\-based systems.
One of baseurl or mirrorlist is required.
.TP
.B comments
Sometimes you want to supply additional information, but not as
enabled configuration. Anything supplied for this list will be saved
in the repo configuration with a comment marker (#) in front.
.UNINDENT
.sp
Additional configuration values, such as gpgkey or gpgcheck, are used
verbatim to update the options for the yum repo in question.
.sp
For apt\-based systems, take note of the following configuration values:
.INDENT 7.0
.TP
.B ppa
On Ubuntu, you can take advantage of Personal Package Archives on
Launchpad simply by specifying the user and archive name. The keyid
will be queried from launchpad and everything else is set
automatically. You can override any of the below settings by simply
setting them as you would normally.
.INDENT 7.0
.INDENT 3.5
EXAMPLE: ppa: wolfnet/logstash
.UNINDENT
.UNINDENT
.TP
.B ppa_auth
For Ubuntu PPAs there can be private PPAs that require authentication
to access. For these PPAs the username/password can be passed as an
HTTP Basic style username/password combination.
.INDENT 7.0
.INDENT 3.5
EXAMPLE: ppa_auth: username:password
.UNINDENT
.UNINDENT
.TP
.B name
On apt\-based systems this must be the complete entry as it would be
seen in the sources.list file.  This can have a limited subset of
components (i.e. \(aqmain\(aq) which can be added/modified with the
"comps" option.
.INDENT 7.0
.INDENT 3.5
EXAMPLE: name: deb \fI\%http://us.archive.ubuntu.com/ubuntu/\fP precise main
.UNINDENT
.UNINDENT
.TP
.B disabled
On apt\-based systems, disabled toggles whether or not the repo is
used for resolving dependencies and/or installing packages
.TP
.B comps
On apt\-based systems, comps dictate the types of packages to be
installed from the repository (e.g. main, nonfree, ...).  For
purposes of this, comps should be a comma\-separated list.
.TP
.B file
The filename for the .list that the repository is configured in.
It is important to include the full\-path AND make sure it is in
a directory that APT will look in when handling packages
.TP
.B dist
This dictates the release of the distro the packages should be built
for.  (e.g. unstable)
.TP
.B keyid
The KeyID of the GPG key to install.  This option also requires
the \(aqkeyserver\(aq option to be set.
.TP
.B keyserver
This is the name of the keyserver to retrieve gpg keys from.  The
keyid option must also be set for this option to work.
.TP
.B key_url
A web URL to retrieve the GPG key from.
.TP
.B consolidate
If set to true, this will consolidate all sources definitions to
the sources.list file, cleanup the now unused files, consolidate
components (e.g. main) for the same URI, type, and architecture
to a single line, and finally remove comments from the sources.list
file.  The consolidate will run every time the state is processed. The
option only needs to be set on one repo managed by salt to take effect.
.TP
.B require_in
Set this to a list of pkg.installed or pkg.latest to trigger the
running of apt\-get update prior to attempting to install these
packages. Setting a require in the pkg will not work for this.
.UNINDENT
.UNINDENT
.SS salt.states.postgres_database
.SS Management of PostgreSQL databases.
.sp
The postgres_database module is used to create and manage Postgres databases.
Databases can be set as either absent or present
.sp
.nf
.ft C
frank:
  postgres_database.present
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.postgres_database.absent(name, runas=None)
Ensure that the named database is absent
.INDENT 7.0
.TP
.B name
The name of the database to remove
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.postgres_database.present(name, tablespace=None, encoding=None, lc_collate=None, lc_ctype=None, owner=None, template=None, runas=None)
Ensure that the named database is present with the specified properties.
For more information about all of these options see man createdb(1)
.INDENT 7.0
.TP
.B name
The name of the database to manage
.TP
.B tablespace
Default tablespace for the database
.TP
.B encoding
The character encoding scheme to be used in this database
.TP
.B lc_collate
The LC_COLLATE setting to be used in this database
.TP
.B lc_ctype
The LC_CTYPE setting to be used in this database
.TP
.B owner
The username of the database owner
.TP
.B template
The template database from which to build this database
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.SS salt.states.postgres_group
.SS Management of PostgreSQL groups (roles).
.sp
The postgres_group module is used to create and manage Postgres groups.
.sp
.nf
.ft C
frank:
  postgres_group.present
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.postgres_group.absent(name, runas=None)
Ensure that the named group is absent
.INDENT 7.0
.TP
.B name
The groupname of the group to remove
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.postgres_group.present(name, createdb=False, createuser=False, encrypted=False, superuser=False, replication=False, password=None, groups=None, runas=None)
Ensure that the named group is present with the specified privileges
.INDENT 7.0
.TP
.B name
The name of the group to manage
.TP
.B createdb
Is the group allowed to create databases?
.TP
.B createuser
Is the group allowed to create other users?
.TP
.B encrypted
Should the password be encrypted in the system catalog?
.TP
.B superuser
Should the new group be a "superuser"
.TP
.B replication
Should the new group be allowed to initiate streaming replication
.TP
.B password
The group\(aqs password
.TP
.B groups
A string of comma separated groups the group should be in
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.SS salt.states.postgres_user
.SS Management of PostgreSQL users (roles).
.sp
The postgres_users module is used to create and manage Postgres users.
.sp
.nf
.ft C
frank:
  postgres_user.present
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.postgres_user.absent(name, runas=None)
Ensure that the named user is absent
.INDENT 7.0
.TP
.B name
The username of the user to remove
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.postgres_user.present(name, createdb=False, createuser=False, encrypted=False, superuser=False, replication=False, password=None, groups=None, runas=None)
Ensure that the named user is present with the specified privileges
.INDENT 7.0
.TP
.B name
The name of the user to manage
.TP
.B createdb
Is the user allowed to create databases?
.TP
.B createuser
Is the user allowed to create other users?
.TP
.B encrypted
Should the password be encrypted in the system catalog?
.TP
.B superuser
Should the new user be a "superuser"
.TP
.B replication
Should the new user be allowed to initiate streaming replication
.TP
.B password
The user\(aqs password
.TP
.B groups
A string of comma separated groups the user should be in
.TP
.B runas
System user all operations should be performed on behalf of
.UNINDENT
.UNINDENT
.SS salt.states.quota
.SS Management of POSIX Quotas
.sp
The quota can be managed for the system:
.sp
.nf
.ft C
/:
  quota.mode:
    mode: off
    quotatype: user
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.quota.mode(name, mode, quotatype)
Set the quota for the system
.INDENT 7.0
.TP
.B name
The filesystem to set the quota mode on
.TP
.B mode
Whether the quota system is \(aqon\(aq or \(aqoff\(aq
.TP
.B quotatype
Need to be \(aquser\(aq or \(aqgroup\(aq
.UNINDENT
.UNINDENT
.SS salt.states.rabbitmq_user
.sp
Manage RabbitMQ Users.
.sp
.nf
.ft C
rabbit_user:
    rabbitmq_user.present:
        \- password: password
        \- force: True
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.rabbitmq_user.absent(name, runas=None)
Ensure the named user is absent
.INDENT 7.0
.TP
.B name
The name of the user to remove
.TP
.B runas
User to run the command
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.rabbitmq_user.present(name, password=None, force=False, runas=None)
Ensure the RabbitMQ user exists.
.INDENT 7.0
.TP
.B name
User name
.TP
.B password
User\(aqs password, if one needs to be set
.TP
.B force
If user exists, forcibly change the password
.TP
.B runas
Name of the user to run the command
.UNINDENT
.UNINDENT
.SS salt.states.rabbitmq_vhost
.sp
Manage RabbitMQ Virtual Hosts.
.sp
.nf
.ft C
virtual_host:
    rabbitmq_vhost.present:
        \- user: rabbit_user
        \- conf: .*
        \- write: .*
        \- read: .*
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.rabbitmq_vhost.absent(name, runas=None)
Ensure the RabbitMQ Virtual Host is absent
.INDENT 7.0
.TP
.B name
Name of the Virtual Host to remove
.TP
.B runas
User to run the command
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.rabbitmq_vhost.present(name, user=None, conf=None, write=None, read=None, runas=None)
Ensure the RabbitMQ VHost exists.
.INDENT 7.0
.TP
.B name
VHost name
.TP
.B user
Initial user permission to set on the VHost, if present
.TP
.B conf
Initial conf string to apply to the VHost and user. Defaults to .*
.TP
.B write
Initial write permissions to apply to the VHost and user.
Defaults to .*
.TP
.B read
Initial read permissions to apply to the VHost and user.
Defaults to .*
.TP
.B runas
Name of the user to run the command
.UNINDENT
.UNINDENT
.SS salt.states.rbenv
.SS Managing Ruby installations with rbenv.
.sp
This module is used to install and manage ruby installations with rbenv.
Different versions of ruby can be installed, and uninstalled. Rbenv will
be installed automatically the first time it is needed and can be updated
later. This module will \fInot\fP automatically install packages which rbenv
will need to compile the versions of ruby.
.sp
If rbenv is run as the root user then it will be installed to /usr/local/rbenv,
otherwise it will be installed to the users ~/.rbenv directory. To make
rbenv available in the shell you may need to add the rbenv/shims and rbenv/bin
directories to the users PATH. If you are installing as root and want other
users to be able to access rbenv then you will need to add RBENV_ROOT to
their environment.
.sp
This is how a state configuration could look like:
.sp
.nf
.ft C
rbenv\-deps:
  pkg.installed:
    \- names:
      \- bash
      \- git
      \- openssl
      \- gmake
      \- curl

ruby\-1.9.3\-p392:
  rbenv.absent:
    \- require:
      \- pkg: rbenv\-deps

ruby\-1.9.3\-p429:
  rvm.installed:
    \- default: True
    \- require:
      \- pkg: rbenv\-deps
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.rbenv.absent(name, runas=None)
Verify that the specified ruby is not installed with rbenv. Rbenv
is installed if necessary.
.INDENT 7.0
.TP
.B name
The version of ruby to uninstall
.TP
.B runas
None
The user to run rbenv as.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.rbenv.installed(name, default=False, runas=None)
Verify that the specified ruby is installed with rbenv. Rbenv is
installed if necessary.
.INDENT 7.0
.TP
.B name
The version of ruby to install
.TP
.B default
False
Whether to make this ruby the default.
.TP
.B runas
None
The user to run rbenv as.
.UNINDENT
.UNINDENT
.SS salt.states.rvm
.SS Managing Ruby installations and gemsets with Ruby Version Manager (RVM).
.sp
This module is used to install and manage ruby installations and
gemsets with RVM, the Ruby Version Manager. Different versions of ruby
can be installed and gemsets created. RVM itself will be installed
automatically if it\(aqs not present. This module will not automatically
install packages that RVM depends on or ones that are needed to build
ruby. If you want to run RVM as an unprivileged user (recommended) you
will have to create this user yourself. This is how a state
configuration could look like:
.sp
.nf
.ft C
rvm:
  group:
    \- present
  user.present:
    \- gid: rvm
    \- home: /home/rvm
    \- require:
      \- group: rvm

rvm\-deps:
  pkg.installed:
    \- names:
      \- bash
      \- coreutils
      \- gzip
      \- bzip2
      \- gawk
      \- sed
      \- curl
      \- git\-core
      \- subversion

mri\-deps:
  pkg.installed:
    \- names:
      \- build\-essential
      \- openssl
      \- libreadline6
      \- libreadline6\-dev
      \- curl
      \- git\-core
      \- zlib1g
      \- zlib1g\-dev
      \- libssl\-dev
      \- libyaml\-dev
      \- libsqlite3\-0
      \- libsqlite3\-dev
      \- sqlite3
      \- libxml2\-dev
      \- libxslt1\-dev
      \- autoconf
      \- libc6\-dev
      \- libncurses5\-dev
      \- automake
      \- libtool
      \- bison
      \- subversion
      \- ruby

jruby\-deps:
  pkg.installed:
    \- names:
      \- curl
      \- g++
      \- openjdk\-6\-jre\-headless

ruby\-1.9.2:
  rvm.installed:
    \- default: True
    \- runas: rvm
    \- require:
      \- pkg: rvm\-deps
      \- pkg: mri\-deps
      \- user: rvm

jruby:
  rvm.installed:
    \- runas: rvm
    \- require:
      \- pkg: rvm\-deps
      \- pkg: jruby\-deps
      \- user: rvm

jgemset:
  rvm.gemset_present:
    \- ruby: jruby
    \- runas: rvm
    \- require:
      \- rvm: jruby

mygemset:
  rvm.gemset_present:
    \- ruby: ruby\-1.9.2
    \- runas: rvm
    \- require:
      \- rvm: ruby\-1.9.2
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.rvm.gemset_present(name, ruby=\(aqdefault\(aq, runas=None)
Verify that the gemset is present.
.INDENT 7.0
.TP
.B name
The name of the gemset.
.TP
.B ruby
default
The ruby version this gemset belongs to.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.rvm.installed(name, default=False, runas=None)
Verify that the specified ruby is installed with RVM. RVM is
installed when necessary.
.INDENT 7.0
.TP
.B name
The version of ruby to install
.TP
.B default
False
Whether to make this ruby the default.
.TP
.B runas
None
The user to run rvm as.
.UNINDENT
.UNINDENT
.SS salt.states.selinux
.SS Management of SELinux rules.
.sp
If SELinux is available for the running system, the mode can be managed and
booleans can be set.
.sp
.nf
.ft C
enforcing:
    selinux.mode

samba_create_home_dirs:
    selinux.boolean:
      \- value: True
      \- persist: True
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.selinux.boolean(name, value, persist=False)
Set up an SELinux boolean
.INDENT 7.0
.TP
.B name
The name of the boolean to set
.TP
.B value
The value to set on the boolean
.TP
.B persist
Defaults to False, set persist to true to make the boolean apply on a
reboot
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.selinux.mode(name)
Verifies the mode SELinux is running in, can be set to enforcing or
permissive
.INDENT 7.0
.TP
.B name
The mode to run SELinux in, permissive or enforcing
.UNINDENT
.UNINDENT
.SS salt.states.service
.SS Starting or restarting of services and daemons.
.sp
Services are defined as system daemons typically started with system init or
rc scripts, services can be defined as running or dead.
.sp
.nf
.ft C
httpd:
  service:
    \- running
.ft P
.fi
.sp
The service can also be set to be started at runtime via the enable option:
.sp
.nf
.ft C
openvpn:
  service:
    \- running
    \- enable: True
.ft P
.fi
.sp
By default if a service is triggered to refresh due to a watch statement the
service is by default restarted. If the desired behaviour is to reload the
service, then set the reload value to True:
.sp
.nf
.ft C
redis:
  service:
    \- running
    \- enable: True
    \- reload: True
    \- watch:
      \- pkg: redis
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.service.dead(name, enable=None, sig=None, **kwargs)
Ensure that the named service is dead by stopping the service if it is running
.INDENT 7.0
.TP
.B name
The name of the init or rc script used to manage the service
.TP
.B enable
Set the service to be enabled at boot time, True sets the service to
be enabled, False sets the named service to be disabled. The default
is None, which does not enable or disable anything.
.TP
.B sig
The string to search for when looking for the service process with ps
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.service.disabled(name, **kwargs)
Verify that the service is disabled on boot, only use this state if you
don\(aqt want to manage the running process, remember that if you want to
disable a service to use the enable: False option for the running or dead
function.
.INDENT 7.0
.TP
.B name
The name of the init or rc script used to manage the service
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.service.enabled(name, **kwargs)
Verify that the service is enabled on boot, only use this state if you
don\(aqt want to manage the running process, remember that if you want to
enable a running service to use the enable: True option for the running
or dead function.
.INDENT 7.0
.TP
.B name
The name of the init or rc script used to manage the service
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.service.mod_watch(name, sig=None, reload=False, full_restart=False)
The service watcher, called to invoke the watch command.
.INDENT 7.0
.TP
.B name
The name of the init or rc script used to manage the service
.TP
.B sig
The string to search for when looking for the service process with ps
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.service.running(name, enable=None, sig=None, **kwargs)
Verify that the service is running
.INDENT 7.0
.TP
.B name
The name of the init or rc script used to manage the service
.TP
.B enable
Set the service to be enabled at boot time, True sets the service to
be enabled, False sets the named service to be disabled. The default
is None, which does not enable or disable anything.
.TP
.B sig
The string to search for when looking for the service process with ps
.UNINDENT
.UNINDENT
.SS salt.states.ssh_auth
.SS Control of entries in SSH authorized_key files.
.sp
The information stored in a user\(aqs ssh authorized key file can be easily
controlled via the ssh_auth state. Defaults can be set by the enc, options,
and comment keys. These defaults can be overridden by including them in the
name.
.sp
.nf
.ft C
AAAAB3NzaC1kc3MAAACBAL0sQ9fJ5bYTEyY==:
  ssh_auth:
    \- present
    \- user: root
    \- enc: ssh\-dss

thatch:
  ssh_auth:
    \- present
    \- user: root
    \- source: salt://ssh_keys/thatch.id_rsa.pub

sshkeys:
  ssh_auth:
    \- present
    \- user: root
    \- enc: ssh\-rsa
    \- options:
      \- option1="value1"
      \- option2="value2 flag2"
    \- comment: myuser
    \- names:
      \- AAAAB3NzaC1kc3MAAACBAL0sQ9fJ5bYTEyY==
      \- ssh\-dss AAAAB3NzaCL0sQ9fJ5bYTEyY== user@domain
      \- option3="value3" ssh\-dss AAAAB3NzaC1kcQ9J5bYTEyY== other@testdomain
      \- AAAAB3NzaC1kcQ9fJFF435bYTEyY== newcomment
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.ssh_auth.absent(name, user, config=\(aq.ssh/authorized_keys\(aq)
Verifies that the specified ssh key is absent
.INDENT 7.0
.TP
.B name
The ssh key to manage
.TP
.B user
The user who owns the ssh authorized keys file to modify
.TP
.B config
The location of the authorized keys file relative to the user\(aqs home
directory, defaults to ".ssh/authorized_keys"
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.ssh_auth.present(name, user, enc=\(aqssh\-rsa\(aq, comment=\(aq\(aq, source=\(aq\(aq, options=None, config=\(aq.ssh/authorized_keys\(aq, **kwargs)
Verifies that the specified ssh key is present for the specified user
.INDENT 7.0
.TP
.B name
The ssh key to manage
.TP
.B user
The user who owns the ssh authorized keys file to modify
.TP
.B enc
Defines what type of key is being used, can be ecdsa ssh\-rsa, ssh\-dss
.TP
.B comment
The comment to be placed with the ssh public key
.TP
.B source
The source file for the key(s). Can contain any number of public keys,
in standard "authorized_keys" format. If this is set, comment, enc,
and options will be ignored.
.TP
.B options
The options passed to the key, pass a list object
.TP
.B config
The location of the authorized keys file relative to the user\(aqs home
directory, defaults to ".ssh/authorized_keys"
.UNINDENT
.UNINDENT
.SS salt.states.ssh_known_hosts
.SS Control of SSH known_hosts entries.
.sp
Manage the information stored in the known_hosts files
.sp
.nf
.ft C
github.com:
  ssh_known_hosts:
    \- present
    \- user: root
    \- fingerprint: 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48

example.com:
  ssh_known_hosts:
    \- absent
    \- user: root
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.ssh_known_hosts.absent(name, user, config=\(aq.ssh/known_hosts\(aq)
Verifies that the specified host is not known by the given user
.INDENT 7.0
.TP
.B name
The host name
.TP
.B user
The user who owns the ssh authorized keys file to modify
.TP
.B config
The location of the authorized keys file relative to the user\(aqs home
directory, defaults to ".ssh/known_hosts"
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.ssh_known_hosts.present(name, user, fingerprint=None, port=None, enc=None, config=\(aq.ssh/known_hosts\(aq, hash_hostname=True)
Verifies that the specified host is known by the specified user
.sp
On many systems, specifically those running with openssh 4 or older, the
\fBenc\fP option must be set, only openssh 5 and above can detect the key
type.
.INDENT 7.0
.TP
.B name
The name of the remote host (i.e. "github.com")
.TP
.B user
The user who owns the ssh authorized keys file to modify
.TP
.B enc
Defines what type of key is being used, can be ecdsa ssh\-rsa or ssh\-dss
.TP
.B fingerprint
The fingerprint of the key which must be presented in the known_hosts
file
.TP
.B port
optional parameter, denoting the port of the remote host, which will be
used in case, if the public key will be requested from it. By default
the port 22 is used.
.TP
.B config
The location of the authorized keys file relative to the user\(aqs home
directory, defaults to ".ssh/known_hosts"
.TP
.B hash_hostname
True
Hash all hostnames and addresses in the output.
.UNINDENT
.UNINDENT
.SS salt.states.stateconf
.SS Stateconf System
.sp
The stateconf system is intended for use only with the stateconf renderer. This
State module presents the set function. This function does not execute any
functionality, but is used to interact with the stateconf renderer.
.INDENT 0.0
.TP
.B salt.states.stateconf.context(name, **kwargs)
No\-op state to support state config via the stateconf renderer.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.stateconf.set(name, **kwargs)
No\-op state to support state config via the stateconf renderer.
.UNINDENT
.SS salt.states.supervisord
.SS Interaction with the Supervisor daemon.
.sp
.nf
.ft C
wsgi_server:
  supervisord:
    \- running
    \- require:
      \- pkg: supervisor
    \- watch:
      \- file.managed: /etc/nginx/sites\-enabled/wsgi_server.conf
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.supervisord.dead(name, runas=None, conf_file=None, bin_env=None)
Ensure the named service is dead (not running).
.INDENT 7.0
.TP
.B name
Service name as defined in the supervisor configuration file
.TP
.B runas
Name of the user to run the supervisorctl command
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.supervisord.mod_watch(name, restart=None, runas=None, conf_file=None, bin_env=None)
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.supervisord.running(name, restart=False, update=False, runas=None, conf_file=None, bin_env=None)
Ensure the named service is running.
.INDENT 7.0
.TP
.B name
Service name as defined in the supervisor configuration file
.TP
.B restart
Whether to force a restart
.TP
.B update
Whether to update the supervisor configuration.
.TP
.B runas
Name of the user to run the supervisorctl command
.TP
.B conf_file
path to supervisorctl config file
.TP
.B bin_env
path to supervisorctl bin or path to virtualenv with supervisor installed
.UNINDENT
.UNINDENT
.SS salt.states.svn
.SS Manage SVN repositories
.sp
Manage repositiry checkouts via the svn vcs system:
.sp
.nf
.ft C
http://unladen\-swallow.googlecode.com/svn/trunk/:
  svn.latest:
    \- target: /tmp/swallow
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.svn.dirty(name, target, user=None, ignore_unversioned=False)
Determine if the working directory has been changed.
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.svn.latest(name, target=None, rev=None, user=None, username=None, force=False, externals=True)
Checkout or update the working directory to the latest revision from the
remote repository.
.INDENT 7.0
.TP
.B name
Address of the name repository as passed to "svn checkout"
.TP
.B target
Name of the target directory where the checkout will put the working
directory
.TP
.B rev
None
The name revision number to checkout. Enable "force" if the directory
already exists.
.TP
.B user
None
Name of the user performing repository management operations
.TP
.B username
None
The user to access the name repository with. The svn default is the
current user
.TP
.B force
False
Continue if conflicts are encountered
.TP
.B externals
True
Change to False to not checkout or update externals
.UNINDENT
.UNINDENT
.SS salt.states.sysctl
.SS Configuration of the Linux kernel using sysctrl.
.sp
Control the kernel sysctl system
.sp
.nf
.ft C
vm.swappines:
  sysctl.present:
    \- value: 20
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.sysctl.present(name, value, config=\(aq/etc/sysctl.conf\(aq)
Ensure that the named sysctl value is set in memory and persisted to the
named configuration file. The default sysctl configuration file is
/etc/sysctl.conf
.INDENT 7.0
.TP
.B name
The name of the sysctl value to edit
.TP
.B value
The sysctl value to apply
.TP
.B config
The location of the sysctl configuration file
.UNINDENT
.UNINDENT
.SS salt.states.timezone
.SS Management of timezones
.sp
The timezone can be managed for the system:
.sp
.nf
.ft C
America/Denver:
  timezone.system:
    \- utc: True
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.timezone.system(name, utc=\(aq\(aq)
Set the timezone for the system.
.INDENT 7.0
.TP
.B name
The name of the timezone to use (e.g.: America/Denver)
.TP
.B utc
Whether or not to use UTC (default is True)
.UNINDENT
.UNINDENT
.SS salt.states.tomcat
.sp
This state uses the manager webapp to manage Apache tomcat webapps
This state requires the manager webapp to be enabled
.sp
The following grains/pillar should be set:
.sp
.nf
.ft C
tomcat\-manager.user: admin user name
tomcat\-manager.passwd: password
.ft P
.fi
.sp
and also configure a user in the conf/tomcat\-users.xml file:
.sp
.nf
.ft C
<?xml version=\(aq1.0\(aq encoding=\(aqutf\-8\(aq?>
<tomcat\-users>
    <role rolename="manager\-script"/>
    <user username="tomcat" password="tomcat" roles="manager\-script"/>
</tomcat\-users>
.ft P
.fi
.sp
Notes:
.INDENT 0.0
.IP \(bu 2
Not supported multiple version on the same context path
.IP \(bu 2
More information about tomcat manager: \fI\%http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html\fP
.IP \(bu 2
if you use only this module for deployments you\(aqve might want to strict access to the manager only from localhost
for more info: \fI\%http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html#Configuring_Manager_Application_Access\fP
.IP \(bu 2
Tested on:
.INDENT 2.0
.TP
.B JVM Vendor:
Sun Microsystems Inc.
.TP
.B JVM Version:
1.6.0_43\-b01
.TP
.B OS Architecture:
amd64
.TP
.B OS Name:
Linux
.TP
.B OS Version:
2.6.32\-358.el6.x86_64
.TP
.B Tomcat Version:
Apache Tomcat/7.0.37
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.tomcat.mod_watch(name, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
The tomcat watcher function.
When called it will reload the webapp in question
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.tomcat.wait(name, url=\(aqhttp://localhost:8080/manager\(aq, timeout=180)
Wait for the tomcat manager to load
.sp
notice that if the tomcat is not running we won\(aqt wait for it start and the state will fail
this state can be required in the tomcat.war_deployed state to make sure tomcat is running and that the manager is running as well and ready for deployment
.INDENT 7.0
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request to the tomcat manager
.UNINDENT
.sp
Example:
.sp
.nf
.ft C
tomcat\-service:
  service:
    \- running
    \- name: tomcat
    \- enable: True

wait\-for\-tomcatmanager:
  tomcat:
    \- wait
    \- timeout: 300
    \- require:
      \- service: tomcat\-service

jenkins:
  tomcat:
    \- war_deployed
    \- name: /ran
    \- war: salt://jenkins\-1.2.4.war
    \- require:
      \- tomcat: wait\-for\-tomcatmanager
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.tomcat.war_deployed(name, war, url=\(aqhttp://localhost:8080/manager\(aq, __env__=\(aqbase\(aq, timeout=180)
Enforce that the WAR will be deployed and started in the context path
it will make use of WAR versions
.sp
for more info: \fI\%http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Naming\fP
.INDENT 7.0
.TP
.B name
the context path to deploy
.TP
.B war
absolute path to WAR file (should be accessible by the user running
tomcat) or a path supported by the salt.modules.cp.get_file function
.TP
.B url
\fI\%http://localhost:8080/manager\fP
the URL of the server manager webapp
.TP
.B timeout
180
timeout for HTTP request to the tomcat manager
.UNINDENT
.sp
Example:
.sp
.nf
.ft C
jenkins:
  tomcat.war_deployed:
    \- name: /ran
    \- war: salt://jenkins\-1.2.4.war
    \- require:
      \- service: application\-service
.ft P
.fi
.UNINDENT
.SS salt.states.user
.SS Management of user accounts.
.sp
The user module is used to create and manage user settings, users can be set
as either absent or present
.sp
.nf
.ft C
fred:
  user.present:
    \- fullname: Fred Jones
    \- shell: /bin/zsh
    \- home: /home/fred
    \- uid: 4000
    \- gid: 4000
    \- groups:
      \- wheel
      \- storage
      \- games

testuser:
  user.absent
.ft P
.fi
.INDENT 0.0
.TP
.B salt.states.user.absent(name, purge=False, force=False)
Ensure that the named user is absent
.INDENT 7.0
.TP
.B name
The name of the user to remove
.TP
.B purge
Set purge to delete all of the user\(aqs files as well as the user
.TP
.B force
If the user is logged in the absent state will fail, set the force
option to True to remove the user even if they are logged in
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.states.user.present(name, uid=None, gid=None, gid_from_name=False, groups=None, optional_groups=None, remove_groups=True, home=None, createhome=True, password=None, enforce_password=True, shell=None, unique=True, system=False, fullname=None, roomnumber=None, workphone=None, homephone=None)
Ensure that the named user is present with the specified properties
.INDENT 7.0
.TP
.B name
The name of the user to manage
.TP
.B uid
The user id to assign, if left empty then the next available user id
will be assigned
.TP
.B gid
The default group id
.TP
.B gid_from_name
If True, the default group id will be set to the id of the group with
the same name as the user.
.TP
.B groups
A list of groups to assign the user to, pass a list object. If a group
specified here does not exist on the minion, the state will fail.
If set to the empty list, the user will be removed from all groups
except the default group.
.TP
.B optional_groups
A list of groups to assign the user to, pass a list object. If a group
specified here does not exist on the minion, the state will silently
ignore it.
.UNINDENT
.sp
NOTE: If the same group is specified in both "groups" and
"optional_groups", then it will be assumed to be required and not optional.
.INDENT 7.0
.TP
.B remove_groups
Remove groups that the user is a member of that weren\(aqt specified in
the state, True by default
.TP
.B home
The location of the home directory to manage
.TP
.B createhome
If True, the home directory will be created if it doesn\(aqt exist.
Please note that directories leading up to the home directory
will NOT be created.
.TP
.B password
A password hash to set for the user. This field is only supported on
Linux, FreeBSD, NetBSD, OpenBSD, and Solaris
.UNINDENT
.sp
Changed in version 0.16.0: BSD support added.
.INDENT 7.0
.TP
.B enforce_password
Set to False to keep the password from being changed if it has already
been set and the password hash differs from what is specified in the
"password" field. This option will be ignored if "password" is not
specified.
.TP
.B shell
The login shell, defaults to the system default shell
.TP
.B unique
Require a unique UID, True by default
.TP
.B system
Choose UID in the range of FIRST_SYSTEM_UID and LAST_SYSTEM_UID.
.UNINDENT
.sp
User comment field (GECOS) support (currently Linux and FreeBSD only):
.sp
The below values should be specified as strings to avoid ambiguities when
the values are loaded. (Especially the phone and room number fields which
are likely to contain numeric data)
.INDENT 7.0
.TP
.B fullname
The user\(aqs full name.
.TP
.B roomnumber
The user\(aqs room number
.TP
.B workphone
The user\(aqs work phone number
.TP
.B homephone
The user\(aqs home phone number
.UNINDENT
.UNINDENT
.SS salt.states.virtualenv
.SS Setup of Python virtualenv sandboxes.
.INDENT 0.0
.TP
.B salt.states.virtualenv.managed(name, venv_bin=\(aqvirtualenv\(aq, requirements=\(aq\(aq, no_site_packages=False, system_site_packages=False, distribute=False, clear=False, python=\(aq\(aq, extra_search_dir=\(aq\(aq, never_download=False, prompt=\(aq\(aq, __env__=\(aqbase\(aq, runas=None, no_chown=False, cwd=None, index_url=None, extra_index_url=None)
Create a virtualenv and optionally manage it with pip
.INDENT 7.0
.TP
.B name
Path to the virtualenv
.TP
.B requirements
Path to a pip requirements file. If the path begins with \fBsalt://\fP
the file will be transfered from the master file server.
.TP
.B cwd
Path to the working directory where "pip install" is executed.
.UNINDENT
.sp
Also accepts any kwargs that the virtualenv module will.
.sp
.nf
.ft C
/var/www/myvirtualenv.com:
  virtualenv.managed:
    \- no_site_packages: True
    \- requirements: salt://REQUIREMENTS.txt
.ft P
.fi
.UNINDENT
.SH RENDERERS
.sp
The Salt state system operates by gathering information from simple data
structures. The state system was designed in this way to make interacting with
it generic and simple. This also means that state files (SLS files) can be one
of many formats.
.sp
By default SLS files are rendered as Jinja templates and then parsed as YAML
documents. But since the only thing the state system cares about is raw data,
the SLS files can be any structured format that can be dreamed up.
.sp
Currently there is support for \fBJinja + YAML\fP, \fBMako + YAML\fP,
\fBWempy + YAML\fP, \fBJinja + json\fP \fBMako + json\fP and \fBWempy + json\fP. But
renderers can be written to support anything. This means that the Salt states
could be managed by XML files, HTML files, puppet files, or any format that
can be translated into the data structure used by the state system.
.SS Multiple Renderers
.sp
When deploying a state tree a default renderer is selected in the master
configuration file with the renderer option. But multiple renderers can be
used inside the same state tree.
.sp
When rendering SLS files Salt checks for the presence of a Salt specific
shebang line. The shebang line syntax was chosen because it is familiar to
the target audience, the systems admin and systems engineer.
.sp
The shebang line directly calls the name of the renderer as it is specified
within Salt. One of the most common reasons to use multiple renderers in to
use the Python or \fBpy\fP renderer:
.sp
.nf
.ft C
#!py

def run():
    \(aq\(aq\(aq
    Install the python\-mako package
    \(aq\(aq\(aq
    return {\(aqinclude\(aq: [\(aqpython\(aq],
            \(aqpython\-mako\(aq: {\(aqpkg\(aq: [\(aqinstalled\(aq]}}
.ft P
.fi
.sp
The first line is a shebang that references the \fBpy\fP renderer.
.SS Composing Renderers
.sp
A renderer can be composed from other renderers by connecting them in a series
of pipes(\fB|\fP). In fact, the default \fBJinja + YAML\fP renderer is implemented
by combining a YAML renderer and a Jinja renderer. Such renderer configuration
is specified as: \fBjinja | yaml\fP.
.sp
Other renderer combinations are possible, here\(aqs a few examples:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fByaml\fP
i.e, just YAML, no templating.
.TP
.B \fBmako | yaml\fP
pass the input to the \fBmako\fP renderer, whose output is then fed into the
\fByaml\fP renderer.
.TP
.B \fBjinja | mako | yaml\fP
This one allows you to use both jinja and mako templating syntax in the
input and then parse the final rendered output as YAML.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
And here\(aqs a contrived example sls file using the \fBjinja | mako | yaml\fP renderer:
.sp
.nf
.ft C
#!jinja|mako|yaml

An_Example:
  cmd.run:
    \- name: |
        echo "Using Salt ${grains[\(aqsaltversion\(aq]}" \e
             "from path {{grains[\(aqsaltpath\(aq]}}."
    \- cwd: /

<%doc> ${...} is Mako\(aqs notation, and so is this comment. </%doc>
{#     Similarly, {{...}} is Jinja\(aqs notation, and so is this comment. #}
.ft P
.fi
.sp
For backward compatibility, \fBjinja | yaml\fP  can also be written as
\fByaml_jinja\fP, and similarly, the \fByaml_mako\fP, \fByaml_wempy\fP,
\fBjson_jinja\fP, \fBjson_mako\fP, and \fBjson_wempy\fP renderers are all supported
as well.
.sp
Keep in mind that not all renderers can be used alone or with any other renderers.
For example, the template renderers shouldn\(aqt be used alone as their outputs are
just strings, which still need to be parsed by another renderer to turn them into
highstate data structures. Also, for example, it doesn\(aqt make sense to specify
\fByaml | jinja\fP either, because the output of the yaml renderer is a highstate
data structure(a dict in Python), which cannot be used as the input to a template
renderer. Therefore, when combining renderers, you should know what each renderer
accepts as input and what it returns as output.
.SS Writing Renderers
.sp
Writing a renderer is easy, all that is required is that a Python module is
placed in the rendered directory and that the module implements the \fBrender\fP
function. The \fBrender\fP function will be passed the path of the SLS file.  In
the \fBrender\fP function, parse the passed file and return the data structure
derived from the file. You can place your custom renderers in a \fB_renderers\fP
directory within the \fBfile_roots\fP specified by the master config
file. These custom renderers are distributed when \fI\%state.highstate\fP is run, or
by executing the \fI\%saltutil.sync_renderers\fP or \fI\%saltutil.sync_all\fP functions.
.SS Examples
.sp
The best place to find examples of renderers is in the Salt source code. The
renderers included with Salt can be found here:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/renderers\fP
.sp
Here is a simple YAML renderer example:
.sp
.nf
.ft C
import yaml
def render(yaml_data, env=\(aq\(aq, sls=\(aq\(aq, **kws):
    if not isinstance(yaml_data, basestring):
        yaml_data = yaml_data.read()
    data = yaml.load(yaml_data)
    return data if data else {}
.ft P
.fi
.SH FULL LIST OF BUILTIN RENDERER MODULES
.TS
center;
|l|l|.
_
T{
\fBjinja\fP
T}	T{
T}
_
T{
\fBjson\fP
T}	T{
T}
_
T{
\fBmako\fP
T}	T{
T}
_
T{
\fBpy\fP
T}	T{
Pure python state renderer
T}
_
T{
\fBpydsl\fP
T}	T{
A Python\-based DSL
T}
_
T{
\fBstateconf\fP
T}	T{
A flexible renderer that takes a templating engine and a data format
T}
_
T{
\fBwempy\fP
T}	T{
T}
_
T{
\fByaml\fP
T}	T{
T}
_
.TE
.SS salt.renderers.jinja
.SS Jinja in States
.sp
The most basic usage of Jinja in state files is using control structures to wrap
conditional or redundant state elements:
.sp
.nf
.ft C
{% if grains[\(aqos\(aq] != \(aqFreeBSD\(aq %}
tcsh:
    pkg:
        \- installed
{% endif %}

motd:
  file.managed:
    {% if grains[\(aqos\(aq] == \(aqFreeBSD\(aq %}
    \- name: /etc/motd
    {% elif grains[\(aqos\(aq] == \(aqDebian\(aq %}
    \- name: /etc/motd.tail
    {% endif %}
    \- source: salt://motd
.ft P
.fi
.sp
In this example, the first if block will only be evaluated on minions that
aren\(aqt running FreeBSD, and the second block changes the file name based on the
\fIos\fP grain.
.sp
Writing \fBif\-else\fP blocks can lead to very redundant state files however. In
this case, using \fBpillars\fP, or using a previously
defined variable might be easier:
.sp
.nf
.ft C
{% set motd = [\(aq/etc/motd\(aq] %}
{% if grains[\(aqos\(aq] == \(aqDebian\(aq %}
  {% set motd = [\(aq/etc/motd.tail\(aq, \(aq/var/run/motd\(aq] %}
{% endif %}

{% for motdfile in motd %}
{{ motdfile }}:
  file.managed:
    \- source: salt://motd
{% endfor %}
.ft P
.fi
.sp
Using a variable set by the template, the \fI\%for loop\fP will iterate over the
list of MOTD files to update, adding a state block for each file.
.SS Passing Variables
.sp
It is also possible to pass additional variable context directly into a
template, using the \fBdefaults\fP and \fBcontext\fP mappings of the
\fBfile.managed\fP state:
.sp
.nf
.ft C
/etc/motd:
  file.managed:
    \- source: salt://motd
    \- template: jinja
    \- defaults:
        message: \(aqFoo\(aq
    {% if grains[\(aqos\(aq] == \(aqFreeBSD\(aq %}
    \- context:
        message: \(aqBar\(aq
    {% endif %}
.ft P
.fi
.sp
The template will receive a variable \fBmessage\fP, which would be accessed in the
template using \fB{{ message }}\fP. If the operating system is FreeBSD, the value
of the variable \fBmessage\fP would be \fIBar\fP, otherwise it is the default
\fIFoo\fP
.SS Include and Import
.sp
Includes and \fI\%imports\fP can be used to share common, reusable state configuration
between state files and between files.
.sp
.nf
.ft C
{% from \(aqlib.sls\(aq import test %}
.ft P
.fi
.sp
This would import the \fBtest\fP template variable or macro, not the \fBtest\fP
state element, from the file \fBlib.sls\fP. In the case that the included file
performs checks again grains, or something else that requires context, passing
the context into the included file is required:
.sp
.nf
.ft C
{% from \(aqlib.sls\(aq import test with context %}
.ft P
.fi
.SS Template Inheritance
.sp
\fI\%Template inheritance\fP works fine from state files and files. The search path
starts at the root of the state tree or pillar.
.SS Macros
.sp
\fI\%Macros\fP are helpful for eliminating redundant code, however stripping whitespace
from the template block, as well as contained blocks, may be necessary to
emulate a variable return from the macro.
.sp
.nf
.ft C
# init.sls
{% from \(aqlib.sls\(aq import pythonpkg with context %}

python\-virtualenv:
  pkg.installed:
    \- name: {{ pythonpkg(\(aqvirtualenv\(aq) }}

python\-fabric:
  pkg.installed:
    \- name: {{ pythonpkg(\(aqfabric\(aq) }}
.ft P
.fi
.sp
.nf
.ft C
# lib.sls
{% macro pythonpkg(pkg) \-%}
  {%\- if grains[\(aqos\(aq] == \(aqFreeBSD\(aq \-%}
    py27\-{{ pkg }}
  {%\- elif grains[\(aqos\(aq] == \(aqDebian\(aq \-%}
    python\-{{ pkg }}
  {%\- endif \-%}
{%\- endmacro %}
.ft P
.fi
.sp
This would define a \fI\%macro\fP that would return a string of the full package name,
depending on the packaging system\(aqs naming convention. The whitespace of the
macro was eliminated, so that the macro would return a string without line
breaks, using \fI\%whitespace control\fP.
.SS Jinja in Files
.sp
\fI\%Jinja\fP can be used in the same way in managed files:
.sp
.nf
.ft C
# redis.sls
/etc/redis/redis.conf:
    file.managed:
        \- source: salt://redis.conf
        \- template: jinja
        \- context:
            bind: 127.0.0.1
.ft P
.fi
.sp
.nf
.ft C
# lib.sls
{% set port = 6379 %}
.ft P
.fi
.sp
.nf
.ft C
# redis.conf
{% from \(aqlib.sls\(aq import port with context %}
port {{ port }}
bind {{ bind }}
.ft P
.fi
.sp
As an example, configuration was pulled from the file context and from an
external template file.
.INDENT 0.0
.TP
.B salt.renderers.jinja.render(template_file, env=\(aq\(aq, sls=\(aq\(aq, argline=\(aq\(aq, context=None, tmplpath=None, **kws)
Render the template_file, passing the functions and grains into the
Jinja rendering system.
.INDENT 7.0
.TP
.B Return type
string
.UNINDENT
.UNINDENT
.SS salt.renderers.json
.INDENT 0.0
.TP
.B salt.renderers.json.render(json_data, env=\(aq\(aq, sls=\(aq\(aq, **kws)
Accepts JSON as a string or as a file object and runs it through the JSON
parser.
.INDENT 7.0
.TP
.B Return type
A Python data structure
.UNINDENT
.UNINDENT
.SS salt.renderers.mako
.INDENT 0.0
.TP
.B salt.renderers.mako.render(template_file, env=\(aq\(aq, sls=\(aq\(aq, context=None, tmplpath=None, **kws)
Render the template_file, passing the functions and grains into the
Mako rendering system.
.INDENT 7.0
.TP
.B Return type
string
.UNINDENT
.UNINDENT
.SS salt.renderers.py
.sp
Pure python state renderer
.sp
The sls file should contain a function called \fBrun\fP which returns high state
data
.INDENT 0.0
.TP
.B salt.renderers.py.render(template, env=\(aq\(aq, sls=\(aq\(aq, tmplpath=None, **kws)
Render the python module\(aqs components
.INDENT 7.0
.TP
.B Return type
string
.UNINDENT
.UNINDENT
.SS salt.renderers.pydsl
.sp
A Python\-based DSL
.INDENT 0.0
.TP
.B maintainer
Jack Kuan <\fI\%kjkuan@gmail.com\fP>
.TP
.B maturity
new
.TP
.B platform
all
.UNINDENT
.sp
The \fIpydsl\fP renderer allows one to author salt formulas(.sls files) in pure
Python using a DSL that\(aqs easy to write and easy to read. Here\(aqs an example:
.sp
.nf
.ft C
 #!pydsl

 apache = state(\(aqapache\(aq)
 apache.pkg.installed()
 apache.service.running()
 state(\(aq/var/www/index.html\(aq) \e
     .file(\(aqmanaged\(aq,
           source=\(aqsalt://webserver/index.html\(aq) \e
     .require(pkg=\(aqapache\(aq)
.ft P
.fi
.sp
Notice that any Python code is allow in the file as it\(aqs really a Python
module, so you have the full power of Python at your disposal. In this module,
a few objects are defined for you, including the usual(with \fB__\fP added)
\fB__salt__\fP dictionary, \fB__grains__\fP, \fB__pillar__\fP, \fB__opts__\fP,
\fB__env__\fP, and \fB__sls__\fP, plus a few more:
.INDENT 0.0
.INDENT 3.5
\fB__file__\fP
.INDENT 0.0
.INDENT 3.5
local file system path to the sls module.
.UNINDENT
.UNINDENT
.sp
\fB__pydsl__\fP
.INDENT 0.0
.INDENT 3.5
Salt PyDSL object, useful for configuring DSL behavior per sls rendering.
.UNINDENT
.UNINDENT
.sp
\fBinclude\fP
.INDENT 0.0
.INDENT 3.5
Salt PyDSL function for creating \fIinclude declaration\fP\(aqs.
.UNINDENT
.UNINDENT
.sp
\fBextend\fP
.INDENT 0.0
.INDENT 3.5
Salt PyDSL function for creating \fIextend declaration\fP\(aqs.
.UNINDENT
.UNINDENT
.sp
\fBstate\fP
.INDENT 0.0
.INDENT 3.5
Salt PyDSL function for creating \fIID declaration\fP\(aqs.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
A state \fIID declaration\fP is created with a \fBstate(id)\fP function call.
Subsequent \fBstate(id)\fP call with the same id returns the same object. This
singleton access pattern applies to all declaration objects created with the DSL.
.sp
.nf
.ft C
state(\(aqexample\(aq)
assert state(\(aqexample\(aq) is state(\(aqexample\(aq)
assert state(\(aqexample\(aq).cmd is state(\(aqexample\(aq).cmd
assert state(\(aqexample\(aq).cmd.running is state(\(aqexample\(aq).cmd.running
.ft P
.fi
.sp
The \fIid\fP argument is optional. If omitted, an UUID will be generated and used as
the \fIid\fP.
.sp
\fBstate(id)\fP returns an object under which you can create a \fIstate declaration\fP
object by accessing an attribute named after \fIany\fP state module available in Salt.
.sp
.nf
.ft C
state(\(aqexample\(aq).cmd
state(\(aqexample\(aq).file
state(\(aqexample\(aq).pkg
\&...
.ft P
.fi
.sp
Then, a \fIfunction declaration\fP object can be created from a
\fIstate declaration\fP object by one of the following two ways:
.INDENT 0.0
.IP 1. 3
by directly calling the attribute named for the \fIstate declaration\fP, and
supplying the state function name as the first argument.
.UNINDENT
.sp
.nf
.ft C
state(\(aqexample\(aq).file(\(aqmanaged\(aq, ...)
.ft P
.fi
.INDENT 0.0
.IP 2. 3
by calling a method named after the state function on the \fIstate declaration\fP
object.
.UNINDENT
.sp
.nf
.ft C
state(\(aqexample\(aq).file.managed(...)
.ft P
.fi
.sp
With either way of creating a \fIfunction declaration\fP object, any
\fIfunction arg declaration\fP\(aqs can be passed as keyword arguments to the call.
Subsequent calls of a \fIfunction declaration\fP will update the arg declarations.
.sp
.nf
.ft C
state(\(aqexample\(aq).file(\(aqmanaged\(aq, source=\(aqsalt://webserver/index.html\(aq)
state(\(aqexample\(aq).file.managed(source=\(aqsalt://webserver/index.html\(aq)
.ft P
.fi
.sp
As a shortcut, the special \fIname\fP argument can also be passed as the first(second if
calling using the first way) positional argument.
.sp
.nf
.ft C
state(\(aqexample\(aq).cmd(\(aqrun\(aq, \(aqls \-la\(aq, cwd=\(aq/\(aq)
state(\(aqexample\(aq).cmd.run(\(aqls \-la\(aq, cwd=\(aq/\(aq)
.ft P
.fi
.sp
Finally, a \fIrequisite declaration\fP object with its \fIrequisite reference\fP\(aqs
can be created by invoking one of the requisite methods(\fBrequire\fP, \fBwatch\fP, \fBuse\fP,
\fBrequire_in\fP, \fBwatch_in\fP, and \fBuse_in\fP) on either a \fIfunction declaration\fP
object or a \fIstate declaration\fP object. The return value of a requisite call is
also a \fIfunction declaration\fP object, so you can chain several requisite calls
together.
.sp
Arguments to a requisite call can be a list of \fIstate declaration\fP objects and/or
a set of keyword arguments whose names are state modules and values are IDs of
\fIID declaration\fP\(aqs or names of \fIname declaration\fP\(aqs.
.sp
.nf
.ft C
apache2 = state(\(aqapache2\(aq)
apache2.pkg.installed()
state(\(aqlibapache2\-mod\-wsgi\(aq).pkg.installed()

# you can call requisites on function declaration
apache2.service.running() \e
               .require(apache2.pkg,
                        pkg=\(aqlibapache2\-mod\-wsgi\(aq) \e
               .watch(file=\(aq/etc/apache2/httpd.conf\(aq)

# or you can call requisites on state declaration.
# this actually creates an anonymous function declaration object
# to add the requisites.
apache2.service.require(state(\(aqlibapache2\-mod\-wsgi\(aq).pkg,
                        pkg=\(aqapache2\(aq) \e
               .watch(file=\(aq/etc/apache2/httpd.conf\(aq)

# we still need to set the name of the function declaration.
apache2.service.running()
.ft P
.fi
.sp
\fIinclude declaration\fP objects can be created with the \fBinclude\fP function,
while \fIextend declaration\fP objects can be created with the \fBextend\fP function,
whose arguments are just \fIfunction declaration\fP objects.
.sp
.nf
.ft C
include(\(aqedit.vim\(aq, \(aqhttp.server\(aq)
extend(state(\(aqapache2\(aq).service.watch(file=\(aq/etc/httpd/httpd.conf\(aq)
.ft P
.fi
.sp
The \fBinclude\fP function, by default, causes the included sls file to be rendered
as soon as the \fBinclude\fP function is called. It returns a list of rendered module
objects; sls files not rendered with the pydsl renderer return \fBNone\fP\(aqs.
This behavior creates no \fIinclude declaration\fP\(aqs in the resulting high state
data structure.
.sp
.nf
.ft C
import types

# including multiple sls returns a list.
_, mod = include(\(aqa\-non\-pydsl\-sls\(aq, \(aqa\-pydsl\-sls\(aq)

assert _ is None
assert isinstance(slsmods[1], types.ModuleType)

# including a single sls returns a single object
mod = include(\(aqa\-pydsl\-sls\(aq)

# myfunc is a function that calls state(...) to create more states.
mod.myfunc(1, 2, "three")
.ft P
.fi
.sp
Notice how you can define a reusable function in your pydsl sls module and then
call it via the module returned by \fBinclude\fP.
.sp
It\(aqs still possible to do late includes by passing the \fBdelayed=True\fP keyword
argument to \fBinclude\fP.
.sp
.nf
.ft C
include(\(aqedit.vim\(aq, \(aqhttp.server\(aq, delayed=True)
.ft P
.fi
.sp
Above will just create a \fIinclude declaration\fP in the rendered result, and
such call always returns \fBNone\fP.
.SS Special integration with the \fIcmd\fP state
.sp
Taking advantage of rendering a Python module, PyDSL allows you to declare a
state that calls a pre\-defined Python function when the state is executed.
.sp
.nf
.ft C
greeting = "hello world"
def helper(something, *args, **kws):
    print greeting                # hello world
    print something, args, kws    # test123 [\(aqa\(aq, \(aqb\(aq, \(aqc\(aq] {\(aqx\(aq: 1, \(aqy\(aq: 2}

state().cmd.call(helper, "test123", \(aqa\(aq, \(aqb\(aq, \(aqc\(aq, x=1, y=2)
.ft P
.fi
.sp
The \fIcmd.call\fP state function takes care of calling our \fBhelper\fP function
with the arguments we specified in the states, and translates the return value
of our function into a structure expected by the state system.
See \fBsalt.states.cmd.call()\fP for more information.
.SS Implicit ordering of states
.sp
Salt states are explicitly ordered via \fIrequisite declaration\fP\(aqs.
However, with \fIpydsl\fP it\(aqs possible to let the renderer track the order
of creation for \fIfunction declaration\fP objects, and implicitly add
\fBrequire\fP requisites for your states to enforce the ordering. This feature
is enabled by setting the \fBordered\fP option on \fB__pydsl__\fP.
.IP Note
this feature is only available if your minions are using Python >= 2.7.
.RE
.sp
.nf
.ft C
include(\(aqsome.sls.file\(aq)

A = state(\(aqA\(aq).cmd.run(cwd=\(aq/var/tmp\(aq)
extend(A)

__pydsl__.set(ordered=True)

for i in range(10):
    i = str(i)
    state(i).cmd.run(\(aqecho \(aq+i, cwd=\(aq/\(aq)
state(\(aq1\(aq).cmd.run(\(aqecho one\(aq)
state(\(aq2\(aq).cmd.run(name=\(aqecho two\(aq)
.ft P
.fi
.sp
Notice that the \fBordered\fP option needs to be set after any \fBextend\fP calls.
This is to prevent \fIpydsl\fP from tracking the creation of a state function that\(aqs
passed to an \fBextend\fP call.
.sp
Above example should create states from \fB0\fP to \fB9\fP that will output \fB0\fP,
\fBone\fP, \fBtwo\fP, \fB3\fP, ... \fB9\fP, in that order.
.sp
It\(aqs important to know that \fIpydsl\fP tracks the \fIcreations\fP of
\fIfunction declaration\fP objects, and automatically adds a \fBrequire\fP requisite
to a \fIfunction declaration\fP object that requires the last
\fIfunction declaration\fP object created before it in the sls file.
.sp
This means later calls(perhaps to update the function\(aqs \fIfunction arg declaration\fP) to a previously created function declaration will not change the order.
.SS Render time state execution
.sp
When Salt processes a salt formula file(\fI.sls\fP), the file is rendered to salt\(aqs
high state data representation by a renderer before the states can be executed.
In the case of the \fIpydsl\fP renderer, the .sls file is executed as a python module
as it is being rendered which makes it easy to execute a state at render time.
In \fIpydsl\fP, executing one or more states at render time can be done by calling a
configured \fIID declaration\fP object.
.sp
.nf
.ft C
#!pydsl

s = state() # save for later invocation

# configure it
s.cmd.run(\(aqecho at render time\(aq, cwd=\(aq/\(aq)
s.file.managed(\(aqtarget.txt\(aq, source=\(aqsalt://source.txt\(aq)

s() # execute the two states now
.ft P
.fi
.sp
Once an \fIID declaration\fP is called at render time it is detached from the
sls module as if it was never defined.
.IP Note
If \fIimplicit ordering\fP is enabled(ie, via \fB__pydsl__.set(ordered=True)\fP) then
the \fIfirst\fP invocation of a \fIID declaration\fP object must be done before a
new \fIfunction declaration\fP is created.
.RE
.SS Integration with the stateconf renderer
.sp
The \fBsalt.renderers.stateconf\fP renderer offers a few interesting features that
can be leveraged by the \fIpydsl\fP renderer. In particular, when using with the \fIpydsl\fP
renderer, we are interested in \fIstateconf\fP\(aqs sls namespacing feature(via dot\-prefixed
id declarations), as well as, the automatic \fIstart\fP and \fIgoal\fP states generation.
.sp
Now you can use \fIpydsl\fP with \fIstateconf\fP like this:
.sp
.nf
.ft C
#!pydsl|stateconf \-ps

include(\(aqxxx\(aq, \(aqyyy\(aq)

# ensure that states in xxx run BEFORE states in this file.
extend(state(\(aq.start\(aq).stateconf.require(stateconf=\(aqxxx::goal\(aq))

# ensure that states in yyy run AFTER states in this file.
extend(state(\(aq.goal\(aq).stateconf.require_in(stateconf=\(aqyyy::start\(aq))

__pydsl__.set(ordered=True)

\&...
.ft P
.fi
.sp
\fB\-s\fP enables the generation of a stateconf \fIstart\fP state, and \fB\-p\fP lets us pipe
high state data rendered by \fIpydsl\fP to \fIstateconf\fP. This example shows that by
\fBrequire\fP\-ing or \fBrequire_in\fP\-ing the included sls\(aq \fIstart\fP or \fIgoal\fP states,
it\(aqs possible to ensure that the included sls files can be made to execute before
or after a state in the including sls file.
.INDENT 0.0
.TP
.B salt.renderers.pydsl.render(template, env=\(aq\(aq, sls=\(aq\(aq, tmplpath=None, rendered_sls=None, **kws)
.UNINDENT
.SS salt.renderers.stateconf
.INDENT 0.0
.TP
.B maintainer
Jack Kuan <\fI\%kjkuan@gmail.com\fP>
.TP
.B maturity
new
.TP
.B platform
all
.UNINDENT
.sp
This module provides a custom renderer that processes a salt file with a
specified templating engine (e.g., Jinja) and a chosen data renderer (e.g., YAML),
extracts arguments for any \fBstateconf.set\fP state, and provides the extracted
arguments (including Salt\-specific args, such as \fBrequire\fP, etc) as template
context. The goal is to make writing reusable/configurable/parameterized
salt files easier and cleaner.
.sp
To use this renderer, either set it as the default renderer via the
\fBrenderer\fP option in master/minion\(aqs config, or use the shebang line in each
individual sls file, like so: \fB#!stateconf\fP. Note, due to the way this
renderer works, it must be specified as the first renderer in a render
pipeline. That is, you cannot specify \fB#!mako|yaml|stateconf\fP, for example.
Instead, you specify them as renderer arguments: \fB#!stateconf mako . yaml\fP.
.sp
Here\(aqs a list of features enabled by this renderer.
.INDENT 0.0
.IP \(bu 2
Prefixes any state id (declaration or reference) that starts with a dot (\fB.\fP)
to avoid duplicated state ids when the salt file is included by other salt
files.
.sp
For example, in the \fIsalt://some/file.sls\fP, a state id such as \fB.sls_params\fP
will be turned into \fBsome.file::sls_params\fP. Example:
.sp
.nf
.ft C
#!stateconf yaml . jinja

\&.vim:
  package.installed
.ft P
.fi
.sp
Above will be translated into:
.sp
.nf
.ft C
some.file::vim:
  package.installed:
    \- name: vim
.ft P
.fi
.sp
Notice how that if a state under a dot\-prefixed state id has no \fBname\fP
argument then one will be added automatically by using the state id with
the leading dot stripped off.
.sp
The leading dot trick can be used with extending state ids as well,
so you can include relatively and extend relatively. For example, when
extending a state in \fIsalt://some/other_file.sls\fP, e.g.,:
.sp
.nf
.ft C
#!stateconf yaml . jinja

include:
  \- .file

extend:
  .file::sls_params:
    stateconf.set:
      \- name1: something
.ft P
.fi
.sp
Above will be pre\-processed into:
.sp
.nf
.ft C
include:
  \- some.file

extend:
  some.file::sls_params:
    stateconf.set:
      \- name1: something
.ft P
.fi
.IP \(bu 2
Adds a \fBsls_dir\fP context variable that expands to the directory containing
the rendering salt file. So, you can write \fBsalt://{{sls_dir}}/...\fP to
reference templates files used by your salt file.
.IP \(bu 2
Recognizes the special state function, \fBstateconf.set\fP, that configures a
default list of named arguments usable within the template context of
the salt file. Example:
.sp
.nf
.ft C
#!stateconf yaml . jinja

\&.sls_params:
  stateconf.set:
    \- name1: value1
    \- name2: value2
    \- name3:
      \- value1
      \- value2
      \- value3
    \- require_in:
      \- cmd: output

# \-\-\- end of state config \-\-\-

\&.output:
  cmd.run:
    \- name: |
        echo \(aqname1={{sls_params.name1}}
              name2={{sls_params.name2}}
              name3[1]={{sls_params.name3[1]}}
        \(aq
.ft P
.fi
.sp
This even works with \fBinclude\fP + \fBextend\fP so that you can override
the default configured arguments by including the salt file and then
\fBextend\fP the \fBstateconf.set\fP states that come from the included salt
file. (\fIIMPORTANT: Both the included and the extending sls files must use the
stateconf renderer for this \(ga\(gaextend\(ga\(ga to work!\fP)
.sp
Notice that the end of configuration marker (\fB# \-\-\- end of state config \-\-\fP)
is needed to separate the use of \(aqstateconf.set\(aq form the rest of your salt
file. The regex that matches such marker can be configured via the
\fBstateconf_end_marker\fP option in your master or minion config file.
.sp
Sometimes, you\(aqd like to set a default argument value that\(aqs based on
earlier arguments in the same \fBstateconf.set\fP. For example, you may be
tempted to do something like this:
.sp
.nf
.ft C
#!stateconf yaml . jinja

\&.apache:
  stateconf.set:
    \- host: localhost
    \- port: 1234
    \- url: \(aqhttp://{{host}}:{{port}}/\(aq

# \-\-\- end of state config \-\-\-

\&.test:
  cmd.run:
    \- name: echo \(aq{{apache.url}}\(aq
    \- cwd: /
.ft P
.fi
.sp
However, this won\(aqt work, but can be worked around like so:
.sp
.nf
.ft C
#!stateconf yaml . jinja

\&.apache:
  stateconf.set:
    \- host: localhost
    \- port: 1234
{#  \- url: \(aqhttp://{{host}}:{{port}}/\(aq #}

# \-\-\- end of state config \-\-\-
# {{ apache.setdefault(\(aqurl\(aq, "http://%(host)s:%(port)s/" % apache) }}

\&.test:
  cmd.run:
    \- name: echo \(aq{{apache.url}}\(aq
    \- cwd: /
.ft P
.fi
.IP \(bu 2
Adds support for relative include and exclude of .sls files. Example:
.sp
.nf
.ft C
#!stateconf yaml . jinja

include:
  \- .apache
  \- .db.mysql

exclude:
  \- sls: .users
.ft P
.fi
.sp
If the above is written in a salt file at \fIsalt://some/where.sls\fP then
it will include \fIsalt://some/apache.sls\fP and \fIsalt://some/db/mysql.sls\fP,
and exclude \fIsalt://some/users.ssl\fP. Actually, it does that by rewriting
the above \fBinclude\fP and \fBexclude\fP into:
.sp
.nf
.ft C
include:
  \- some.apache
  \- some.db.mysql

exclude:
  \- sls: some.users
.ft P
.fi
.IP \(bu 2
Optionally (enabled by default, \fIdisable\fP via the \fI\-G\fP renderer option,
e.g., in the shebang line: \fB#!stateconf \-G\fP), generates a
\fBstateconf.set\fP goal state (state id named as \fB.goal\fP by default,
configurable via the master/minion config option, \fBstateconf_goal_state\fP)
that requires all other states in the salt file. Note, the \fB.goal\fP
state id is subject to dot\-prefix rename rule mentioned earlier.
.sp
Such goal state is intended to be required by some state in an including
salt file. For example, in your webapp salt file, if you include a
sls file that is supposed to setup Tomcat, you might want to make sure that
all states in the Tomcat sls file will be executed before some state in
the webapp sls file.
.IP \(bu 2
Optionally (enable via the \fI\-o\fP renderer option, e.g., in the shebang line:
\fB#!stateconf \-o\fP), orders the states in a sls file by adding a
\fBrequire\fP requisite to each state such that every state requires the
state defined just before it. The order of the states here is the order
they are defined in the sls file. (Note: this feature is only available
if your minions are using Python >= 2.7. For Python2.6, it should also
work if you install the \fIordereddict\fP module from PyPI)
.sp
By enabling this feature, you are basically agreeing to author your sls
files in a way that gives up the explicit (or implicit?) ordering imposed
by the use of \fBrequire\fP, \fBwatch\fP, \fBrequire_in\fP or \fBwatch_in\fP
requisites, and instead, you rely on the order of states you define in
the sls files. This may or may not be a better way for you. However, if
there are many states defined in a sls file, then it tends to be easier
to see the order they will be executed with this feature.
.sp
You are still allowed to use all the requisites, with a few restrictions.
You cannot \fBrequire\fP or \fBwatch\fP a state defined \fIafter\fP the current
state. Similarly, in a state, you cannot \fBrequire_in\fP or \fBwatch_in\fP
a state defined \fIbefore\fP it. Breaking any of the two restrictions above
will result in a state loop. The renderer will check for such incorrect
uses if this feature is enabled.
.sp
Additionally, \fBnames\fP declarations cannot be used with this feature
because the way they are compiled into low states make it impossible to
guarantee the order in which they will be executed. This is also checked
by the renderer. As a workaround for not being able to use \fBnames\fP,
you can achieve the same effect, by generate your states with the
template engine available within your sls file.
.sp
Finally, with the use of this feature, it becomes possible to easily make
an included sls file execute all its states \fIafter\fP some state (say, with
id \fBX\fP) in the including sls file.  All you have to do is to make state,
\fBX\fP, \fBrequire_in\fP the first state defined in the included sls file.
.UNINDENT
.sp
When writing sls files with this renderer, you should avoid using what can be
defined in a \fBname\fP argument of a state as the state\(aqs id. That is, avoid
writing your states like this:
.sp
.nf
.ft C
/path/to/some/file:
  file.managed:
    \- source: salt://some/file

cp /path/to/some/file file2:
  cmd.run:
    \- cwd: /
    \- require:
      \- file: /path/to/some/file
.ft P
.fi
.sp
Instead, you should define the state id and the \fBname\fP argument separately
for each state, and the id should be something meaningful and easy to reference
within a requisite (which I think is a good habit anyway, and such extra
indirection would also makes your sls file easier to modify later). Thus, the
above states should be written like this:
.sp
.nf
.ft C
add\-some\-file:
  file.managed:
    \- name: /path/to/some/file
    \- source: salt://some/file

copy\-files:
  cmd.run:
    \- name: cp /path/to/some/file file2
    \- cwd: /
    \- require:
      \- file: add\-some\-file
.ft P
.fi
.sp
Moreover, when referencing a state from a requisite, you should reference the
state\(aqs id plus the state name rather than the state name plus its \fBname\fP
argument. (Yes, in the above example, you can actually \fBrequire\fP the
\fBfile: /path/to/some/file\fP, instead of the \fBfile: add\-some\-file\fP). The
reason is that this renderer will re\-write or rename state id\(aqs and their
references for state id\(aqs prefixed with \fB.\fP. So, if you reference \fBname\fP
then there\(aqs no way to reliably rewrite such reference.
.SS salt.renderers.wempy
.INDENT 0.0
.TP
.B salt.renderers.wempy.render(template_file, env=\(aq\(aq, sls=\(aq\(aq, argline=\(aq\(aq, context=None, **kws)
Render the data passing the functions and grains into the rendering system
.INDENT 7.0
.TP
.B Return type
string
.UNINDENT
.UNINDENT
.SS salt.renderers.yaml
.INDENT 0.0
.TP
.B salt.renderers.yaml.get_yaml_loader(argline)
.UNINDENT
.INDENT 0.0
.TP
.B salt.renderers.yaml.render(yaml_data, env=\(aq\(aq, sls=\(aq\(aq, argline=\(aq\(aq, **kws)
Accepts YAML as a string or as a file object and runs it through the YAML
parser.
.INDENT 7.0
.TP
.B Return type
A Python data structure
.UNINDENT
.UNINDENT
.SH PILLARS
.sp
Salt includes a number of built\-in external pillars, listed at
\fIall\-salt.pillars\fP.
.sp
You may also wish to look at the standard pillar documentation, at
\fIpillar\-configuration\fP
.sp
The source for the built\-in Salt pillars can be found here:
\fI\%https://github.com/saltstack/salt/blob/develop/salt/pillar\fP
.SH FULL LIST OF BUILTIN PILLAR MODULES
.TS
center;
|l|l|.
_
T{
\fBcmd_json\fP
T}	T{
Execute a command and read the output as JSON. The JSON data is then directly
T}
_
T{
\fBcmd_yaml\fP
T}	T{
Execute a command and read the output as YAML. The YAML data is then directly
T}
_
T{
\fBcobbler\fP
T}	T{
Cobbler Pillar
T}
_
T{
\fBhiera\fP
T}	T{
Take in a hiera configuration file location and execute it.
T}
_
T{
\fBlibvirt\fP
T}	T{
Load up the libvirt keys into pillar for a given minion if said keys have
T}
_
T{
\fBmongo\fP
T}	T{
Read pillar data from a mongodb collection.
T}
_
T{
\fBpillar_ldap\fP
T}	T{
This pillar module parses a config file (specified in the salt master config),
T}
_
T{
\fBpuppet\fP
T}	T{
Execute an unmodified puppet_node_classifier and read the output as YAML.
T}
_
T{
\fBreclass\fP
T}	T{
T}
_
.TE
.SS salt.pillar.cmd_json
.sp
Execute a command and read the output as JSON. The JSON data is then directly
overlaid onto the minion\(aqs pillar data
.INDENT 0.0
.TP
.B salt.pillar.cmd_json.ext_pillar(pillar, command)
Execute a command and read the output as JSON
.UNINDENT
.SS salt.pillar.cmd_yaml
.sp
Execute a command and read the output as YAML. The YAML data is then directly
overlaid onto the minion\(aqs pillar data
.INDENT 0.0
.TP
.B salt.pillar.cmd_yaml.ext_pillar(pillar, command)
Execute a command and read the output as YAML
.UNINDENT
.SS salt.pillar.cobbler
.SS Cobbler Pillar
.sp
A pillar module to pull data from Cobbler via its API into the pillar dictionary.
.SS Configuring the Cobbler ext_pillar
.sp
The same cobbler.* parameters are used for both the Cobbler tops and Cobbler pillar
modules.
.sp
.nf
.ft C
ext_pillar:
\- cobbler:
  \- key: cobbler # Nest results within this key. By default, values are not nested.
  \- only: [parameters] # Add only these keys to pillar.

cobbler.url: https://example.com/cobbler_api #default is http://localhost/cobbler_api
cobbler.user: username # default is no username
cobbler.password: password # default is no password
.ft P
.fi
.SS Module Documentation
.INDENT 0.0
.TP
.B salt.pillar.cobbler.ext_pillar(pillar, key=None, only=())
Read pillar data from Cobbler via its API.
.UNINDENT
.SS salt.pillar.hiera
.sp
Take in a hiera configuration file location and execute it.
Adds the hiera data to pillar
.INDENT 0.0
.TP
.B salt.pillar.hiera.ext_pillar(pillar, conf)
Execute hiera and return the data
.UNINDENT
.SS salt.pillar.libvirt
.sp
Load up the libvirt keys into pillar for a given minion if said keys have
been generated using the libvirt key runner.
.INDENT 0.0
.TP
.B salt.pillar.libvirt.ext_pillar(pillar, command)
Read in the generated libvirt keys
.UNINDENT
.INDENT 0.0
.TP
.B salt.pillar.libvirt.gen_hyper_keys(country=\(aqUS\(aq, state=\(aqUtah\(aq, locality=\(aqSalt Lake City\(aq, organization=\(aqSalted\(aq)
Generate the keys to be used by libvirt hypervisors, this routine gens
the keys and applies them to the pillar for the hypervisor minions
.UNINDENT
.SS salt.pillar.mongo
.sp
Read pillar data from a mongodb collection.
.sp
This module will load a node\-specific pillar dictionary from a mongo
collection. It uses the node\(aqs id for lookups and can load either the whole
document, or just a specific field from that
document as the pillar dictionary.
.SS Salt Master Mongo Configuration
.sp
The module shares the same base mongo connection variables as
\fBsalt.returners.mongo_return\fP. These variables go in your master
config file.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBmongo.db\fP \- The mongo database to connect to. Defaults to \fB\(aqsalt\(aq\fP.
.IP \(bu 2
\fBmongo.host\fP \- The mongo host to connect to. Supports replica sets by
specifying all hosts in the set, comma\-delimited. Defaults to \fB\(aqsalt\(aq\fP.
.IP \(bu 2
\fBmongo.port\fP \- The port that the mongo database is running on. Defaults
to \fB27017\fP.
.IP \(bu 2
\fBmongo.user\fP \- The username for connecting to mongo. Only required if
you are using mongo authentication. Defaults to \fB\(aq\(aq\fP.
.IP \(bu 2
\fBmongo.password\fP \- The password for connecting to mongo. Only required
if you are using mongo authentication. Defaults to \fB\(aq\(aq\fP.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Configuring the Mongo ext_pillar
.sp
The Mongo ext_pillar takes advantage of the fact that the Salt Master
configuration file is yaml. It uses a sub\-dictionary of values to adjust
specific features of the pillar. This is the explicit single\-line dictionary
notation for yaml. One may be able to get the easier\-to\-read multine dict to
work correctly with some experimentation.
.sp
.nf
.ft C
ext_pillar:
  \- mongo: {collection: vm, id_field: name, re_pattern: \e.example\e.com, fields: [customer_id, software, apache_vhosts]}
.ft P
.fi
.sp
In the example above, we\(aqve decided to use the \fBvm\fP collection in the
database to store the data. Minion ids are stored in the \fBname\fP field on
documents in that collection. And, since minion ids are FQDNs in most cases,
we\(aqll need to trim the domain name in order to find the minion by hostname in
the collection. When we find a minion, return only the \fBcustomer_id\fP,
\fBsoftware\fP, and \fBapache_vhosts\fP fields, as that will contain the data we
want for a given node. They will be available directly inside the \fBpillar\fP
dict in your SLS templates.
.SS Module Documentation
.INDENT 0.0
.TP
.B salt.pillar.mongo.ext_pillar(pillar, collection=\(aqpillar\(aq, id_field=\(aq_id\(aq, re_pattern=None, re_replace=\(aq\(aq, fields=None)
Connect to a mongo database and read per\-node pillar information.
.INDENT 7.0
.TP
.B Parameters:
.INDENT 7.0
.IP \(bu 2
\fIcollection\fP: The mongodb collection to read data from. Defaults to
\fB\(aqpillar\(aq\fP.
.IP \(bu 2
\fIid_field\fP: The field in the collection that represents an individual
minion id. Defaults to \fB\(aq_id\(aq\fP.
.IP \(bu 2
\fIre_pattern\fP: If your naming convention in the collection is shorter
than the minion id, you can use this to trim the name.
\fIre_pattern\fP will be used to match the name, and \fIre_replace\fP will
be used to replace it. Backrefs are supported as they are in the
Python standard library. If \fBNone\fP, no mangling of the name will
be performed \- the collection will be searched with the entire
minion id. Defaults to \fBNone\fP.
.IP \(bu 2
\fIre_replace\fP: Use as the replacement value in node ids matched with
\fIre_pattern\fP. Defaults to \(aq\(aq. Feel free to use backreferences here.
.IP \(bu 2
\fIfields\fP: The specific fields in the document to use for the pillar
data. If \fBNone\fP, will use the entire document. If using the
entire document, the \fB_id\fP field will be converted to string. Be
careful with other fields in the document as they must be string
serializable. Defaults to \fBNone\fP.
.UNINDENT
.UNINDENT
.UNINDENT
.SS salt.pillar.pillar_ldap
.sp
This pillar module parses a config file (specified in the salt master config),
and executes a series of LDAP searches based on that config.  Data returned by
these searches is aggregated, with data items found later in the LDAP search
order overriding data found earlier on.
The final result set is merged with the pillar data.
.INDENT 0.0
.TP
.B salt.pillar.pillar_ldap.ext_pillar(pillar, config_file)
Execute LDAP searches and return the aggregated data
.UNINDENT
.SS salt.pillar.puppet
.sp
Execute an unmodified puppet_node_classifier and read the output as YAML.
The YAML data is then directly overlaid onto the minion\(aqs pillar data.
.INDENT 0.0
.TP
.B salt.pillar.puppet.ext_pillar(pillar, command)
Execute an unmodified puppet_node_classifier and read the output as YAML
.UNINDENT
.SH MASTER TOPS
.sp
Salt includes a number of built\-in subsystems to generate top file data, they
are listed listed at
\fIall\-salt.tops\fP.
.sp
The source for the built\-in Salt master tops can be found here:
\fI\%https://github.com/saltstack/salt/blob/develop/salt/tops\fP
.SH FULL LIST OF BUILTIN MASTER TOPS MODULES
.TS
center;
|l|l|.
_
T{
\fBext_nodes\fP
T}	T{
External Nodes Classifier
T}
_
T{
\fBcobbler\fP
T}	T{
Cobbler Tops
T}
_
T{
\fBmongo\fP
T}	T{
Read tops data from a mongodb collection.
T}
_
T{
\fBreclass\fP
T}	T{
T}
_
.TE
.SS salt.tops.ext_nodes
.SS External Nodes Classifier
.sp
The External Nodes Classifier is a master tops subsystem used to hook into
systems used to provide mapping information used by major configuration
management systems. One of the most common external nodes classification
system is provided by Cobbler and is called \fBcobbler\-ext\-nodes\fP.
.sp
The cobbler\-ext\-nodes command can be used with this configuration:
.sp
.nf
.ft C
master_tops:
  ext_nodes: cobbler\-ext\-nodes
.ft P
.fi
.sp
It is noteworthy that the Salt system does not directly ingest the data
sent from the \fBcobbler\-ext\-nodes\fP command, but converts the data into
information that is used by a Salt top file.
.INDENT 0.0
.TP
.B salt.tops.ext_nodes.top(**kwargs)
Run the command configured
.UNINDENT
.SS salt.tops.cobbler
.SS Cobbler Tops
.sp
Cobbler Tops is a master tops subsystem used to look up mapping information
from Cobbler via its API. The same cobbler.* parameters are used for both
the Cobbler tops and Cobbler pillar modules.
.sp
.nf
.ft C
master_tops:
  cobbler: {}
cobbler.url: https://example.com/cobbler_api #default is http://localhost/cobbler_api
cobbler.user: username # default is no username
cobbler.password: password # default is no password
.ft P
.fi
.SS Module Documentation
.INDENT 0.0
.TP
.B salt.tops.cobbler.top(**kwargs)
Look up top data in Cobbler for a minion.
.UNINDENT
.SS salt.tops.mongo
.sp
Read tops data from a mongodb collection.
.sp
This module will load tops data from a mongo collection. It uses the node\(aqs id
for lookups.
.SS Salt Master Mongo Configuration
.sp
The module shares the same base mongo connection variables as
\fBsalt.returners.mongo_return\fP. These variables go in your master
config file.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBmongo.db\fP \- The mongo database to connect to. Defaults to \fB\(aqsalt\(aq\fP.
.IP \(bu 2
\fBmongo.host\fP \- The mongo host to connect to. Supports replica sets by
specifying all hosts in the set, comma\-delimited. Defaults to \fB\(aqsalt\(aq\fP.
.IP \(bu 2
\fBmongo.port\fP \- The port that the mongo database is running on. Defaults
to \fB27017\fP.
.IP \(bu 2
\fBmongo.user\fP \- The username for connecting to mongo. Only required if
you are using mongo authentication. Defaults to \fB\(aq\(aq\fP.
.IP \(bu 2
\fBmongo.password\fP \- The password for connecting to mongo. Only required
if you are using mongo authentication. Defaults to \fB\(aq\(aq\fP.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Configuring the Mongo Tops Subsystem
.sp
.nf
.ft C
master_tops:
  mongo:
    collection: tops
    id_field: _id
    re_replace: ""
    re_pattern: \e.example\e.com
    states_field: states
    environment_field: environment
.ft P
.fi
.SS Module Documentation
.INDENT 0.0
.TP
.B salt.tops.mongo.top(**kwargs)
Connect to a mongo database and read per\-node tops data.
.INDENT 7.0
.TP
.B Parameters:
.INDENT 7.0
.IP \(bu 2
\fIcollection\fP: The mongodb collection to read data from. Defaults to
\fB\(aqtops\(aq\fP.
.IP \(bu 2
\fIid_field\fP: The field in the collection that represents an individual
minion id. Defaults to \fB\(aq_id\(aq\fP.
.IP \(bu 2
\fIre_pattern\fP: If your naming convention in the collection is shorter
than the minion id, you can use this to trim the name.
\fIre_pattern\fP will be used to match the name, and \fIre_replace\fP will
be used to replace it. Backrefs are supported as they are in the
Python standard library. If \fBNone\fP, no mangling of the name will
be performed \- the collection will be searched with the entire
minion id. Defaults to \fBNone\fP.
.IP \(bu 2
\fIre_replace\fP: Use as the replacement value in node ids matched with
\fIre_pattern\fP. Defaults to \(aq\(aq. Feel free to use backreferences here.
.IP \(bu 2
\fIstates_field\fP: The name of the field providing a list of states.
.IP \(bu 2
\fIenvironment_field\fP: The name of the field providing the environment.
Defaults to \fBenvironment\fP.
.UNINDENT
.UNINDENT
.UNINDENT
.SH SALT RUNNERS
.IP "See also"
.sp
\fIThe full list of runners\fP
.RE
.sp
Salt runners are convenience applications executed with the salt\-run command.
Where as salt modules are sent out to minions for execution, salt runners are
executed on the salt master.
.sp
A Salt runner can be a simple client call, or a complex application.
.sp
The use for a Salt runner is to build a frontend hook for running sets of
commands via Salt or creating special formatted output.
.SS Writing Salt Runners
.sp
Salt runners can be easily written, the work in a similar way to Salt modules
except they run on the server side.
.sp
A runner is a Python module that contains functions, each public function is
a runner that can be executed via the \fIsalt\-run\fP command.
.sp
If a Python module named test.py is created in the runners directory and
contains a function called \fBfoo\fP then the function could be called with:
.sp
.nf
.ft C
# salt\-run test.foo
.ft P
.fi
.SS Examples
.sp
The best examples of runners can be found in the Salt source:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/runners\fP
.sp
A simple runner that returns a well\-formatted list of the minions that are
responding to Salt calls would look like this:
.sp
.nf
.ft C
# Import salt modules
import salt.client

def up():
    \(aq\(aq\(aq
    Print a list of all of the minions that are up
    \(aq\(aq\(aq
    client = salt.client.LocalClient(__opts__[\(aqconf_file\(aq])
    minions = client.cmd(\(aq*\(aq, \(aqtest.ping\(aq, timeout=1)
    for minion in sorted(minions):
        print minion
.ft P
.fi
.SH FULL LIST OF RUNNER MODULES
.TS
center;
|l|l|.
_
T{
\fBcache\fP
T}	T{
Return cached data from minions
T}
_
T{
\fBdoc\fP
T}	T{
A runner module to collect and display the inline documentation from the
T}
_
T{
\fBfileserver\fP
T}	T{
Directly manage the salt fileserver plugins
T}
_
T{
\fBjobs\fP
T}	T{
A convenience system to manage jobs, both active and already run
T}
_
T{
\fBlaunchd\fP
T}	T{
T}
_
T{
\fBmanage\fP
T}	T{
General management functions for salt, tools like seeing what hosts are up
T}
_
T{
\fBnetwork\fP
T}	T{
Network tools to run from the Master
T}
_
T{
\fBsearch\fP
T}	T{
Runner frontend to search system
T}
_
T{
\fBstate\fP
T}	T{
Execute overstate functions
T}
_
T{
\fBvirt\fP
T}	T{
Control virtual machines via Salt
T}
_
T{
\fBwinrepo\fP
T}	T{
Runner to manage Windows software repo
T}
_
.TE
.SS salt.runners.cache
.sp
Return cached data from minions
.INDENT 0.0
.TP
.B salt.runners.cache.grains(minion=None)
Return cached grains for all minions or a specific minion
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.cache.pillar(minion=None)
Return cached grains for all minions or a specific minion
.UNINDENT
.SS salt.runners.doc
.sp
A runner module to collect and display the inline documentation from the
various module types
.INDENT 0.0
.TP
.B salt.runners.doc.execution()
Collect all the sys.doc output from each minion and return the aggregate
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.doc.runner()
Return all inline documetation for runner modules
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.doc.wheel()
Return all inline documentation for wheel modules
.UNINDENT
.SS salt.runners.fileserver
.sp
Directly manage the salt fileserver plugins
.INDENT 0.0
.TP
.B salt.runners.fileserver.update()
Execute an update for all of the configured fileserver backends
.UNINDENT
.SS salt.runners.jobs
.sp
A convenience system to manage jobs, both active and already run
.INDENT 0.0
.TP
.B salt.runners.jobs.active()
Return a report on all actively running jobs from a job id centric
perspective
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.jobs.list_jobs()
List all detectable jobs and associated functions
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.jobs.lookup_jid(jid, ext_source=None)
Return the printout from a previously executed job
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.jobs.print_job(job_id)
Print job available details, including return data.
.UNINDENT
.SS salt.runners.launchd
.INDENT 0.0
.TP
.B salt.runners.launchd.write_launchd_plist(program)
Write a launchd plist for managing salt\-master or salt\-minion
.UNINDENT
.SS salt.runners.manage
.sp
General management functions for salt, tools like seeing what hosts are up
and what hosts are down
.INDENT 0.0
.TP
.B salt.runners.manage.down()
Print a list of all the down or unresponsive salt minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.manage.key_regen()
This routine is used to regenerate all keys in an environment. This is
invasive! ALL KEYS IN THE SALT ENVIRONMENT WILL BE REGENERATED!!
.sp
The key_regen routine sends a command out to minions to revoke the master
key and remove all minion keys, it then removes all keys from the master
and prompts the user to restart the master. The minions will all reconnect
and keys will be placed in pending.
.sp
After the master is restarted and minion keys are in the pending directory
execute a salt\-key \-A command to accept the regenerated minion keys.
.sp
Only Execute this runner after upgrading minions and master to 0.15.1 or
higher!
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.manage.status(output=True)
Print the status of all known salt minions
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.manage.up()
Print a list of all of the minions that are up
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.manage.versions()
Check the version of active minions
.UNINDENT
.SS salt.runners.network
.sp
Network tools to run from the Master
.INDENT 0.0
.TP
.B salt.runners.network.wol(mac, bcast=\(aq255.255.255.255\(aq, destport=9)
Send a "Magic Packet" to wake up a Minion
.sp
CLI Example:
.sp
.nf
.ft C
salt\-run network.wol 08\-00\-27\-13\-69\-77
salt\-run network.wol 080027136977 255.255.255.255 7
salt\-run network.wol 08:00:27:13:69:77 255.255.255.255 7
.ft P
.fi
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.network.wollist(maclist, bcast=\(aq255.255.255.255\(aq, destport=9)
Send a "Magic Packet" to wake up a list of Minions.
This list must contain one MAC hardware address per line
.sp
CLI Example:
.sp
.nf
.ft C
salt\-run network.wollist \(aq/path/to/maclist\(aq
salt\-run network.wollist \(aq/path/to/maclist\(aq 255.255.255.255 7
salt\-run network.wollist \(aq/path/to/maclist\(aq 255.255.255.255 7
.ft P
.fi
.UNINDENT
.SS salt.runners.search
.sp
Runner frontend to search system
.INDENT 0.0
.TP
.B salt.runners.search.query(term)
Query the search system
.UNINDENT
.SS salt.runners.state
.sp
Execute overstate functions
.INDENT 0.0
.TP
.B salt.runners.state.over(env=\(aqbase\(aq, os_fn=None)
Execute an overstate sequence to orchestrate the executing of states
over a group of systems
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.state.show_stages(env=\(aqbase\(aq, os_fn=None)
Display the stage data to be executed
.UNINDENT
.SS salt.runners.virt
.sp
Control virtual machines via Salt
.INDENT 0.0
.TP
.B salt.runners.virt.force_off(name)
Force power down the named virtual machine
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.hyper_info(hyper=None)
Return information about the hypervisors connected to this master
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.init(name, cpu, mem, image, hyper=None, seed=True, nic=\(aqdefault\(aq)
Initialize a new vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.migrate(name, target=\(aq\(aq)
Migrate a vm from one hypervisor to another. This routine will just start
the migration and display information on how to look up the progress
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.next_hyper()
Return the hypervisor to use for the next autodeployed vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.pause(name)
Pause the named vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.purge(name)
Destroy the named vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.query(hyper=None, quiet=False)
Query the virtual machines
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.reset(name)
Force power down and restart an existing vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.resume(name)
Resume a paused vm
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.start(name)
Start a named virtual machine
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.virt.vm_info(name, quiet=False)
Return the information on the named vm
.UNINDENT
.SS salt.runners.winrepo
.sp
Runner to manage Windows software repo
.INDENT 0.0
.TP
.B salt.runners.winrepo.genrepo()
Generate win_repo_cachefile based on sls files in the win_repo
.UNINDENT
.INDENT 0.0
.TP
.B salt.runners.winrepo.update_git_repos()
Checkout git repos containing Windows Software Package Definitions
.UNINDENT
.SH FULL LIST OF BUILTIN WHEEL MODULES
.TS
center;
|l|l|.
_
T{
\fBconfig\fP
T}	T{
Manage the master configuration file
T}
_
T{
\fBfile_roots\fP
T}	T{
Read in files from the file_root and save files to the file root
T}
_
T{
\fBkey\fP
T}	T{
Wheel system wrapper for key system
T}
_
T{
\fBpillar_roots\fP
T}	T{
The \fIpillar_roots\fP wheel module is used to manage files under the pillar roots
T}
_
.TE
.SS salt.wheel.config
.sp
Manage the master configuration file
.INDENT 0.0
.TP
.B salt.wheel.config.apply(key, value)
Set a single key
.IP Note
This will strip comments from your config file
.RE
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.config.values()
Return the raw values of the config file
.UNINDENT
.SS salt.wheel.file_roots
.sp
Read in files from the file_root and save files to the file root
.INDENT 0.0
.TP
.B salt.wheel.file_roots.find(path, env=\(aqbase\(aq)
Return a dict of the files located with the given path and environment
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.file_roots.list_env(env=\(aqbase\(aq)
Return all of the file paths found in an environment
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.file_roots.list_roots()
Return all of the files names in all available environments
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.file_roots.read(path, env=\(aqbase\(aq)
Read the contents of a text file, if the file is binary then
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.file_roots.write(data, path, env=\(aqbase\(aq, index=0)
Write the named file, by default the first file found is written, but the
index of the file can be specified to write to a lower priority file root
.UNINDENT
.SS salt.wheel.key
.sp
Wheel system wrapper for key system
.INDENT 0.0
.TP
.B salt.wheel.key.accept(match)
Accept keys based on a glob match
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.delete(match)
Delete keys based on a glob match
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.finger(match)
Return the matching key fingerprints
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.key_str(match)
Return the key strings
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.list_(match)
List all the keys under a named status
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.list_all()
List all the keys
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.key.reject(match)
Delete keys based on a glob match
.UNINDENT
.SS salt.wheel.pillar_roots
.sp
The \fIpillar_roots\fP wheel module is used to manage files under the pillar roots
directories on the master server.
.INDENT 0.0
.TP
.B salt.wheel.pillar_roots.find(path, env=\(aqbase\(aq)
Return a dict of the files located with the given path and environment
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.pillar_roots.list_env(env=\(aqbase\(aq)
Return all of the file paths found in an environment
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.pillar_roots.list_roots()
Return all of the files names in all available environments
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.pillar_roots.read(path, env=\(aqbase\(aq)
Read the contents of a text file, if the file is binary then
.UNINDENT
.INDENT 0.0
.TP
.B salt.wheel.pillar_roots.write(data, path, env=\(aqbase\(aq, index=0)
Write the named file, by default the first file found is written, but the
index of the file can be specified to write to a lower priority file root
.UNINDENT
.SH FULL LIST OF BUILTIN OUTPUT MODULES
.TS
center;
|l|l|.
_
T{
\fBgrains\fP
T}	T{
Special outputter for grains
T}
_
T{
\fBhighstate\fP
T}	T{
The return data from the Highstate command is a standard data structure
T}
_
T{
\fBjson_out\fP
T}	T{
The JSON output module converts the return data into JSON.
T}
_
T{
\fBkey\fP
T}	T{
Salt Key makes use of the outputter system to format information sent to the
T}
_
T{
\fBnested\fP
T}	T{
Recursively display nested data, this is the default outputter.
T}
_
T{
\fBno_out\fP
T}	T{
Display no output.
T}
_
T{
\fBno_return\fP
T}	T{
Display output for minions that did not return
T}
_
T{
\fBoverstatestage\fP
T}	T{
Display clean output of an overstate stage
T}
_
T{
\fBpprint_out\fP
T}	T{
The python pretty print system was the default outputter.
T}
_
T{
\fBraw\fP
T}	T{
The raw outputter outputs the data via the python print function and is shown in a raw state.
T}
_
T{
\fBtxt\fP
T}	T{
The txt outputter has been developed to make the output from shell
T}
_
T{
\fBvirt_query\fP
T}	T{
virt.query outputter
T}
_
T{
\fByaml_out\fP
T}	T{
Output data in YAML, this outputter defaults to printing in YAML block mode
T}
_
.TE
.SS salt.output.grains
.sp
Special outputter for grains
.INDENT 0.0
.TP
.B salt.output.grains.output(grains)
Output the grains in a clean way
.UNINDENT
.SS salt.output.highstate
.sp
The return data from the Highstate command is a standard data structure
which is parsed by the highstate outputter to deliver a clean and readable
set of information about the HighState run on minions.
.sp
Two configurations can be set to modify the highstate outputter. These values
can be set in the master config to change the output of the \fBsalt\fP command or
set in the minion config to change the output of the \fBsalt\-call\fP command.
.INDENT 0.0
.TP
.B state_verbose:
By default \fIstate_verbose\fP is set to \fITrue\fP, setting this to \fIFalse\fP will
instruct the highstate outputter to omit displaying anything in green, this
means that nothing with a result of True and no changes will not be printed
.TP
.B state_output:
The highstate outputter has three output modes, \fIfull\fP, \fIterse\fP, and
\fImixed\fP. The default is set to full, which will display many lines of
detailed information for each executed chunk. If the \fIstate_output\fP option
is set to \fIterse\fP then the output is greatly simplified and shown in only
one line.  If \fImixed\fP is used, then terse output will be used unless a
state failed, in which case full output will be used.
.UNINDENT
.INDENT 0.0
.TP
.B salt.output.highstate.output(data)
The HighState Outputter is only meant to
be used with the state.highstate function, or a function that returns
highstate return data.
.UNINDENT
.SS salt.output.json_out
.sp
The JSON output module converts the return data into JSON.
.INDENT 0.0
.TP
.B salt.output.json_out.output(data)
Print the output data in JSON
.UNINDENT
.SS salt.output.key
.sp
Salt Key makes use of the outputter system to format information sent to the
\fBsalt\-key\fP command. This outputter is geared towards ingesting very specific
data and should only be used with the salt\-key command.
.INDENT 0.0
.TP
.B salt.output.key.output(data)
Read in the dict structure generated by the salt key API methods and
print the structure.
.UNINDENT
.SS salt.output.nested
.sp
Recursively display nested data, this is the default outputter.
.INDENT 0.0
.TP
.B class salt.output.nested.NestDisplay
Manage the nested display contents
.INDENT 7.0
.TP
.B display(ret, indent, prefix, out)
Recursively iterate down through data structures to determine output
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.output.nested.output(ret)
Display ret data
.UNINDENT
.SS salt.output.no_out
.sp
Display no output.
.INDENT 0.0
.TP
.B salt.output.no_out.output(ret)
Don\(aqt display data. Used when you only are interested in the
return.
.UNINDENT
.SS salt.output.no_return
.sp
Display output for minions that did not return
.INDENT 0.0
.TP
.B class salt.output.no_return.NestDisplay
Create generator for nested output
.INDENT 7.0
.TP
.B display(ret, indent, prefix, out)
Recursively iterate down through data structures to determine output
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B salt.output.no_return.output(ret)
Display ret data
.UNINDENT
.SS salt.output.overstatestage
.sp
Display clean output of an overstate stage
.INDENT 0.0
.TP
.B salt.output.overstatestage.output(data)
Format the data for printing stage information from the overstate system
.UNINDENT
.SS salt.output.pprint_out
.sp
The python pretty print system was the default outputter. This outputter
simply passed the data passed into it through the pprint module.
.INDENT 0.0
.TP
.B salt.output.pprint_out.output(data)
Print out via pretty print
.UNINDENT
.SS salt.output.raw
.sp
The raw outputter outputs the data via the python print function and is shown
in a raw state. This was the original outputter used by Salt before the
outputter system was developed.
.INDENT 0.0
.TP
.B salt.output.raw.output(data)
Rather basic....
.UNINDENT
.SS salt.output.txt
.sp
The txt outputter has been developed to make the output from shell
commands on minions appear as they do when the command is executed
on the minion.
.INDENT 0.0
.TP
.B salt.output.txt.output(data)
Output the data in lines, very nice for running commands
.UNINDENT
.SS salt.output.virt_query
.sp
virt.query outputter
.INDENT 0.0
.TP
.B salt.output.virt_query.output(data)
Display output for the salt\-run virt.query function
.UNINDENT
.SS salt.output.yaml_out
.sp
Output data in YAML, this outputter defaults to printing in YAML block mode
for better readability.
.INDENT 0.0
.TP
.B salt.output.yaml_out.output(data)
Print out YAML using the block mode
.UNINDENT
.SH SALT CLIENT API INTERFACES
.INDENT 0.0
.TP
.B class salt.client.LocalClient(c_path=\(aq/etc/salt/master\(aq, mopts=None)
Connect to the salt master via the local server and via root
.INDENT 7.0
.TP
.B cmd(tgt, fun, arg=(), timeout=None, expr_form=\(aqglob\(aq, ret=\(aq\(aq, kwarg=None, **kwargs)
Execute a salt command and return.
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class salt.runner.RunnerClient(opts)
A client for accessing runners
.INDENT 7.0
.TP
.B low(fun, low)
Pass in the runner function name and the low data structure
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B class salt.wheel.Wheel(opts)
Manage calls to the salt wheel system
.INDENT 7.0
.TP
.B master_call(fun, **kwargs)
Send a function call to a wheel module through the master network interface
.UNINDENT
.UNINDENT
.SH PEER COMMUNICATION
.sp
Salt 0.9.0 introduced the capability for Salt minions to publish commands. The
intent of this feature is not for Salt minions to act as independent brokers
one with another, but to allow Salt minions to pass commands to each other.
.sp
In Salt 0.10.0 the ability to execute runners from the master was added. This
allows for the master to return collective data from runners back to the
minions via the peer interface.
.sp
The peer interface is configured through two options in the master
configuration file. For minions to send commands from the master the \fBpeer\fP
configuration is used. To allow for minions to execute runners from the master
the \fBpeer_run\fP configuration is used.
.sp
Since this presents a viable security risk by allowing minions access to the
master publisher the capability is turned off by default. The minions can be
allowed access to the master publisher on a per minion basis based on regular
expressions. Minions with specific ids can be allowed access to certain Salt
modules and functions.
.SS Peer Configuration
.sp
The configuration is done under the \fBpeer\fP setting in the Salt master
configuration file, here are a number of configuration possibilities.
.sp
The simplest approach is to enable all communication for all minions, this is
only recommended for very secure environments.
.sp
.nf
.ft C
peer:
  .*:
    \- .*
.ft P
.fi
.sp
This configuration will allow minions with IDs ending in example.com access
to the test, ps, and pkg module functions.
.sp
.nf
.ft C
peer:
  .*example.com:
    \- test.*
    \- ps.*
    \- pkg.*
.ft P
.fi
.sp
The configuration logic is simple, a regular expression is passed for matching
minion ids, and then a list of expressions matching minion functions is
associated with the named minion. For instance, this configuration will also
allow minions ending with foo.org access to the publisher.
.sp
.nf
.ft C
peer:
  .*example.com:
    \- test.*
    \- ps.*
    \- pkg.*
  .*foo.org:
    \- test.*
    \- ps.*
    \- pkg.*
.ft P
.fi
.SS Peer Runner Communication
.sp
Configuration to allow minions to execute runners from the master is done via
the \fBpeer_run\fP option on the master. The \fBpeer_run\fP configuration follows
the same logic as the \fBpeer\fP option. The only difference is that access is
granted to runner modules.
.sp
To open up access to all minions to all runners:
.sp
.nf
.ft C
peer_run:
  .*:
    \- .*
.ft P
.fi
.sp
This configuration will allow minions with IDs ending in example.com access
to the manage and jobs runner functions.
.sp
.nf
.ft C
peer_run:
  .*example.com:
    \- manage.*
    \- jobs.*
.ft P
.fi
.SS Using Peer Communication
.sp
The publish module was created to manage peer communication. The publish module
comes with a number of functions to execute peer communication in different
ways. Currently there are three functions in the publish module. These examples
will show how to test the peer system via the salt\-call command.
.sp
To execute test.ping on all minions:
.sp
.nf
.ft C
# salt\-call publish.publish \e* test.ping
.ft P
.fi
.sp
To execute the manage.up runner:
.sp
.nf
.ft C
# salt\-call publish.runner manage.up
.ft P
.fi
.SH CLIENT ACL SYSTEM
.sp
The salt client ACL system is a means to allow system users other than root to
have access to execute select salt commands on minions from the master.
.sp
The client ACL system is configured in the master configuration file via the
\fBclient_acl\fP configuration option. Under the \fBclient_acl\fP configuration
option the users open to send commands are specified and then a list of regular
expressions which specify the minion functions which will be made available to
specified user. This configuration is much like the \fBpeer\fP configuration:
.sp
.nf
.ft C
# Allow thatch to execute anything and allow fred to use ping and pkg
client_acl:
  thatch:
    \- .*
  fred:
    \- ping.*
    \- pkg.*
.ft P
.fi
.SS Permission Issues
.sp
Directories required for \fBclient_acl\fP must be modified to be readable by the
users specified:
.sp
.nf
.ft C
chmod 755 /var/cache/salt /var/cache/salt/jobs /var/run/salt
.ft P
.fi
.sp
If you are upgrading from earlier versions of salt you must also remove any
existing user keys and re\-start the Salt master:
.sp
.nf
.ft C
rm /var/cache/salt/.*key
service salt\-master restart
.ft P
.fi
.SH SALT SYNDIC
.sp
The Salt Syndic interface is a powerful tool which allows for the construction
of Salt command topologies. A basic Salt setup has a Salt Master commanding a
group of Salt Minions. The Syndic interface is a special passthrough
minion, it is run on a master and connects to another master, then the master
that the Syndic minion is listening to can control the minions attached to
the master running the syndic.
.sp
The intent for supporting many layouts is not presented with the intent of
supposing the use of any single topology, but to allow a more flexible method
of controlling many systems.
.SS Configuring the Syndic
.sp
Since the Syndic only needs to be attached to a higher level master the
configuration is very simple. On a master that is running a syndic to connect
to a higher level master the syndic_master option needs to be set in the
master config file. The syndic_master option contains the hostname or IP
address of the master server that can control the master that the syndic is
running on.
.sp
The master that the syndic connects to sees the syndic as an ordinary minion,
and treats it as such. the higher level master will need to accept the syndic\(aqs
minion key like any other minion. This master will also need to set the
order_masters value in the configuration to True. The order_masters option in
the config on the higher level master is very important, to control a syndic
extra information needs to be sent with the publications, the order_masters
option makes sure that the extra data is sent out.
.SS Running the Syndic
.sp
The Syndic is a separate daemon that needs to be started on the master that is
controlled by a higher master. Starting the Syndic daemon is the same as
starting the other Salt daemons.
.sp
.nf
.ft C
# salt\-syndic
.ft P
.fi
.SH PYTHON CLIENT API
.sp
Salt is written to be completely API centric, Salt minions and master can be
built directly into third party applications as a communication layer. The Salt
client API is very straightforward.
.sp
A number of client command methods are available depending on the exact
behavior desired.
.SS Using the LocalClient API
.sp
Sending information through the client is simple:
.sp
.nf
.ft C
# Import the Salt client library
import salt.client
# create a local client object
client = salt.client.LocalClient()
# make calls with the cmd method
ret = client.cmd(\(aq*\(aq, \(aqcmd.run\(aq, [\(aqls \-l\(aq])
.ft P
.fi
.sp
The LocalClient object only works running as root on the salt\-master, it is the
same interface used by the \fBsalt\fP command line tool.
.INDENT 0.0
.TP
.B LocalClient.cmd(tgt, fun, arg=[], timeout=5, expr_form=\(aqglob\(aq, ret=\(aq\(aq)
The cmd method will execute and wait for the timeout period for all minions
to reply, then it will return all minion data at once.
.UNINDENT
.INDENT 0.0
.TP
.B tgt
The tgt option is the target specification, by default a target is passed
in as a bash shell glob. The expr_form option allows the tgt to be passed
as either a PCRE regular expression or as a Python list.
.UNINDENT
.INDENT 0.0
.TP
.B fun
The name of the function to call on the specified minions. The
documentation for these functions can be seen by running on the
salt\-master: salt \(aq*\(aq sys.doc
.UNINDENT
.INDENT 0.0
.TP
.B arg
The optional arg parameter is used to pass a list of options on to the
remote function
.UNINDENT
.INDENT 0.0
.TP
.B timeout
The number of seconds to wait after the last minion returns but before all
minions return.
.UNINDENT
.INDENT 0.0
.TP
.B expr_form
The type of tgt that is passed in, the allowed values are:
.INDENT 7.0
.IP \(bu 2
\(aqglob\(aq \- Bash glob completion \- Default
.IP \(bu 2
\(aqpcre\(aq \- Perl style regular expression
.IP \(bu 2
\(aqlist\(aq \- Python list of hosts
.IP \(bu 2
\(aqgrain\(aq \- Match based on a grain comparison
.IP \(bu 2
\(aqgrain_pcre\(aq \- Grain comparison with a regex
.IP \(bu 2
\(aqpillar\(aq \- Pillar data comparison
.IP \(bu 2
\(aqnodegroup\(aq \- Match on nodegroup
.IP \(bu 2
\(aqrange\(aq \- Use a Range server for matching
.IP \(bu 2
\(aqcompound\(aq \- Pass a compound match string
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ret
Specify the returner to use. The value passed can be single returner, or
a comma delimited list of returners to call in order on the minions
.UNINDENT
.INDENT 0.0
.TP
.B LocalClient.cmd_cli(tgt, fun, arg=[], timeout=5, verbose=False, expr_form=\(aqglob\(aq, ret=\(aq\(aq)
The cmd_cli method is used by the salt command, it is a generator. This
method returns minion returns as the come back and attempts to block
until all minions return.
.UNINDENT
.INDENT 0.0
.TP
.B tgt
The tgt option is the target specification, by default a target is passed
in as a bash shell glob. The expr_form option allows the tgt to be passed
as either a pcre regular expression or as a Python list.
.UNINDENT
.INDENT 0.0
.TP
.B fun
The name of the function to call on the specified minions. The
documentation for these functions can be seen by running on the
salt\-master: salt \(aq*\(aq sys.doc
.UNINDENT
.INDENT 0.0
.TP
.B arg
The optional arg parameter is used to pass a list of options on to the
remote function
.UNINDENT
.INDENT 0.0
.TP
.B timeout
The number of seconds to wait after the last minion returns but before all
minions return.
.UNINDENT
.INDENT 0.0
.TP
.B expr_form
The type of tgt that is passed in, the allowed values are:
.INDENT 7.0
.IP \(bu 2
\(aqglob\(aq \- Bash glob completion \- Default
.IP \(bu 2
\(aqpcre\(aq \- Perl style regular expression
.IP \(bu 2
\(aqlist\(aq \- Python list of hosts
.IP \(bu 2
\(aqgrain\(aq \- Match based on a grain comparison
.IP \(bu 2
\(aqgrain_pcre\(aq \- Grain comparison with a regex
.IP \(bu 2
\(aqpillar\(aq \- Pillar data comparison
.IP \(bu 2
\(aqnodegroup\(aq \- Match on nodegroup
.IP \(bu 2
\(aqrange\(aq \- Use a Range server for matching
.IP \(bu 2
\(aqcompound\(aq \- Pass a compound match string
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ret
Specify the returner to use. The value passed can be single returner, or
a comma delimited list of returners to call in order on the minions
.UNINDENT
.INDENT 0.0
.TP
.B verbose
Print extra information about the running command to the terminal
.UNINDENT
.INDENT 0.0
.TP
.B LocalClient.cmd_iter(tgt, fun, arg=[], timeout=5, expr_form=\(aqglob\(aq, ret=\(aq\(aq)
The cmd_iter method is a generator which yields the individual minion
returns as the come in.
.UNINDENT
.INDENT 0.0
.TP
.B tgt
The tgt option is the target specification, by default a target is passed
in as a bash shell glob. The expr_form option allows the tgt to be passed
as either a pcre regular expression or as a Python list.
.UNINDENT
.INDENT 0.0
.TP
.B fun
The name of the function to call on the specified minions. The
documentation for these functions can be seen by running on the
salt\-master: salt \(aq*\(aq sys.doc
.UNINDENT
.INDENT 0.0
.TP
.B arg
The optional arg parameter is used to pass a list of options on to the
remote function
.UNINDENT
.INDENT 0.0
.TP
.B timeout
The number of seconds to wait after the last minion returns but before all
minions return.
.UNINDENT
.INDENT 0.0
.TP
.B expr_form
The type of tgt that is passed in, the allowed values are:
.INDENT 7.0
.IP \(bu 2
\(aqglob\(aq \- Bash glob completion \- Default
.IP \(bu 2
\(aqpcre\(aq \- Perl style regular expression
.IP \(bu 2
\(aqlist\(aq \- Python list of hosts
.IP \(bu 2
\(aqgrain\(aq \- Match based on a grain comparison
.IP \(bu 2
\(aqgrain_pcre\(aq \- Grain comparison with a regex
.IP \(bu 2
\(aqpillar\(aq \- Pillar data comparison
.IP \(bu 2
\(aqnodegroup\(aq \- Match on nodegroup
.IP \(bu 2
\(aqrange\(aq \- Use a Range server for matching
.IP \(bu 2
\(aqcompound\(aq \- Pass a compound match string
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ret
Specify the returner to use. The value passed can be single returner, or
a comma delimited list of returners to call in order on the minions
.UNINDENT
.INDENT 0.0
.TP
.B LocalClient.cmd_iter_no_block(tgt, fun, arg=[], timeout=5, expr_form=\(aqglob\(aq, ret=\(aq\(aq)
The cmd_iter method will block waiting for individual minions to return,
the cmd_iter_no_block method will return None until the next minion
returns. This allows for actions to be injected in between minion returns
.UNINDENT
.INDENT 0.0
.TP
.B tgt
The tgt option is the target specification, by default a target is passed
in as a bash shell glob. The expr_form option allows the tgt to be passed
as either a pcre regular expression or as a Python list.
.UNINDENT
.INDENT 0.0
.TP
.B fun
The name of the function to call on the specified minions. The
documentation for these functions can be seen by running on the
salt\-master: salt \(aq*\(aq sys.doc
.UNINDENT
.INDENT 0.0
.TP
.B arg
The optional arg parameter is used to pass a list of options on to the
remote function
.UNINDENT
.INDENT 0.0
.TP
.B timeout
The number of seconds to wait after the last minion returns but before all
minions return.
.UNINDENT
.INDENT 0.0
.TP
.B expr_form
The type of tgt that is passed in, the allowed values are:
.INDENT 7.0
.IP \(bu 2
\(aqglob\(aq \- Bash glob completion \- Default
.IP \(bu 2
\(aqpcre\(aq \- Perl style regular expression
.IP \(bu 2
\(aqlist\(aq \- Python list of hosts
.IP \(bu 2
\(aqgrain\(aq \- Match based on a grain comparison
.IP \(bu 2
\(aqgrain_pcre\(aq \- Grain comparison with a regex
.IP \(bu 2
\(aqpillar\(aq \- Pillar data comparison
.IP \(bu 2
\(aqnodegroup\(aq \- Match on nodegroup
.IP \(bu 2
\(aqrange\(aq \- Use a Range server for matching
.IP \(bu 2
\(aqcompound\(aq \- Pass a compound match string
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B ret
Specify the returner to use. The value passed can be single returner, or
a comma delimited list of returners to call in order on the minions
.UNINDENT
.SS Compound Command Execution With the Salt API
.sp
The Salt client API can also send what is called a compound command. Often
a collection of commands need to be executed on the targeted minions, rather
than send the commands one after another, they can be sent in a single publish
containing a series of commands. This can dramatically lower overhead and
speed up the application communicating with Salt.
.sp
When commands are executed with compound execution the minion functions called
are executed in serial on the minion and the return value is sent back in a
different fashion. The return value is a dict, with the function names as keys
to the function returns as values.
.sp
Using the compound command execution system via the API requires that the fun
value and the arg value are lists matching by index. This ensures that the
order of the executions can be controlled. Any function that has no arguments
MUST have an empty array in the corresponding arg index.
.sp
All client command methods can execute compound commands.
.sp
.nf
.ft C
# Import the Salt client library
import salt.client
# create a local client object
client = salt.client.LocalClient()
# make compound execution calls with the cmd method
ret = client.cmd(\(aq*\(aq, [\(aqcmd.run\(aq, \(aqtest.ping\(aq, \(aqtest.echo\(aq], [[\(aqls \-l\(aq], [], [\(aqfoo\(aq]])
.ft P
.fi
.sp
This will execute \fBcmd.run ls \-l\fP then \fBtest.ping\fP and finally
\fBtest.echo foo\fP.
The return data from the minion will look like this:
.sp
.nf
.ft C
{\(aqcmd.run\(aq: \(aq<output from ls \-l>\(aq,
 \(aqtest.ping\(aq: True,
 \(aqtest.echo\(aq: \(aqfoo\(aq}
.ft P
.fi
.SS Salt Caller API
.sp
The Salt minion caller api can be used to simplify the execution and use of
minion elements. The caller api is useful for accessing the Salt api, direct
access to the state functions, using the matcher interface on a single minion,
and as an api for the peer interface. Using the api is fairly straightforward:
.sp
.nf
.ft C
# Import the Salt client library
import salt.client
# Create the caller object
caller = salt.client.Caller()
# call a function
caller.function(\(aqtest.ping\(aq)
# Call objects directly:
caller.sminion.functions[\(aqcmd.run\(aq](\(aqls \-l\(aq)
.ft P
.fi
.SH FILE SERVER BACKENDS
.sp
Salt version 0.12.0 introduced the ability for the Salt Master to integrate
different file server backends. File server backends allows the Salt file
server to act as a transparent bridge to external resources. The primary
example of this is the git backend which allows for all of the Salt formulas
and files to be maintained in a remote git repository.
.sp
The fileserver backend system can accept multiple backends as well. This makes
it possible to have the environments listed in the file_roots configuration
available in addition to other backends, or the ability to mix multiple
backends.
.sp
This feature is managed by the \fIfileserver_backend\fP option in the master
config. The desired backend systems are listed in order of search priority:
.sp
.nf
.ft C
fileserver_backend:
  \- roots
  \- git
.ft P
.fi
.sp
If this configuration the environments and files defined in the \fIfile_roots\fP
configuration will be searched first, if the referenced environment and file
is not found then the git backend will be searched.
.SS Environments
.sp
The concept of environments is followed in all backend systems. The
environments in the classic \fIroots\fP backend are defined in the \fIfile_roots\fP
option. Environments map differently based on the backend, for instance the
git backend translated branches and tags in git to environments. This makes
it easy to define environments in git by just setting a tag or forking a
branch.
.SH DYNAMIC MODULE DISTRIBUTION
.sp
New in version 0.9.5.
.sp
Salt Python modules can be distributed automatically via the Salt file server.
Under the root of any environment defined via the \fBfile_roots\fP
option on the master server directories corresponding to the type of module can
be used.
.INDENT 0.0
.TP
.B Module sync
Automatically transfer and load modules, grains, renderers, returners,
states, etc from the master to the minions.
.UNINDENT
.sp
The directories are prepended with an underscore:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
\fB_modules\fP
.IP 2. 3
\fB_grains\fP
.IP 3. 3
\fB_renderers\fP
.IP 4. 3
\fB_returners\fP
.IP 5. 3
\fB_states\fP
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The contents of these directories need to be synced over to the minions after
Python modules have been created in them. There are a number of ways to sync
the modules.
.SS Sync Via States
.sp
The minion configuration contains an option \fBautoload_dynamic_modules\fP
which defaults to True. This option makes the state system refresh all
dynamic modules when states are run. To disable this behavior set
\fBautoload_dynamic_modules\fP to False in the minion config.
.sp
When dynamic modules are autoloaded via states, modules only pertinent to
the environments matched in the master\(aqs top file are downloaded.
.sp
This is important to remember, because modules can be manually loaded from
any specific environment that environment specific modules will be loaded
when a state run is executed.
.SS Sync Via the saltutil Module
.sp
The saltutil module has a number of functions that can be used to sync all
or specific dynamic modules. The saltutil module function \fBsaltutil.sync_all\fP
will sync all module types over to a minion. For more information see:
\fBsalt.modules.saltutil\fP
.SH FILE SERVER CONFIGURATION
.sp
The Salt file server is a high performance file server written in ZeroMQ. It
manages large files quickly and with little overhead, and has been optimized
to handle small files in an extremely efficient manner.
.sp
The Salt file server is an environment aware file server. This means that
files can be allocated within many root directories and accessed by
specifying both the file path and the environment to search. The
individual environments can span across multiple directory roots
to create overlays and to allow for files to be organized in many flexible
ways.
.SS Environments
.sp
The Salt file server defaults to the mandatory \fBbase\fP environment. This
environment \fBMUST\fP be defined and is used to download files when no
environment is specified.
.sp
Environments allow for files and sls data to be logically separated, but
environments are not isolated from each other. This allows for logical
isolation of environments by the engineer using Salt, but also allows
for information to be used in multiple environments.
.SS Directory Overlay
.sp
The \fBenvironment\fP setting is a list of directories to publish files from.
These directories are searched in order to find the specified file and the
first file found is returned.
.sp
This means that directory data is prioritized based on the order in which they
are listed. In the case of this \fBfile_roots\fP configuration:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt/base
    \- /srv/salt/failover
.ft P
.fi
.sp
If a file\(aqs URI is \fBsalt://httpd/httpd.conf\fP, it will first search for the
file at \fB/srv/salt/base/httpd/httpd.conf\fP. If the file is found there it
will be returned. If the file is not found there, then
\fB/srv/salt/failover/httpd/httpd.conf\fP will be used for the source.
.sp
This allows for directories to be overlaid and prioritized based on the order
they are defined in the configuration.
.SS Local File Server
.sp
New in version 0.9.8.
.sp
The file server can be rerouted to run from the minion. This is primarily to
enable running Salt states without a Salt master. To use the local file server
interface, copy the file server data to the minion and set the file_roots
option on the minion to point to the directories copied from the master.
Once the minion \fBfile_roots\fP option has been set, change the \fBfile_client\fP
option to local to make sure that the local file server interface is used.
.SH SALT FILE SERVER
.sp
Salt comes with a simple file server suitable for distributing files to the
Salt minions. The file server is a stateless ZeroMQ server that is built into
the Salt master.
.sp
The main intent of the Salt file server is to present files for use in the
Salt state system. With this said, the Salt file server can be used for any
general file transfer from the master to the minions.
.SS The cp Module
.sp
The cp module is the home of minion side file server operations. The cp module
is used by the Salt state system, salt\-cp and can be used to distribute files
presented by the Salt file server.
.SS Environments
.sp
Since the file server is made to work with the Salt state system, it supports
environments. The environments are defined in the master config file and
when referencing an environment the file specified will be based on the root
directory of the environment.
.SS get_file
.sp
The cp.get_file function can be used on the minion to download a file from
the master, the syntax looks like this:
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_file salt://vimrc /etc/vimrc
.ft P
.fi
.sp
This will instruct all Salt minions to download the vimrc file and copy it
to /etc/vimrc
.sp
Template rendering can be enabled on both the source and destination file names
like so:
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_file "salt://{{grains.os}}/vimrc" /etc/vimrc template=jinja
.ft P
.fi
.sp
This example would instruct all Salt minions to download the vimrc from a
directory with the same name as their OS grain and copy it to /etc/vimrc
.sp
For larger files, the cp.get_file module also supports gzip compression.
Because gzip is CPU\-intensive, this should only be used in
scenarios where the compression ratio is very high (e.g. pretty\-printed JSON
or YAML files).
.sp
Use the \fIgzip\fP named argument to enable it.  Valid values are 1..9,
where 1 is the lightest compression and 9 the heaviest.  1 uses the least CPU
on the master (and minion), 9 uses the most.
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_file salt://vimrc /etc/vimrc gzip=5
.ft P
.fi
.sp
Finally, note that by default cp.get_file does \fInot\fP create new destination
directories if they do not exist.  To change this, use the \fImakedirs\fP argument:
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_file salt://vimrc /etc/vim/vimrc makedirs=True
.ft P
.fi
.sp
In this example, /etc/vim/ would be created if it didn\(aqt already exist.
.SS get_dir
.sp
The cp.get_dir function can be used on the minion to download an entire
directory from the master.  The syntax is very similar to get_file:
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_dir salt://etc/apache2 /etc
.ft P
.fi
.sp
cp.get_dir supports \fItemplate\fP rendering and \fIgzip\fP compression arguments just
like get_file:
.sp
.nf
.ft C
# salt \(aq*\(aq cp.get_dir salt://etc/{{pillar.webserver}} /etc gzip=5 template=jinja
.ft P
.fi
.SS File Server Client API
.sp
A client API is available which allows for modules and applications to be
written which make use of the Salt file server.
.sp
The file server uses the same authentication and encryption used by the rest
of the Salt system for network communication.
.SS FileClient Class
.sp
The FileClient class is used to set up the communication from the minion to
the master. When creating a FileClient object the minion configuration needs
to be passed in. When using the FileClient from within a minion module the
built in \fB__opts__\fP data can be passed:
.sp
.nf
.ft C
import salt.minion

def get_file(path, dest, env=\(aqbase\(aq):
    \(aq\(aq\(aq
    Used to get a single file from the Salt master

    CLI Example:
    salt \(aq*\(aq cp.get_file salt://vimrc /etc/vimrc
    \(aq\(aq\(aq
    # Create the FileClient object
    client = salt.minion.FileClient(__opts__)
    # Call get_file
    return client.get_file(path, dest, False, env)
.ft P
.fi
.sp
Using the FileClient class outside of a minion module where the \fB__opts__\fP
data is not available, it needs to be generated:
.sp
.nf
.ft C
import salt.minion
import salt.config

def get_file(path, dest, env=\(aqbase\(aq):
    \(aq\(aq\(aq
    Used to get a single file from the Salt master
    \(aq\(aq\(aq
    # Get the configuration data
    opts = salt.config.minion_config(\(aq/etc/salt/minion\(aq)
    # Create the FileClient object
    client = salt.minion.FileClient(opts)
    # Call get_file
    return client.get_file(path, dest, False, env)
.ft P
.fi
.SH CONFIGURATION FILE EXAMPLES
.INDENT 0.0
.IP \(bu 2
\fI\%Example master configuration file\fP
.IP \(bu 2
\fI\%Example minion configuration file\fP
.UNINDENT
.SS Example master configuration file
.sp
.nf
.ft C
##### Primary configuration settings #####
##########################################
# This configuration file is used to manage the behavior of the Salt Master
# Values that are commented out but have no space after the comment are
# defaults that need not be set in the config. If there is a space after the
# comment that the value is presented as an example and is not the default.

# Per default, the master will automatically include all config files
# from master.d/*.conf (master.d is a directory in the same directory
# as the main master config file)
#default_include: master.d/*.conf

# The address of the interface to bind to
#interface: 0.0.0.0

# Whether the master should listen for IPv6 connections. If this is set to True,
# the interface option must be adjusted too (for example: "interface: \(aq::\(aq")
#ipv6: False

# The tcp port used by the publisher
#publish_port: 4505

# The user to run the salt\-master as. Salt will update all permissions to
# allow the specified user to run the master. If the modified files cause
# conflicts set verify_env to False.
#user: root

# Max open files
# Each minion connecting to the master uses AT LEAST one file descriptor, the
# master subscription connection. If enough minions connect you might start
# seeing on the console(and then salt\-master crashes):
#   Too many open files (tcp_listener.cpp:335)
#   Aborted (core dumped)
#
# By default this value will be the one of \(gaulimit \-Hn\(ga, ie, the hard limit for
# max open files.
#
# If you wish to set a different value than the default one, uncomment and
# configure this setting. Remember that this value CANNOT be higher than the
# hard limit. Raising the hard limit depends on your OS and/or distribution,
# a good way to find the limit is to search the internet for(for example):
#   raise max open files hard limit debian
#
#max_open_files: 100000

# The number of worker threads to start, these threads are used to manage
# return calls made from minions to the master, if the master seems to be
# running slowly, increase the number of threads
#worker_threads: 5

# The port used by the communication interface. The ret (return) port is the
# interface used for the file server, authentication, job returnes, etc.
#ret_port: 4506

# Specify the location of the daemon process ID file
#pidfile: /var/run/salt\-master.pid

# The root directory prepended to these options: pki_dir, cachedir,
# sock_dir, log_file, autosign_file, extension_modules, key_logfile, pidfile.
#root_dir: /

# Directory used to store public key data
#pki_dir: /etc/salt/pki/master

# Directory to store job and cache data
#cachedir: /var/cache/salt/master

# Verify and set permissions on configuration directories at startup
#verify_env: True

# Set the number of hours to keep old job information in the job cache
#keep_jobs: 24

# Set the default timeout for the salt command and api, the default is 5
# seconds
#timeout: 5

# The loop_interval option controls the seconds for the master\(aqs maintinance
# process check cycle. This process updates file server backends, cleans the
# job cache and executes the scheduler.
#loop_interval: 60

# Set the default outputter used by the salt command. The default is "nested"
#output: nested

# By default output is colored, to disable colored output set the color value
# to False
#color: True

# Set the directory used to hold unix sockets
#sock_dir: /var/run/salt/master

# The master maintains a job cache, while this is a great addition it can be
# a burden on the master for larger deployments (over 5000 minions).
# Disabling the job cache will make previously executed jobs unavailable to
# the jobs system and is not generally recommended.
#
#job_cache: True

# Cache minion grains and pillar data in the cachedir.
#minion_data_cache: True

# The master can include configuration from other files. To enable this,
# pass a list of paths to this option. The paths can be either relative or
# absolute; if relative, they are considered to be relative to the directory
# the main master configuration file lives in (this file). Paths can make use
# of shell\-style globbing. If no files are matched by a path passed to this
# option then the master will log a warning message.
#
#
# Include a config file from some other path:
# include: /etc/salt/extra_config
#
# Include config from several files and directories:
# include:
#   \- /etc/salt/extra_config


#####        Security settings       #####
##########################################
# Enable "open mode", this mode still maintains encryption, but turns off
# authentication, this is only intended for highly secure environments or for
# the situation where your keys end up in a bad state. If you run in open mode
# you do so at your own risk!
#open_mode: False

# Enable auto_accept, this setting will automatically accept all incoming
# public keys from the minions. Note that this is insecure.
#auto_accept: False

# If the autosign_file is specified only incoming keys specified in
# the autosign_file will be automatically accepted. This is insecure.
# Regular expressions as well as globing lines are supported.
#autosign_file: /etc/salt/autosign.conf

# Enable permissive access to the salt keys.  This allows you to run the
# master or minion as root, but have a non\-root group be given access to
# your pki_dir.  To make the access explicit, root must belong to the group
# you\(aqve given access to.  This is potentially quite insecure.
# If an autosign_file is specified, enabling permissive_pki_access will allow group access
# to that specific file.
#permissive_pki_access: False

# Allow users on the master access to execute specific commands on minions.
# This setting should be treated with care since it opens up execution
# capabilities to non root users. By default this capability is completely
# disabled.
#
# client_acl:
#   larry:
#     \- test.ping
#     \- network.*
#

# Blacklist any of the following users or modules
#
# This example would blacklist all non sudo users, including root from
# running any commands. It would also blacklist any use of the "cmd"
# module.
# This is completely disabled by default.
#
# client_acl_blacklist:
#   users:
#     \- root
#     \- \(aq^(?!sudo_).*$\(aq   #  all non sudo users
#   modules:
#     \- cmd

# The external auth system uses the Salt auth modules to authenticate and
# validate users to access areas of the Salt system
#
# external_auth:
#   pam:
#     fred:
#       \- test.*
#
# Time (in seconds) for a newly generated token to live. Default: 12 hours
# token_expire: 43200


#####    Master Module Management    #####
##########################################
# Manage how master side modules are loaded

# Add any additional locations to look for master runners
#runner_dirs: []

# Enable Cython for master side modules
#cython_enable: False


#####      State System settings     #####
##########################################
# The state system uses a "top" file to tell the minions what environment to
# use and what modules to use. The state_top file is defined relative to the
# root of the base environment as defined in "File Server settings" below.
#state_top: top.sls

# The master_tops option replaces the external_nodes option by creating
# a plugable system for the generation of external top data. The external_nodes
# option is deprecated by the master_tops option.
# To gain the capabilities of the classic external_nodes system, use the
# following configuration:
# master_tops:
#   ext_nodes: <Shell command which returns yaml>
#
#master_tops: {}

# The external_nodes option allows Salt to gather data that would normally be
# placed in a top file. The external_nodes option is the executable that will
# return the ENC data. Remember that Salt will look for external nodes AND top
# files and combine the results if both are enabled!
#external_nodes: None

# The renderer to use on the minions to render the state data
#renderer: yaml_jinja

# The failhard option tells the minions to stop immediately after the first
# failure detected in the state execution, defaults to False
#failhard: False

# The state_verbose and state_output settings can be used to change the way
# state system data is printed to the display. By default all data is printed.
# The state_verbose setting can be set to True or False, when set to False
# all data that has a result of True and no changes will be suppressed.
#state_verbose: True

# The state_output setting changes if the output is the full multi line
# output for each changed state if set to \(aqfull\(aq, but if set to \(aqterse\(aq
# the output will be shortened to a single line.  If set to \(aqmixed\(aq, the output
# will be terse unless a state failed, in which case that output will be full.
#state_output: full


#####      File Server settings      #####
##########################################
# Salt runs a lightweight file server written in zeromq to deliver files to
# minions. This file server is built into the master daemon and does not
# require a dedicated port.

# The file server works on environments passed to the master, each environment
# can have multiple root directories, the subdirectories in the multiple file
# roots cannot match, otherwise the downloaded files will not be able to be
# reliably ensured. A base environment is required to house the top file.
# Example:
# file_roots:
#   base:
#     \- /srv/salt/
#   dev:
#     \- /srv/salt/dev/services
#     \- /srv/salt/dev/states
#   prod:
#     \- /srv/salt/prod/services
#     \- /srv/salt/prod/states

#file_roots:
#  base:
#    \- /srv/salt

# The hash_type is the hash to use when discovering the hash of a file on
# the master server, the default is md5, but sha1, sha224, sha256, sha384
# and sha512 are also supported.
#hash_type: md5

# The buffer size in the file server can be adjusted here:
#file_buffer_size: 1048576

# A regular expression (or a list of expressions) that will be matched
# against the file path before syncing the modules and states to the minions.
# This includes files affected by the file.recurse state.
# For example, if you manage your custom modules and states in subversion
# and don\(aqt want all the \(aq.svn\(aq folders and content synced to your minions,
# you could set this to \(aq/\e.svn($|/)\(aq. By default nothing is ignored.
# file_ignore_regex:
#   \- \(aq/\e.svn($|/)\(aq
#   \- \(aq/\e.git($|/)\(aq

# A file glob (or list of file globs) that will be matched against the file
# path before syncing the modules and states to the minions. This is similar
# to file_ignore_regex above, but works on globs instead of regex. By default
# nothing is ignored.
# file_ignore_glob:
#   \- \(aq*.pyc\(aq
#   \- \(aq*/somefolder/*.bak\(aq

# File Server Backend
# Salt supports a modular fileserver backend system, this system allows
# the salt master to link directly to third party systems to gather and
# manage the files available to minions. Multiple backends can be
# configured and will be searched for the requested file in the order in which
# they are defined here. The default setting only enables the standard backend
# "roots" which uses the "file_roots" option.
#fileserver_backend:
#  \- roots
# To use multiple backends list them in the order they are searched:
# fileserver_backend:
#   \- git
#   \- roots

# Git fileserver backend configuration
# When using the git fileserver backend at least one git remote needs to be
# defined. The user running the salt master will need read access to the repo.
# gitfs_remotes:
#   \- git://github.com/saltstack/salt\-states.git
#   \- file:///var/git/saltmaster
# The repos will be searched in order to find the file requested by a client
# and the first repo to have the file will return it.
# When using the git backend branches and tags are translated into salt
# environments.
# Note:  file:// repos will be treated as a remote, so refs you want used must
# exist in that repo as *local* refs.


#####         Pillar settings        #####
##########################################
# Salt Pillars allow for the building of global data that can be made selectively
# available to different minions based on minion grain filtering. The Salt
# Pillar is laid out in the same fashion as the file server, with environments,
# a top file and sls files. However, pillar data does not need to be in the
# highstate format, and is generally just key/value pairs.

#pillar_roots:
#  base:
#    \- /srv/pillar

# ext_pillar:
#   \- hiera: /etc/hiera.yaml
#   \- cmd_yaml: cat /etc/salt/yaml

# The pillar_opts option adds the master configuration file data to a dict in
# the pillar called "master". This is used to set simple configurations in the
# master config file that can then be used on minions.
#pillar_opts: True


#####          Syndic settings       #####
##########################################
# The Salt syndic is used to pass commands through a master from a higher
# master. Using the syndic is simple, if this is a master that will have
# syndic servers(s) below it set the "order_masters" setting to True, if this
# is a master that will be running a syndic daemon for passthrough the
# "syndic_master" setting needs to be set to the location of the master server
# to receive commands from.

# Set the order_masters setting to True if this master will command lower
# masters\(aq syndic interfaces.
#order_masters: False

# If this master will be running a salt syndic daemon, syndic_master tells
# this master where to receive commands from.
#syndic_master: masterofmaster


#####      Peer Publish settings     #####
##########################################
# Salt minions can send commands to other minions, but only if the minion is
# allowed to. By default "Peer Publication" is disabled, and when enabled it
# is enabled for specific minions and specific commands. This allows secure
# compartmentalization of commands based on individual minions.

# The configuration uses regular expressions to match minions and then a list
# of regular expressions to match functions. The following will allow the
# minion authenticated as foo.example.com to execute functions from the test
# and pkg modules.
# peer:
#   foo.example.com:
#       \- test.*
#       \- pkg.*
#
# This will allow all minions to execute all commands:
# peer:
#   .*:
#       \- .*
# This is not recommended, since it would allow anyone who gets root on any
# single minion to instantly have root on all of the minions!

# Minions can also be allowed to execute runners from the salt master.
# Since executing a runner from the minion could be considered a security risk,
# it needs to be enabled. This setting functions just like the peer setting
# except that it opens up runners instead of module functions.
#
# All peer runner support is turned off by default and must be enabled before
# using. This will enable all peer runners for all minions:
#
# peer_run:
#   .*:
#     \- .*
#
# To enable just the manage.up runner for the minion foo.example.com:
#
# peer_run:
#   foo.example.com:
#     \- manage.up


#####         Logging settings       #####
##########################################
# The location of the master log file
# The master log can be sent to a regular file, local path name, or network
# location. Remote logging works best when configured to use rsyslogd(8) (e.g.:
# \(ga\(gafile:///dev/log\(ga\(ga), with rsyslogd(8) configured for network logging. The URI
# format is: <file|udp|tcp>://<host|socketpath>:<port\-if\-required>/<log\-facility>
#log_file: /var/log/salt/master
#log_file: file:///dev/log
#log_file: udp://loghost:10514

#log_file: /var/log/salt/master
#key_logfile: /var/log/salt/key

# The level of messages to send to the console.
# One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
#log_level: warning

# The level of messages to send to the log file.
# One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
#log_level_logfile: warning

# The date and time format used in log messages. Allowed date/time formating
# can be seen here: http://docs.python.org/library/time.html#time.strftime
#log_datefmt: \(aq%H:%M:%S\(aq
#log_datefmt_logfile: \(aq%Y\-%m\-%d %H:%M:%S\(aq

# The format of the console logging messages. Allowed formatting options can
# be seen here: http://docs.python.org/library/logging.html#logrecord\-attributes
#log_fmt_console: \(aq[%(levelname)\-8s] %(message)s\(aq
#log_fmt_logfile: \(aq%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\(aq

# This can be used to control logging levels more specificically.  This
# example sets the main salt library at the \(aqwarning\(aq level, but sets
# \(aqsalt.modules\(aq to log at the \(aqdebug\(aq level:
#   log_granular_levels:
#     \(aqsalt\(aq: \(aqwarning\(aq,
#     \(aqsalt.modules\(aq: \(aqdebug\(aq
#
#log_granular_levels: {}


#####         Node Groups           #####
##########################################
# Node groups allow for logical groupings of minion nodes.
# A group consists of a group name and a compound target.
#
# nodegroups:
#   group1: \(aqL@foo.domain.com,bar.domain.com,baz.domain.com and bl*.domain.com\(aq
#   group2: \(aqG@os:Debian and foo.domain.com\(aq


#####     Range Cluster settings     #####
##########################################
# The range server (and optional port) that serves your cluster information
# https://github.com/grierj/range/wiki/Introduction\-to\-Range\-with\-YAML\-files
#
# range_server: range:80


#####     Windows Software Repo settings #####
##############################################
# Location of the repo on the master
# win_repo: \(aq/srv/salt/win/repo\(aq

# Location of the master\(aqs repo cache file
# win_repo_mastercachefile: \(aq/srv/salt/win/repo/winrepo.p\(aq

# List of git repositories to include with the local repo
# win_gitrepos:
#   \- \(aqhttps://github.com/saltstack/salt\-winrepo.git\(aq

.ft P
.fi
.SS Example minion configuration file
.sp
.nf
.ft C
##### Primary configuration settings #####
##########################################

# Per default the minion will automatically include all config files
# from minion.d/*.conf (minion.d is a directory in the same directory
# as the main minion config file).
#default_include: minion.d/*.conf

# Set the location of the salt master server, if the master server cannot be
# resolved, then the minion will fail to start.
#master: salt

# Set whether the minion should connect to the master via IPv6
#ipv6: False

# Set the number of seconds to wait before attempting to resolve
# the master hostname if name resolution fails. Defaults to 30 seconds.
# Set to zero if the minion should shutdown and not retry.
# retry_dns: 30

# Set the port used by the master reply and authentication server
#master_port: 4506

# The user to run salt
#user: root

# Specify the location of the daemon process ID file
#pidfile: /var/run/salt\-minion.pid

# The root directory prepended to these options: pki_dir, cachedir, log_file,
# sock_dir, pidfile.
#root_dir: /

# The directory to store the pki information in
#pki_dir: /etc/salt/pki/minion

# Explicitly declare the id for this minion to use, if left commented the id
# will be the hostname as returned by the python call: socket.getfqdn()
# Since salt uses detached ids it is possible to run multiple minions on the
# same machine but with different ids, this can be useful for salt compute
# clusters.
#id:

# Append a domain to a hostname in the event that it does not exist.  This is
# useful for systems where socket.getfqdn() does not actually result in a
# FQDN (for instance, Solaris).
#append_domain:

# Custom static grains for this minion can be specified here and used in SLS
# files just like all other grains. This example sets 4 custom grains, with
# the \(aqroles\(aq grain having two values that can be matched against:
#grains:
#  roles:
#    \- webserver
#    \- memcache
#  deployment: datacenter4
#  cabinet: 13
#  cab_u: 14\-15

# Where cache data goes
#cachedir: /var/cache/salt/minion

# Verify and set permissions on configuration directories at startup
#verify_env: True

# The minion can locally cache the return data from jobs sent to it, this
# can be a good way to keep track of jobs the minion has executed
# (on the minion side). By default this feature is disabled, to enable
# set cache_jobs to True
#cache_jobs: False

# set the directory used to hold unix sockets
#sock_dir: /var/run/salt/minion

# Set the default outputter used by the salt\-call command. The default is
# "nested"
#output: nested
#
# By default output is colored, to disable colored output set the color value
# to False
#color: True

# Backup files that are replaced by file.managed and file.recurse under
# \(aqcachedir\(aq/file_backups relative to their original location and appended
# with a timestamp. The only valid setting is "minion". Disabled by default.
#
# Alternatively this can be specified for each file in state files:
#
# /etc/ssh/sshd_config:
#   file.managed:
#     \- source: salt://ssh/sshd_config
#       \- backup: minion
#
#backup_mode: minion

# When waiting for a master to accept the minion\(aqs public key, salt will
# continuously attempt to reconnect until successful. This is the time, in
# seconds, between those reconnection attempts.
#acceptance_wait_time: 10

# If this is set, the time between reconnection attempts will increase by 
# acceptance_wait_time seconds per iteration, up to this maximum. If this
# is not set, the time between reconnection attempts will stay constant.
# acceptance_wait_time_max: None

# The loop_interval sets how long in seconds the minion will wait between
# evaluating the scheduler and running cleanup tasks. This defaults to a
# sane 60 seconds, but if the minion scheduler needs to be evaluated more
# often lower this value
#loop_interval: 60

# When healing, a dns_check is run. This is to make sure that the originally
# resolved dns has not changed. If this is something that does not happen in
# your environment, set this value to False.
#dns_check: True

# Windows platforms lack posix IPC and must rely on slower TCP based inter\-
# process communications. Set ipc_mode to \(aqtcp\(aq on such systems
#ipc_mode: ipc
#
# Overwrite the default tcp ports used by the minion when in tcp mode
#tcp_pub_port: 4510
#tcp_pull_port: 4511

# The minion can include configuration from other files. To enable this,
# pass a list of paths to this option. The paths can be either relative or
# absolute; if relative, they are considered to be relative to the directory
# the main minion configuration file lives in (this file). Paths can make use
# of shell\-style globbing. If no files are matched by a path passed to this
# option then the minion will log a warning message.
#
#
# Include a config file from some other path:
# include: /etc/salt/extra_config
#
# Include config from several files and directories:
# include:
#  \- /etc/salt/extra_config
#  \- /etc/roles/webserver

#####   Minion module management     #####
##########################################
# Disable specific modules. This allows the admin to limit the level of
# access the master has to the minion
#disable_modules: [cmd,test]
#disable_returners: []
#
# Modules can be loaded from arbitrary paths. This enables the easy deployment
# of third party modules. Modules for returners and minions can be loaded.
# Specify a list of extra directories to search for minion modules and
# returners. These paths must be fully qualified!
#module_dirs: []
#returner_dirs: []
#states_dirs: []
#render_dirs: []
#
# A module provider can be statically overwritten or extended for the minion
# via the providers option, in this case the default module will be
# overwritten by the specified module. In this example the pkg module will
# be provided by the yumpkg5 module instead of the system default.
#
# providers:
#   pkg: yumpkg5
#
# Enable Cython modules searching and loading. (Default: False)
#cython_enable: False
#

#####    State Management Settings    #####
###########################################
# The state management system executes all of the state templates on the minion
# to enable more granular control of system state management. The type of
# template and serialization used for state management needs to be configured
# on the minion, the default renderer is yaml_jinja. This is a yaml file
# rendered from a jinja template, the available options are:
# yaml_jinja
# yaml_mako
# yaml_wempy
# json_jinja
# json_mako
# json_wempy
#
#renderer: yaml_jinja
#
# The failhard option tells the minions to stop immediately after the first
# failure detected in the state execution, defaults to False
#failhard: False
#
# autoload_dynamic_modules Turns on automatic loading of modules found in the
# environments on the master. This is turned on by default, to turn of
# autoloading modules when states run set this value to False
#autoload_dynamic_modules: True
#
# clean_dynamic_modules keeps the dynamic modules on the minion in sync with
# the dynamic modules on the master, this means that if a dynamic module is
# not on the master it will be deleted from the minion. By default this is
# enabled and can be disabled by changing this value to False
#clean_dynamic_modules: True
#
# Normally the minion is not isolated to any single environment on the master
# when running states, but the environment can be isolated on the minion side
# by statically setting it. Remember that the recommended way to manage
# environments is to isolate via the top file.
#environment: None
#
# If using the local file directory, then the state top file name needs to be
# defined, by default this is top.sls.
#state_top: top.sls
#
# Run states when the minion daemon starts. To enable, set startup_states to:
# \(aqhighstate\(aq \-\- Execute state.highstate
# \(aqsls\(aq \-\- Read in the sls_list option and execute the named sls files
# \(aqtop\(aq \-\- Read top_file option and execute based on that file on the Master
#startup_states: \(aq\(aq
#
# list of states to run when the minion starts up if startup_states is \(aqsls\(aq
#sls_list:
#  \- edit.vim
#  \- hyper
#
# top file to execute if startup_states is \(aqtop\(aq
#top_file: \(aq\(aq

#####     File Directory Settings    #####
##########################################
# The Salt Minion can redirect all file server operations to a local directory,
# this allows for the same state tree that is on the master to be used if
# copied completely onto the minion. This is a literal copy of the settings on
# the master but used to reference a local directory on the minion.

# Set the file client, the client defaults to looking on the master server for
# files, but can be directed to look at the local file directory setting
# defined below by setting it to local.
#file_client: remote

# The file directory works on environments passed to the minion, each environment
# can have multiple root directories, the subdirectories in the multiple file
# roots cannot match, otherwise the downloaded files will not be able to be
# reliably ensured. A base environment is required to house the top file.
# Example:
# file_roots:
#   base:
#     \- /srv/salt/
#   dev:
#     \- /srv/salt/dev/services
#     \- /srv/salt/dev/states
#   prod:
#     \- /srv/salt/prod/services
#     \- /srv/salt/prod/states
#
# Default:
#file_roots:
#  base:
#    \- /srv/salt

# The hash_type is the hash to use when discovering the hash of a file in
# the minion directory, the default is md5, but sha1, sha224, sha256, sha384
# and sha512 are also supported.
#hash_type: md5

# The Salt pillar is searched for locally if file_client is set to local. If
# this is the case, and pillar data is defined, then the pillar_roots need to
# also be configured on the minion:
#pillar_roots:
#  base:
#    \- /srv/pillar

######        Security settings       #####
###########################################
# Enable "open mode", this mode still maintains encryption, but turns off
# authentication, this is only intended for highly secure environments or for
# the situation where your keys end up in a bad state. If you run in open mode
# you do so at your own risk!
#open_mode: False

# Enable permissive access to the salt keys.  This allows you to run the
# master or minion as root, but have a non\-root group be given access to
# your pki_dir.  To make the access explicit, root must belong to the group
# you\(aqve given access to. This is potentially quite insecure.
#permissive_pki_access: False

# The state_verbose and state_output settings can be used to change the way
# state system data is printed to the display. By default all data is printed.
# The state_verbose setting can be set to True or False, when set to False
# all data that has a result of True and no changes will be suppressed.
#state_verbose: True
#
# The state_output setting changes if the output is the full multi line
# output for each changed state if set to \(aqfull\(aq, but if set to \(aqterse\(aq
# the output will be shortened to a single line.
#state_output: full
#
# Fingerprint of the master public key to double verify the master is valid,
# the master fingerprint can be found by running "salt\-key \-F master" on the
# salt master.
#master_finger: \(aq\(aq

######         Thread settings        #####
###########################################
# Disable multiprocessing support, by default when a minion receives a
# publication a new process is spawned and the command is executed therein.
#multiprocessing: True

#####         Logging settings       #####
##########################################
# The location of the minion log file
# The minion log can be sent to a regular file, local path name, or network
# location. Remote logging works best when configured to use rsyslogd(8) (e.g.:
# \(ga\(gafile:///dev/log\(ga\(ga), with rsyslogd(8) configured for network logging. The URI
# format is: <file|udp|tcp>://<host|socketpath>:<port\-if\-required>/<log\-facility>
#log_file: /var/log/salt/minion
#log_file: file:///dev/log
#log_file: udp://loghost:10514
#
#log_file: /var/log/salt/minion
#key_logfile: /var/log/salt/key
#
# The level of messages to send to the console.
# One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
# Default: \(aqwarning\(aq
#log_level: warning
#
# The level of messages to send to the log file.
# One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
# Default: \(aqwarning\(aq
#log_level_logfile:

# The date and time format used in log messages. Allowed date/time formating
# can be seen here: http://docs.python.org/library/time.html#time.strftime
#log_datefmt: \(aq%H:%M:%S\(aq
#log_datefmt_logfile: \(aq%Y\-%m\-%d %H:%M:%S\(aq
#
# The format of the console logging messages. Allowed formatting options can
# be seen here: http://docs.python.org/library/logging.html#logrecord\-attributes
#log_fmt_console: \(aq[%(levelname)\-8s] %(message)s\(aq
#log_fmt_logfile: \(aq%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\(aq
#
# This can be used to control logging levels more specificically.  This
# example sets the main salt library at the \(aqwarning\(aq level, but sets
# \(aqsalt.modules\(aq to log at the \(aqdebug\(aq level:
#   log_granular_levels:
#     \(aqsalt\(aq: \(aqwarning\(aq,
#     \(aqsalt.modules\(aq: \(aqdebug\(aq
#
#log_granular_levels: {}

######      Module configuration      #####
###########################################
# Salt allows for modules to be passed arbitrary configuration data, any data
# passed here in valid yaml format will be passed on to the salt minion modules
# for use. It is STRONGLY recommended that a naming convention be used in which
# the module name is followed by a . and then the value. Also, all top level
# data must be applied via the yaml dict construct, some examples:
#
# You can specify that all modules should run in test mode:
#test: True
#
# A simple value for the test module:
#test.foo: foo
#
# A list for the test module:
#test.bar: [baz,quo]
#
# A dict for the test module:
#test.baz: {spam: sausage, cheese: bread}


######      Update settings          ######
###########################################
# Using the features in Esky, a salt minion can both run as a frozen app and
# be updated on the fly. These options control how the update process
# (saltutil.update()) behaves.
#
# The url for finding and downloading updates. Disabled by default.
#update_url: False
#
# The list of services to restart after a successful update. Empty by default.
#update_restart_services: []


######      Keepalive settings        ######
############################################
# ZeroMQ now includes support for configuring SO_KEEPALIVE if supported by
# the OS. If connections between the minion and the master pass through
# a state tracking device such as a firewall or VPN gateway, there is
# the risk that it could tear down the connection the master and minion
# without informing either party that their connection has been taken away.
# Enabling TCP Keepalives prevents this from happening.
#
# Overall state of TCP Keepalives, enable (1 or True), disable (0 or False)
# or leave to the OS defaults (\-1), on Linux, typically disabled. Default True, enabled.
#tcp_keepalive: True
#
# How long before the first keepalive should be sent in seconds. Default 300
# to send the first keepalive after 5 minutes, OS default (\-1) is typically 7200 seconds
# on Linux see /proc/sys/net/ipv4/tcp_keepalive_time.
#tcp_keepalive_idle: 300
#
# How many lost probes are needed to consider the connection lost. Default \-1
# to use OS defaults, typically 9 on Linux, see /proc/sys/net/ipv4/tcp_keepalive_probes.
#tcp_keepalive_cnt: \-1
#
# How often, in seconds, to send keepalives after the first one. Default \-1 to
# use OS defaults, typically 75 seconds on Linux, see
# /proc/sys/net/ipv4/tcp_keepalive_intvl.
#tcp_keepalive_intvl: \-1


######      Windows Software settings ######
############################################
# Location of the repository cache file on the master
# win_repo_cachefile: \(aqsalt://win/repo/winrepo.p\(aq

.ft P
.fi
.SH CONFIGURING THE SALT MASTER
.sp
The Salt system is amazingly simple and easy to configure, the two components
of the Salt system each have a respective configuration file. The
\fBsalt\-master\fP is configured via the master configuration file, and the
\fBsalt\-minion\fP is configured via the minion configuration file.
.IP "See also"
.sp
\fIexample master configuration file\fP
.RE
.sp
The configuration file for the salt\-master is located at
\fB/etc/salt/master\fP. The available options are as follows:
.SS Primary Master Configuration
.SS \fBinterface\fP
.sp
Default: \fB0.0.0.0\fP (all interfaces)
.sp
The local interface to bind to.
.sp
.nf
.ft C
interface: 192.168.0.1
.ft P
.fi
.SS \fBpublish_port\fP
.sp
Default: \fB4505\fP
.sp
The network port to set up the publication interface
.sp
.nf
.ft C
publish_port: 4505
.ft P
.fi
.SS \fBuser\fP
.sp
Default: \fBroot\fP
.sp
The user to run the Salt processes
.sp
.nf
.ft C
user: root
.ft P
.fi
.SS \fBmax_open_files\fP
.sp
Default: \fBmax_open_files\fP
.sp
Each minion connecting to the master uses AT LEAST one file descriptor, the
master subscription connection. If enough minions connect you might start
seeing on the console(and then salt\-master crashes):
.sp
.nf
.ft C
Too many open files (tcp_listener.cpp:335)
Aborted (core dumped)
.ft P
.fi
.sp
By default this value will be the one of \fIulimit \-Hn\fP, i.e., the hard limit for
max open files.
.sp
If you wish to set a different value than the default one, uncomment and
configure this setting. Remember that this value CANNOT be higher than the
hard limit. Raising the hard limit depends on your OS and/or distribution,
a good way to find the limit is to search the internet for(for example):
.sp
.nf
.ft C
raise max open files hard limit debian
.ft P
.fi
.sp
.nf
.ft C
max_open_files: 100000
.ft P
.fi
.SS \fBworker_threads\fP
.sp
Default: \fB5\fP
.sp
The number of threads to start for receiving commands and replies from minions.
If minions are stalling on replies because you have many minions, raise the
worker_threads value.
.sp
Worker threads should not be put below 3 when using the peer system, but can
drop down to 1 worker otherwise.
.sp
.nf
.ft C
worker_threads: 5
.ft P
.fi
.SS \fBret_port\fP
.sp
Default: \fB4506\fP
.sp
The port used by the return server, this is the server used by Salt to receive
execution returns and command executions.
.sp
.nf
.ft C
ret_port: 4506
.ft P
.fi
.SS \fBpidfile\fP
.sp
Default: \fB/var/run/salt\-master.pid\fP
.sp
Specify the location of the master pidfile
.sp
.nf
.ft C
pidfile: /var/run/salt\-master.pid
.ft P
.fi
.SS \fBroot_dir\fP
.sp
Default: \fB/\fP
.sp
The system root directory to operate from, change this to make Salt run from
an alternative root
.sp
.nf
.ft C
root_dir: /
.ft P
.fi
.SS \fBpki_dir\fP
.sp
Default: \fB/etc/salt/pki\fP
.sp
The directory to store the pki authentication keys.
.sp
.nf
.ft C
pki_dir: /etc/salt/pki
.ft P
.fi
.SS \fBcachedir\fP
.sp
Default: \fB/var/cache/salt\fP
.sp
The location used to store cache information, particularly the job information
for executed salt commands.
.sp
.nf
.ft C
cachedir: /var/cache/salt
.ft P
.fi
.SS \fBkeep_jobs\fP
.sp
Default: \fB24\fP
.sp
Set the number of hours to keep old job information
.SS \fBjob_cache\fP
.sp
Default: \fBTrue\fP
.sp
The master maintains a job cache, while this is a great addition it can be
a burden on the master for larger deployments (over 5000 minions).
Disabling the job cache will make previously executed jobs unavailable to
the jobs system and is not generally recommended. Normally it is wise to make
sure the master has access to a faster IO system or a tmpfs is mounted to the
jobs dir
.SS \fBext_job_cache\fP
.sp
Default: \(aq\(aq
.sp
Used to specify a default returner for all minions, when this option is set
the specified returner needs to be properly configured and the minions will
always default to sending returns to this returner. This will also disable the
local job cache on the master
.sp
.nf
.ft C
ext_job_cache: redis
.ft P
.fi
.SS \fBminion_data_cache\fP
.sp
Default: True
.sp
The minion data cache is a cache of information about the minions stored on the
master, this information is primarily the pillar and grains data. The data is
cached in the Master cachedir under the name of the minion and used to pre
determine what minions are expected to reply from executions.
.sp
.nf
.ft C
minion_cache_dir: True
.ft P
.fi
.SS \fBenforce_mine_cache\fP
.sp
Default: False
.sp
By\-default when disabling the minion_data_cache mine will stop working since
it is based on cached data, by enabling this option we explicitly enabling
only the cache for the mine system.
.sp
.nf
.ft C
enforce_mine_cache: False
.ft P
.fi
.SS \fBsock_dir\fP
.sp
Default:: \fB/tmp/salt\-unix\fP
.sp
Set the location to use for creating Unix sockets for master process
communication
.SS Master Security Settings
.SS \fBopen_mode\fP
.sp
Default: \fBFalse\fP
.sp
Open mode is a dangerous security feature. One problem encountered with pki
authentication systems is that keys can become "mixed up" and authentication
begins to fail. Open mode turns off authentication and tells the master to
accept all authentication. This will clean up the pki keys received from the
minions. Open mode should not be turned on for general use. Open mode should
only be used for a short period of time to clean up pki keys. To turn on open
mode set this value to \fBTrue\fP.
.sp
.nf
.ft C
open_mode: False
.ft P
.fi
.SS \fBauto_accept\fP
.sp
Default: \fBFalse\fP
.sp
Enable auto_accept. This setting will automatically accept all incoming
public keys from the minions
.sp
.nf
.ft C
auto_accept: False
.ft P
.fi
.SS \fBautosign_file\fP
.sp
Default \fBnot defined\fP
.sp
If the autosign_file is specified incoming keys specified in the autosign_file
will be automatically accepted.  Matches will be searched for first by string
comparison, then by globbing, then by full\-string regex matching.  This is
insecure!
.SS \fBclient_acl\fP
.sp
Default: {}
.sp
Enable user accounts on the master to execute specific modules. These modules
can be expressed as regular expressions
.sp
.nf
.ft C
client_acl:
  fred:
    \- test.ping
    \- pkg.*
.ft P
.fi
.SS Master Module Management
.SS \fBrunner_dirs\fP
.sp
Default: \fB[]\fP
.sp
Set additional directories to search for runner modules
.SS \fBcython_enable\fP
.sp
Default: \fBFalse\fP
.sp
Set to true to enable cython modules (.pyx files) to be compiled on the fly on
the Salt master
.sp
.nf
.ft C
cython_enable: False
.ft P
.fi
.SS Master State System Settings
.SS \fBstate_verbose\fP
.sp
Default: \fBFalse\fP
.sp
state_verbose allows for the data returned from the minion to be more
verbose. Normally only states that fail or states that have changes are
returned, but setting state_verbose to \fBTrue\fP will return all states that
were checked
.sp
.nf
.ft C
state_verbose: True
.ft P
.fi
.SS \fBstate_output\fP
.sp
Default: \fBfull\fP
.sp
The state_output setting changes if the output is the full multi line
output for each changed state if set to \(aqfull\(aq, but if set to \(aqterse\(aq
the output will be shortened to a single line.  If set to \(aqmixed\(aq, the output
will be terse unless a state failed, in which case that output will be full.
If set to \(aqchanges\(aq, the output will be full unless the state didn\(aqt change.
.sp
.nf
.ft C
state_output: full
.ft P
.fi
.SS \fBstate_top\fP
.sp
Default: \fBtop.sls\fP
.sp
The state system uses a "top" file to tell the minions what environment to
use and what modules to use. The state_top file is defined relative to the
root of the base environment
.sp
.nf
.ft C
state_top: top.sls
.ft P
.fi
.SS \fBexternal_nodes\fP
.sp
Default: None
.sp
The external_nodes option allows Salt to gather data that would normally be
placed in a top file from and external node controller. The external_nodes
option is the executable that will return the ENC data. Remember that Salt
will look for external nodes AND top files and combine the results if both
are enabled and available!
.sp
.nf
.ft C
external_nodes: cobbler\-ext\-nodes
.ft P
.fi
.SS \fBrenderer\fP
.sp
Default: \fByaml_jinja\fP
.sp
The renderer to use on the minions to render the state data
.sp
.nf
.ft C
renderer: yaml_jinja
.ft P
.fi
.SS \fBfailhard\fP
.sp
Default:: \fBFalse\fP
.sp
Set the global failhard flag, this informs all states to stop running states
at the moment a single state fails
.sp
.nf
.ft C
failhard: False
.ft P
.fi
.SS \fBtest\fP
.sp
Default:: \fBFalse\fP
.sp
Set all state calls to only test if they are going to actually make changes
or just post what changes are going to be made
.sp
.nf
.ft C
test: False
.ft P
.fi
.SS Master File Server Settings
.SS \fBfile_roots\fP
.sp
Default: \fBbase: [/srv/salt]\fP
.sp
Salt runs a lightweight file server written in ZeroMQ to deliver files to
minions. This file server is built into the master daemon and does not
require a dedicated port.
.sp
The file server works on environments passed to the master. Each environment
can have multiple root directories. The subdirectories in the multiple file
roots cannot match, otherwise the downloaded files will not be able to be
reliably ensured. A base environment is required to house the top file.
Example:
.sp
.nf
.ft C
file_roots:
  base:
    \- /srv/salt
  dev:
    \- /srv/salt/dev/services
    \- /srv/salt/dev/states
  prod:
    \- /srv/salt/prod/services
    \- /srv/salt/prod/states
.ft P
.fi
.sp
.nf
.ft C
base:
  \- /srv/salt
.ft P
.fi
.SS \fBhash_type\fP
.sp
Default: \fBmd5\fP
.sp
The hash_type is the hash to use when discovering the hash of a file on
the master server, the default is md5, but sha1, sha224, sha256, sha384
and sha512 are also supported.
.sp
.nf
.ft C
hash_type: md5
.ft P
.fi
.SS \fBfile_buffer_size\fP
.sp
Default: \fB1048576\fP
.sp
The buffer size in the file server in bytes
.sp
.nf
.ft C
file_buffer_size: 1048576
.ft P
.fi
.SS Pillar Configuration
.SS \fBpillar_roots\fP
.sp
Set the environments and directories used to hold pillar sls data. This
configuration is the same as file_roots:
.sp
Default: \fBbase: [/srv/pillar]\fP
.sp
.nf
.ft C
pillar_roots:
  base:
    \- /srv/pillar/
  dev:
    \- /srv/pillar/dev/
  prod:
    \- /srv/pillar/prod/
.ft P
.fi
.sp
.nf
.ft C
base:
  \- /srv/pillar
.ft P
.fi
.SS \fBext_pillar\fP
.sp
The ext_pillar option allows for any number of external pillar interfaces to be
called when populating pillar data. The configuration is based on ext_pillar
functions. The available ext_pillar functions are: hiera, cmd_yaml. By default
the ext_pillar interface is not configured to run.
.sp
Default:: \fBNone\fP
.sp
.nf
.ft C
ext_pillar:
  \- hiera: /etc/hiera.yaml
  \- cmd_yaml: cat /etc/salt/yaml
  \- reclass:
      inventory_base_uri: /etc/reclass
.ft P
.fi
.sp
There are additional details at \fIsalt\-pillars\fP
.SS Syndic Server Settings
.sp
A Salt syndic is a Salt master used to pass commands from a higher Salt master to
minions below the syndic. Using the syndic is simple. If this is a master that
will have syndic servers(s) below it, set the "order_masters" setting to True. If this
is a master that will be running a syndic daemon for passthrough the
"syndic_master" setting needs to be set to the location of the master server
.SS \fBorder_masters\fP
.sp
Default: \fBFalse\fP
.sp
Extra data needs to be sent with publications if the master is controlling a
lower level master via a syndic minion. If this is the case the order_masters
value must be set to True
.sp
.nf
.ft C
order_masters: False
.ft P
.fi
.SS \fBsyndic_master\fP
.sp
Default: \fBNone\fP
.sp
If this master will be running a salt\-syndic to connect to a higher level
master, specify the higher level master with this configuration value
.sp
.nf
.ft C
syndic_master: masterofmasters
.ft P
.fi
.SS Peer Publish Settings
.sp
Salt minions can send commands to other minions, but only if the minion is
allowed to. By default "Peer Publication" is disabled, and when enabled it
is enabled for specific minions and specific commands. This allows secure
compartmentalization of commands based on individual minions.
.SS \fBpeer\fP
.sp
Default: \fB{}\fP
.sp
The configuration uses regular expressions to match minions and then a list
of regular expressions to match functions. The following will allow the
minion authenticated as foo.example.com to execute functions from the test
and pkg modules
.sp
.nf
.ft C
peer:
  foo.example.com:
      \- test.*
      \- pkg.*
.ft P
.fi
.sp
This will allow all minions to execute all commands:
.sp
.nf
.ft C
peer:
  .*:
      \- .*
.ft P
.fi
.sp
This is not recommended, since it would allow anyone who gets root on any
single minion to instantly have root on all of the minions!
.SS \fBpeer_run\fP
.sp
Default: \fB{}\fP
.sp
The peer_run option is used to open up runners on the master to access from the
minions. The peer_run configuration matches the format of the peer
configuration.
.sp
The following example would allow foo.example.com to execute the manage.up
runner:
.sp
.nf
.ft C
peer_run:
  foo.example.com:
      \- manage.up
.ft P
.fi
.SS Node Groups
.sp
Default: \fB{}\fP
.sp
Node groups allow for logical groupings of minion nodes.
A group consists of a group name and a compound target.
.sp
.nf
.ft C
nodegroups:
  group1: \(aqL@foo.domain.com,bar.domain.com,baz.domain.com or bl*.domain.com\(aq
  group2: \(aqG@os:Debian and foo.domain.com\(aq
.ft P
.fi
.SS Master Logging Settings
.SS \fBlog_file\fP
.sp
Default: /var/log/salt/master
.sp
The master log can be sent to a regular file, local path name, or network location.
Remote logging works best when configured to use rsyslogd(8) (e.g.: \fBfile:///dev/log\fP),
with rsyslogd(8) configured for network logging.  The format for remote addresses is:
\fB<file|udp|tcp>://<host|socketpath>:<port\-if\-required>/<log\-facility>\fP.  Examples:
.sp
.nf
.ft C
log_file: /var/log/salt/master
.ft P
.fi
.sp
.nf
.ft C
log_file: file:///dev/log
.ft P
.fi
.sp
.nf
.ft C
log_file: udp://loghost:10514
.ft P
.fi
.SS \fBlog_level\fP
.sp
Default: \fBwarning\fP
.sp
The level of messages to send to the console.
One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
.sp
.nf
.ft C
log_level: warning
.ft P
.fi
.SS \fBlog_level_logfile\fP
.sp
Default: \fBwarning\fP
.sp
The level of messages to send to the log file.
One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
.sp
.nf
.ft C
log_level_logfile: warning
.ft P
.fi
.SS \fBlog_datefmt\fP
.sp
Default: \fB%H:%M:%S\fP
.sp
The date and time format used in console log messages. Allowed date/time formatting
can be seen on \fI\%http://docs.python.org/library/time.html#time.strftime\fP
.sp
.nf
.ft C
log_datefmt: \(aq%H:%M:%S\(aq
.ft P
.fi
.SS \fBlog_datefmt_logfile\fP
.sp
Default: \fB%Y\-%m\-%d %H:%M:%S\fP
.sp
The date and time format used in log file messages. Allowed date/time formatting
can be seen on \fI\%http://docs.python.org/library/time.html#time.strftime\fP
.sp
.nf
.ft C
log_datefmt_logfile: \(aq%Y\-%m\-%d %H:%M:%S\(aq
.ft P
.fi
.SS \fBlog_fmt_console\fP
.sp
Default: \fB[%(levelname)\-8s] %(message)s\fP
.sp
The format of the console logging messages. Allowed formatting options can
be seen on \fI\%http://docs.python.org/library/logging.html#logrecord-attributes\fP
.sp
.nf
.ft C
log_fmt_console: \(aq[%(levelname)\-8s] %(message)s\(aq
.ft P
.fi
.SS \fBlog_fmt_logfile\fP
.sp
Default: \fB%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\fP
.sp
The format of the log file logging messages. Allowed formatting options can
be seen on \fI\%http://docs.python.org/library/logging.html#logrecord-attributes\fP
.sp
.nf
.ft C
log_fmt_logfile: \(aq%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\(aq
.ft P
.fi
.SS \fBlog_granular_levels\fP
.sp
Default: \fB{}\fP
.sp
This can be used to control logging levels more specifically.  The
example sets the main salt library at the \(aqwarning\(aq level, but sets
\(aqsalt.modules\(aq to log at the \(aqdebug\(aq level:
.sp
.nf
.ft C
log_granular_levels:
  \(aqsalt\(aq: \(aqwarning\(aq,
  \(aqsalt.modules\(aq: \(aqdebug\(aq
.ft P
.fi
.SS \fBdefault_include\fP
.sp
Default: \fBmaster.d/*.conf\fP
.sp
The master can include configuration from other files. Per default the
master will automatically include all config files from \fImaster.d/*.conf\fP
where master.d is relative to the directory of the master configuration
file.
.SH CONFIGURING THE SALT MINION
.sp
The Salt system is amazingly simple and easy to configure, the two components
of the Salt system each have a respective configuration file. The
\fBsalt\-master\fP is configured via the master configuration file, and the
\fBsalt\-minion\fP is configured via the minion configuration file.
.IP "See also"
.sp
\fIexample minion configuration file\fP
.RE
.sp
The Salt Minion configuration is very simple, typically the only value that
needs to be set is the master value so the minion can find its master.
.SS Minion Primary Configuration
.SS \fBmaster\fP
.sp
Default: \fBsalt\fP
.sp
The hostname or ipv4 of the master.
.sp
.nf
.ft C
master: salt
.ft P
.fi
.SS \fBmaster_port\fP
.sp
Default: \fB4506\fP
.sp
The port of the master ret server, this needs to coincide with the ret_port
option on the Salt master.
.sp
.nf
.ft C
master_port: 4506
.ft P
.fi
.SS \fBuser\fP
.sp
Default: \fBroot\fP
.sp
The user to run the Salt processes
.sp
.nf
.ft C
user: root
.ft P
.fi
.SS \fBpidfile\fP
.sp
Default: \fB/var/run/salt\-minion.pid\fP
.sp
The location of the daemon\(aqs process ID file
.sp
.nf
.ft C
pidfie: /var/run/salt\-minion.pid
.ft P
.fi
.SS \fBroot_dir\fP
.sp
Default: \fB/\fP
.sp
This directory is prepended to the following options: \fBpki_dir\fP,
\fBcachedir\fP, \fBlog_file\fP, \fBsock_dir\fP, and
\fBpidfile\fP.
.sp
.nf
.ft C
root_dir: /
.ft P
.fi
.SS \fBpki_dir\fP
.sp
Default: \fB/etc/salt/pki\fP
.sp
The directory used to store the minion\(aqs public and private keys.
.sp
.nf
.ft C
pki_dir: /etc/salt/pki
.ft P
.fi
.SS \fBid\fP
.sp
Default: hostname (as returned by the Python call: \fBsocket.getfqdn()\fP)
.sp
Explicitly declare the id for this minion to use, if left commented the id
will be the hostname as returned by the Python call: \fBsocket.getfqdn()\fP
Since Salt uses detached ids it is possible to run multiple minions on the
same machine but with different ids, this can be useful for Salt compute
clusters.
.sp
.nf
.ft C
id: foo.bar.com
.ft P
.fi
.SS \fBappend_domain\fP
.sp
Default: \fBNone\fP
.sp
Append a domain to a hostname in the event that it does not exist. This is
useful for systems where \fBsocket.getfqdn()\fP does not actually result in a
FQDN (for instance, Solaris).
.sp
.nf
.ft C
append_domain: foo.org
.ft P
.fi
.SS \fBcachedir\fP
.sp
Default: \fB/var/cache/salt\fP
.sp
The location for minion cache data.
.sp
.nf
.ft C
cachedir: /var/cache/salt
.ft P
.fi
.SS \fBverify_env\fP
.sp
Default: \fBTrue\fP
.sp
Verify and set permissions on configuration directories at startup.
.sp
.nf
.ft C
verify_env: True
.ft P
.fi
.SS \fBcache_jobs\fP
.sp
Default: \fBFalse\fP
.sp
The minion can locally cache the return data from jobs sent to it, this can be
a good way to keep track of the minion side of the jobs the minion has
executed. By default this feature is disabled, to enable set cache_jobs to
\fBTrue\fP.
.sp
.nf
.ft C
cache_jobs: False
.ft P
.fi
.SS \fBsock_dir\fP
.sp
Default: \fB/var/run/salt/minion\fP
.sp
The directory where Unix sockets will be kept.
.sp
.nf
.ft C
sock_dir: /var/run/salt/minion
.ft P
.fi
.SS \fBbackup_mode\fP
.sp
Default: \fB[]\fP
.sp
Backup files replaced by file.managed and file.recurse under cachedir.
.sp
.nf
.ft C
backup_mode: minion
.ft P
.fi
.SS \fBacceptance_wait_time\fP
.sp
Default: \fB10\fP
.sp
The number of seconds to wait until attempting to re\-authenticate with the
master.
.sp
.nf
.ft C
acceptance_wait_time: 10
.ft P
.fi
.SS \fBacceptance_wait_time_max\fP
.sp
Default: \fBNone\fP
.sp
The maximum number of seconds to wait until attempting to re\-authenticate
with the master. If set, the wait will increase by \fBacceptance_wait_time\fP
seconds each iteration.
.sp
.nf
.ft C
acceptance_wait_time_max: None
.ft P
.fi
.SS \fBdns_check\fP
.sp
Default: \fBTrue\fP
.sp
When healing, a dns_check is run. This is to make sure that the originally
resolved dns has not changed. If this is something that does not happen in your
environment, set this value to \fBFalse\fP.
.sp
.nf
.ft C
dns_check: True
.ft P
.fi
.SS \fBipc_mode\fP
.sp
Default: \fBipc\fP
.sp
Windows platforms lack POSIX IPC and must rely on slower TCP based inter\-
process communications. Set ipc_mode to \fBtcp\fP on such systems.
.sp
.nf
.ft C
ipc_mode: ipc
.ft P
.fi
.SS \fBtcp_pub_port\fP
.sp
Default: \fB4510\fP
.sp
Publish port used when \fBipc_mode\fP is set to \fBtcp\fP.
.sp
.nf
.ft C
tcp_pub_port: 4510
.ft P
.fi
.SS \fBtcp_pull_port\fP
.sp
Default: \fB4511\fP
.sp
Pull port used when \fBipc_mode\fP is set to \fBtcp\fP.
.sp
.nf
.ft C
tcp_pull_port: 4511
.ft P
.fi
.SS Minion Module Management
.SS \fBdisable_modules\fP
.sp
Default: \fB[]\fP (all modules are enabled by default)
.sp
The event may occur in which the administrator desires that a minion should not
be able to execute a certain module. The sys module is built into the minion
and cannot be disabled.
.sp
This setting can also tune the minion, as all modules are loaded into ram
disabling modules will lover the minion\(aqs ram footprint.
.sp
.nf
.ft C
disable_modules:
  \- test
  \- solr
.ft P
.fi
.SS \fBdisable_returners\fP
.sp
Default: \fB[]\fP (all returners are enabled by default)
.sp
If certain returners should be disabled, this is the place
.sp
.nf
.ft C
disable_returners:
  \- mongo_return
.ft P
.fi
.SS \fBmodule_dirs\fP
.sp
Default: \fB[]\fP
.sp
A list of extra directories to search for Salt modules
.sp
.nf
.ft C
module_dirs:
  \- /var/lib/salt/modules
.ft P
.fi
.SS \fBreturner_dirs\fP
.sp
Default: \fB[]\fP
.sp
A list of extra directories to search for Salt returners
.sp
.nf
.ft C
returners_dirs:
  \- /var/lib/salt/returners
.ft P
.fi
.SS \fBstates_dirs\fP
.sp
Default: \fB[]\fP
.sp
A list of extra directories to search for Salt states
.sp
.nf
.ft C
states_dirs:
  \- /var/lib/salt/states
.ft P
.fi
.SS \fBrender_dirs\fP
.sp
Default: \fB[]\fP
.sp
A list of extra directories to search for Salt renderers
.sp
.nf
.ft C
render_dirs:
  \- /var/lib/salt/renderers
.ft P
.fi
.SS \fBcython_enable\fP
.sp
Default: \fBFalse\fP
.sp
Set this value to true to enable auto\-loading and compiling of \fB.pyx\fP modules,
This setting requires that \fBgcc\fP and \fBcython\fP are installed on the minion
.sp
.nf
.ft C
cython_enable: False
.ft P
.fi
.SS \fBproviders\fP
.sp
Default: (empty)
.sp
A module provider can be statically overwritten or extended for the minion via
the \fBproviders\fP option. This can be done \fBon an individual basis in an
SLS file\fP, or globally here in the minion config, like
below.
.sp
.nf
.ft C
providers:
  pkg: yumpkg5
  service: systemd
.ft P
.fi
.SS State Management Settings
.SS \fBrenderer\fP
.sp
Default: \fByaml_jinja\fP
.sp
The default renderer used for local state executions
.sp
.nf
.ft C
renderer: yaml_jinja
.ft P
.fi
.SS \fBstate_verbose\fP
.sp
Default: \fBFalse\fP
.sp
state_verbose allows for the data returned from the minion to be more
verbose. Normally only states that fail or states that have changes are
returned, but setting state_verbose to \fBTrue\fP will return all states that
were checked
.sp
.nf
.ft C
state_verbose: True
.ft P
.fi
.SS \fBstate_output\fP
.sp
Default: \fBfull\fP
.sp
The state_output setting changes if the output is the full multi line
output for each changed state if set to \(aqfull\(aq, but if set to \(aqterse\(aq
the output will be shortened to a single line.
.sp
.nf
.ft C
state_output: full
.ft P
.fi
.SS \fBautoload_dynamic_modules\fP
.sp
Default: \fBTrue\fP
.sp
autoload_dynamic_modules Turns on automatic loading of modules found in the
environments on the master. This is turned on by default, to turn of
auto\-loading modules when states run set this value to \fBFalse\fP
.sp
.nf
.ft C
autoload_dynamic_modules: True
.ft P
.fi
.sp
Default: \fBTrue\fP
.sp
clean_dynamic_modules keeps the dynamic modules on the minion in sync with
the dynamic modules on the master, this means that if a dynamic module is
not on the master it will be deleted from the minion. By default this is
enabled and can be disabled by changing this value to \fBFalse\fP
.sp
.nf
.ft C
clean_dynamic_modules: True
.ft P
.fi
.SS \fBenvironment\fP
.sp
Default: \fBNone\fP
.sp
Normally the minion is not isolated to any single environment on the master
when running states, but the environment can be isolated on the minion side
by statically setting it. Remember that the recommended way to manage
environments is to isolate via the top file.
.sp
.nf
.ft C
environment: None
.ft P
.fi
.SS Security Settings
.SS \fBopen_mode\fP
.sp
Default: \fBFalse\fP
.sp
Open mode can be used to clean out the PKI key received from the Salt master,
turn on open mode, restart the minion, then turn off open mode and restart the
minion to clean the keys.
.sp
.nf
.ft C
open_mode: False
.ft P
.fi
.SS Thread Settings
.sp
Default: \fBTrue\fP
.sp
Disable multiprocessing support by default when a minion receives a
publication a new process is spawned and the command is executed therein.
.sp
.nf
.ft C
multiprocessing: True
.ft P
.fi
.SS Minion Logging Settings
.SS \fBlog_file\fP
.sp
Default: /var/log/salt/minion
.sp
The minion log can be sent to a regular file, local path name, or network location.
Remote logging works best when configured to use rsyslogd(8) (e.g.: \fBfile:///dev/log\fP),
with rsyslogd(8) configured for network logging.  The format for remote addresses is:
\fB<file|udp|tcp>://<host|socketpath>:<port\-if\-required>/<log\-facility>\fP.  Examples:
.sp
.nf
.ft C
log_file: /var/log/salt/minion
.ft P
.fi
.sp
.nf
.ft C
log_file: file:///dev/log
.ft P
.fi
.sp
.nf
.ft C
log_file: udp://loghost:10514
.ft P
.fi
.SS \fBlog_level\fP
.sp
Default: \fBwarning\fP
.sp
The level of messages to send to the console.
One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
.sp
.nf
.ft C
log_level: warning
.ft P
.fi
.SS \fBlog_level_logfile\fP
.sp
Default: \fBwarning\fP
.sp
The level of messages to send to the log file.
One of \(aqgarbage\(aq, \(aqtrace\(aq, \(aqdebug\(aq, info\(aq, \(aqwarning\(aq, \(aqerror\(aq, \(aqcritical\(aq.
.sp
.nf
.ft C
log_level_logfile: warning
.ft P
.fi
.SS \fBlog_datefmt\fP
.sp
Default: \fB%H:%M:%S\fP
.sp
The date and time format used in console log messages. Allowed date/time formatting
can be seen on \fI\%http://docs.python.org/library/time.html#time.strftime\fP
.sp
.nf
.ft C
log_datefmt: \(aq%H:%M:%S\(aq
.ft P
.fi
.SS \fBlog_datefmt_logfile\fP
.sp
Default: \fB%Y\-%m\-%d %H:%M:%S\fP
.sp
The date and time format used in log file messages. Allowed date/time formatting
can be seen on \fI\%http://docs.python.org/library/time.html#time.strftime\fP
.sp
.nf
.ft C
log_datefmt_logfile: \(aq%Y\-%m\-%d %H:%M:%S\(aq
.ft P
.fi
.SS \fBlog_fmt_console\fP
.sp
Default: \fB[%(levelname)\-8s] %(message)s\fP
.sp
The format of the console logging messages. Allowed formatting options can
be seen on \fI\%http://docs.python.org/library/logging.html#logrecord-attributes\fP
.sp
.nf
.ft C
log_fmt_console: \(aq[%(levelname)\-8s] %(message)s\(aq
.ft P
.fi
.SS \fBlog_fmt_logfile\fP
.sp
Default: \fB%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\fP
.sp
The format of the log file logging messages. Allowed formatting options can
be seen on \fI\%http://docs.python.org/library/logging.html#logrecord-attributes\fP
.sp
.nf
.ft C
log_fmt_logfile: \(aq%(asctime)s,%(msecs)03.0f [%(name)\-17s][%(levelname)\-8s] %(message)s\(aq
.ft P
.fi
.SS \fBlog_granular_levels\fP
.sp
Default: \fB{}\fP
.sp
This can be used to control logging levels more specifically.  This
example sets the main salt library at the \(aqwarning\(aq level, but sets
\(aqsalt.modules\(aq to log at the \(aqdebug\(aq level:
.sp
.nf
.ft C
log_granular_levels:
  \(aqsalt\(aq: \(aqwarning\(aq,
  \(aqsalt.modules\(aq: \(aqdebug\(aq
.ft P
.fi
.SS \fBdefault_include\fP
.sp
Default: \fBminion.d/*.conf\fP
.sp
The minion can include configuration from other files. Per default the
minion will automatically include all config files from \fIminion.d/*.conf\fP
where minion.d is relative to the directory of the minion configuration
file.
.SS \fBinclude\fP
.sp
Default: \fBnot defined\fP
.sp
The minion can include configuration from other files. To enable this,
pass a list of paths to this option. The paths can be either relative or
absolute; if relative, they are considered to be relative to the directory
the main minion configuration file lives in. Paths can make use of
shell\-style globbing. If no files are matched by a path passed to this
option then the minion will log a warning message.
.sp
.nf
.ft C
# Include files from a minion.d directory in the same
# directory as the minion config file
include: minion.d/*

# Include a single extra file into the configuration
include: /etc/roles/webserver

# Include several files and the minion.d directory
include:
  \- extra_config
  \- minion.d/*
  \- /etc/roles/webserver
.ft P
.fi
.SS Frozen Build Update Settings
.sp
These options control how \fBsalt.modules.saltutil.update()\fP works with esky
frozen apps. For more information look at \fI\%https://github.com/cloudmatrix/esky/\fP.
.SS \fBupdate_url\fP
.sp
Default: \fBFalse\fP (Update feature is disabled)
.sp
The url to use when looking for application updates. Esky depends on directory
listings to search for new versions. A webserver running on your Master is a
good starting point for most setups.
.sp
.nf
.ft C
update_url: \(aqhttp://salt.example.com/minion\-updates\(aq
.ft P
.fi
.SS \fBupdate_restart_services\fP
.sp
Default: \fB[]\fP (service restarting on update is disabled)
.sp
A list of services to restart when the minion software is updated. This would
typically just be a list containing the minion\(aqs service name, but you may
have other services that need to go with it.
.sp
.nf
.ft C
update_restart_services: [\(aqsalt\-minion\(aq]
.ft P
.fi
.SH SALT CODE AND INTERNALS
.sp
Reference documentation on Salt\(aqs internal code.
.SS Contents
.SS Exceptions
.sp
Salt\-specific exceptions should be thrown as often as possible so the various
interfaces to Salt (CLI, API, etc) can handle those errors appropriately and
display error messages appropriately.
.TS
center;
|l|l|.
_
T{
\fBsalt.exceptions\fP
T}	T{
This module is a central location for all salt exceptions
T}
_
.TE
.SS salt.exceptions
.sp
This module is a central location for all salt exceptions
.INDENT 0.0
.TP
.B exception salt.exceptions.AuthenticationError
If sha256 signature fails during decryption
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.CommandExecutionError
Used when a module runs a command which returns an error and wants
to show the user the output gracefully instead of dying
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.CommandNotFoundError
Used in modules or grains when a required binary is not available
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.EauthAuthenticationError
Thrown when eauth authentication fails
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.LoaderError
Problems loading the right renderer
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.MasterExit
Rise when the master exits
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.MinionError
Minion problems reading uris such as salt:// or http://
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.PkgParseError
Used when of the pkg modules cannot correctly parse the output from
the CLI tool (pacman, yum, apt, aptitude, etc)
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltClientError
Problem reading the master root key
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltException
Base exception class; all Salt\-specific exceptions should subclass this
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltInvocationError
Used when the wrong number of arguments are sent to modules or invalid
arguments are specified on the command line
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltMasterError
Problem reading the master root key
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltRenderError
Used when a renderer needs to raise an explicit error
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltReqTimeoutError
Thrown when a salt master request call fails to return within the timeout
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltSystemExit(code=0, msg=None)
This exception is raised when an unsolvable problem is found. There\(aqs
nothing else to do, salt should just exit.
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.TimedProcTimeoutError
Thrown when a timed subprocess does not terminate within the timeout,
or if the specified timeout is not an int or a float
.UNINDENT
.SS salt.exceptions
.sp
This module is a central location for all salt exceptions
.INDENT 0.0
.TP
.B exception salt.exceptions.AuthenticationError
If sha256 signature fails during decryption
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.CommandExecutionError
Used when a module runs a command which returns an error and wants
to show the user the output gracefully instead of dying
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.CommandNotFoundError
Used in modules or grains when a required binary is not available
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.EauthAuthenticationError
Thrown when eauth authentication fails
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.LoaderError
Problems loading the right renderer
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.MasterExit
Rise when the master exits
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.MinionError
Minion problems reading uris such as salt:// or http://
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.PkgParseError
Used when of the pkg modules cannot correctly parse the output from
the CLI tool (pacman, yum, apt, aptitude, etc)
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltClientError
Problem reading the master root key
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltException
Base exception class; all Salt\-specific exceptions should subclass this
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltInvocationError
Used when the wrong number of arguments are sent to modules or invalid
arguments are specified on the command line
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltMasterError
Problem reading the master root key
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltRenderError
Used when a renderer needs to raise an explicit error
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltReqTimeoutError
Thrown when a salt master request call fails to return within the timeout
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.SaltSystemExit(code=0, msg=None)
This exception is raised when an unsolvable problem is found. There\(aqs
nothing else to do, salt should just exit.
.UNINDENT
.INDENT 0.0
.TP
.B exception salt.exceptions.TimedProcTimeoutError
Thrown when a timed subprocess does not terminate within the timeout,
or if the specified timeout is not an int or a float
.UNINDENT
.SH NETWORK TOPOLOGY
.sp
Salt is based on a powerful, asynchronous, network topology using ZeroMQ. Many
ZeroMQ systems are in place to enable communication. The central idea is to
have the fastest communication possible.
.SS Servers
.sp
The Salt Master runs 2 network services. First is the ZeroMQ PUB system. This
service by default runs on port \fB4505\fP and can be configured via the
\fBpublish_port\fP option in the master configuration.
.sp
Second is the ZeroMQ REP system. This is a separate interface used for all
bi\-directional communication with minions. By default this system binds to
port \fB4506\fP and can be configured via the \fBret_port\fP option in the master.
.SS PUB/SUB
.sp
The commands sent out via the salt client are broadcast out to the minions via
ZeroMQ PUB/SUB. This is done by allowing the minions to maintain a connection
back to the Salt Master and then all connections are informed to download the
command data at once. The command data is kept extremely small (usually less
than 1K) so it is not a burden on the network.
.SS Return
.sp
The PUB/SUB system is a one way communication, so once a publish is sent out
the PUB interface on the master has no further communication with the minion.
The minion, after running the command, then sends the command\(aqs return data
back to the master via the \fBret_port\fP.
.SH WINDOWS SOFTWARE REPOSITORY
.sp
The Salt Windows Software Repository provides a package manager and software
repository similar to what is provided by yum and apt on Linux.
.sp
By default, the Windows software repository is found at \fB/srv/salt/win/repo\fP
Each piece of software should have its own directory which contains the
installers and a package definition file. This package definition file is a
YAML file named \fBinit.sls\fP.
.sp
The package definition file should look similar to this example for Firefox:
\fB/srv/salt/win/repo/firefox/init.sls\fP
.sp
.nf
.ft C
firefox:
  17.0.1:
    installer: \(aqsalt://win/repo/firefox/English/Firefox Setup 17.0.1.exe\(aq
    full_name: Mozilla Firefox 17.0.1 (x86 en\-US)
    locale: en_US
    reboot: False
    install_flags: \(aq \-ms\(aq
    uninstaller: \(aq%ProgramFiles(x86)%/Mozilla Firefox/uninstall/helper.exe\(aq
    uninstall_flags: \(aq /S\(aq
  16.0.2:
    installer: \(aqsalt://win/repo/firefox/English/Firefox Setup 16.0.2.exe\(aq
    full_name: Mozilla Firefox 16.0.2 (x86 en\-US)
    locale: en_US
    reboot: False
    install_flags: \(aq \-ms\(aq
    uninstaller: \(aq%ProgramFiles(x86)%/Mozilla Firefox/uninstall/helper.exe\(aq
    uninstall_flags: \(aq /S\(aq
  15.0.1:
    installer: \(aqsalt://win/repo/firefox/English/Firefox Setup 15.0.1.exe\(aq
    full_name: Mozilla Firefox 15.0.1 (x86 en\-US)
    locale: en_US
    reboot: False
    install_flags: \(aq \-ms\(aq
    uninstaller: \(aq%ProgramFiles(x86)%/Mozilla Firefox/uninstall/helper.exe\(aq
    uninstall_flags: \(aq /S\(aq
.ft P
.fi
.sp
Add \fBmsiexec: True\fP if using an MSI installer requiring the use of \fBmsiexec
/i\fP to install and \fBmsiexec /x\fP to uninstall.
\fB/srv/salt/win/repo/7zip/init.sls\fP
.sp
.nf
.ft C
7zip:
  9.20:
    installer: salt://win/repo/7zip/7z920\-x64.msi
    full_name: 7zip 9.22
    reboot: False
    install_flags: \(aq /q \(aq
    msiexec: True
    uninstaller: salt://win/repo/7zip/7z920\-x64.msi
    uninstall_flags: \(aq /qn\(aq
.ft P
.fi
.SS Generate Repo Cache File
.sp
Once the sls file has been created, generate the repository cache file with the winrepo runner:
.sp
.nf
.ft C
$ salt\-run winrepo.genrepo
.ft P
.fi
.sp
Then update the repository cache file on your minions, exactly how it\(aqs done for the Linux package managers:
.sp
.nf
.ft C
$ salt \(aq*\(aq pkg.refresh_db
.ft P
.fi
.SS Install Windows Software
.sp
Now you can query the available version of Firefox using the Salt pkg module.
.sp
.nf
.ft C
$ salt \e* pkg.available_version firefox

{\(aqdavewindows\(aq: {\(aq15.0.1\(aq: \(aqMozilla Firefox 15.0.1 (x86 en\-US)\(aq,
                 \(aq16.0.2\(aq: \(aqMozilla Firefox 16.0.2 (x86 en\-US)\(aq,
                 \(aq17.0.1\(aq: \(aqMozilla Firefox 17.0.1 (x86 en\-US)\(aq}}
.ft P
.fi
.sp
As you can see, there are three versions of Firefox available for installation.
.sp
.nf
.ft C
$ salt \e* pkg.install firefox
.ft P
.fi
.sp
The above line will install the latest version of Firefox.
.sp
.nf
.ft C
$ salt \e* pkg.install firefox version=16.0.2
.ft P
.fi
.sp
The above line will install version 16.0.2 of Firefox.
.sp
This first release requires you uninstall an application and then install a
newer version in order to accomplish an upgrade. This will be fixed very soon.
.SS Uninstall Windows Software
.sp
Uninstall software using the pkg module:
.sp
.nf
.ft C
$ salt \e* pkg.remove firefox

$ salt \e* pkg.purge firefox
.ft P
.fi
.sp
\fBpkg.purge\fP just executes \fBpkg.remove\fP on Windows. At some point in the
future \fBpkg.purge\fP may direct the installer to remove all configs and
settings for software packages that support that option.
.SS Git Hosted Repo
.sp
Windows software package definitions can also be hosted in one or more git
repositories. The default repo is one hosted on Github.com by SaltStack,Inc., which
includes package definitions for open source software. This repo points to the
HTTP or ftp locations of the installer files. Anyone is welcome to send a pull
request to this repo to add new package definitions. Browse the repo
here: \fI\%https://github.com/saltstack/salt-winrepo\fP .
.sp
Configure which git repos the master can search for package definitions by
modifying or extending the \fBwin_gitrepos\fP configuration option list in the
master config.
.sp
Checkout each git repo in \fBwin_gitrepos\fP, compile your package repository
cache and then refresh each minion\(aqs package cache:
.sp
.nf
.ft C
$ salt\-run winrepo.update_git_repos
$ salt\-run winrepo.genrepo
$ salt \e* pkg.refresh_db
.ft P
.fi
.SH COMMAND LINE REFERENCE
.sp
Salt can be controlled by a command line client by the root user on the Salt
master. The Salt command line client uses the Salt client API to communicate
with the Salt master server. The Salt client is straightforward and simple
to use.
.sp
Using the Salt client commands can be easily sent to the minions.
.sp
Each of these commands accepts an explicit \fI\-\-config\fP option to point to either
the master or minion configuration file.  If this option is not provided and
the default configuration file does not exist then Salt falls back to use the
environment variables \fBSALT_MASTER_CONFIG\fP and \fBSALT_MINION_CONFIG\fP.
.IP "See also"
.sp
\fB/topics/configuration\fP
.RE
.SS Using the Salt Command
.sp
The Salt command needs a few components to send information to the Salt
minions. The target minions need to be defined, the function to call and any
arguments the function requires.
.SS Defining the Target Minions
.sp
The first argument passed to salt, defines the target minions, the target
minions are accessed via their hostname. The default target type is a bash
glob:
.sp
.nf
.ft C
salt \e*foo.com sys.doc
.ft P
.fi
.sp
Salt can also define the target minions with regular expressions:
.sp
.nf
.ft C
salt \-E \(aq.*\(aq cmd.run \(aqls \-l | grep foo\(aq
.ft P
.fi
.sp
Or to explicitly list hosts, salt can take a list:
.sp
.nf
.ft C
salt \-L foo.bar.baz,quo.qux cmd.run \(aqps aux | grep foo\(aq
.ft P
.fi
.SS More Powerful Targets
.sp
The simple target specifications, glob, regex and list will cover many use
cases, and for some will cover all use cases, but more powerful options exist.
.SS Targeting with Grains
.sp
The Grains interface was built into Salt to allow minions to be targeted by
system properties. So minions running on a particular operating system can
be called to execute a function, or a specific kernel.
.sp
Calling via a grain is done by passing the \-G option to salt, specifying
a grain and a glob expression to match the value of the grain. The syntax for
the target is the grain key followed by a globexpression: "os:Arch*".
.sp
.nf
.ft C
salt \-G \(aqos:Fedora\(aq test.ping
.ft P
.fi
.sp
Will return True from all of the minions running Fedora.
.sp
To discover what grains are available and what the values are, execute the
grains.item salt function:
.sp
.nf
.ft C
salt \(aq*\(aq grains.items
.ft P
.fi
.SS Targeting with Executions
.sp
As of 0.8.8 targeting with executions is still under heavy development and this
documentation is written to reference the behavior of execution matching in the
future.
.sp
Execution matching allows for a primary function to be executed, and then based
on the return of the primary function the main function is executed.
.sp
Execution matching allows for matching minions based on any arbitrary running
data on the minions.
.SS Compound Targeting
.sp
New in version 0.9.5.
.sp
Multiple target interfaces can be used in conjunction to determine the command
targets. These targets can then be combined using and or or statements. This
is well defined with an example:
.sp
.nf
.ft C
salt \-C \(aqG@os:Debian and webser* or E@db.*\(aq test.ping
.ft P
.fi
.sp
In this example any minion who\(aqs id starts with \fBwebser\fP and is running
Debian, or any minion who\(aqs id starts with db will be matched.
.sp
The type of matcher defaults to glob, but can be specified with the
corresponding letter followed by the \fB@\fP symbol. In the above example a grain
is used with \fBG@\fP as well as a regular expression with \fBE@\fP. The
\fBwebser*\fP target does not need to be prefaced with a target type specifier
because it is a glob.
.SS Node Group Targeting
.sp
New in version 0.9.5.
.sp
Often the convenience of having a predefined group of minions to execute
targets on is desired. This can be accomplished with the new nodegroups
feature. Nodegroups allow for predefined compound targets to be declared in
the master configuration file:
.sp
.nf
.ft C
nodegroups:
 \ group1: \(aqL@foo.domain.com,bar.domain.com,baz.domain.com and bl*.domain.com\(aq
 \ group2: \(aqG@os:Debian and foo.domain.com\(aq
.ft P
.fi
.SS Calling the Function
.sp
The function to call on the specified target is placed after the target
specification.
.sp
New in version 0.9.8.
.sp
Functions may also accept arguments, space\-delimited:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.exec_code python \(aqimport sys; print sys.version\(aq
.ft P
.fi
.sp
Optional, keyword arguments are also supported:
.sp
.nf
.ft C
salt \(aq*\(aq pip.install salt timeout=5 upgrade=True
.ft P
.fi
.sp
They are always in the form of \fBkwarg=argument\fP.
.sp
Arguments are formatted as YAML:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run \(aqecho "Hello: $FIRST_NAME"\(aq env=\(aq{FIRST_NAME: "Joe"}\(aq
.ft P
.fi
.sp
Note: dictionaries must have curly braces around them (like the \fBenv\fP
keyword argument above).  This was changed in 0.15.1: in the above example,
the first argument used to be parsed as the dictionary
\fB{\(aqecho "Hello\(aq: \(aq$FIRST_NAME"\(aq}\fP. This was generally not the expected
behavior.
.sp
If you want to test what parameters are actually passed to a module, use the
\fBtest.arg_repr\fP command:
.sp
.nf
.ft C
salt \(aq*\(aq test.arg_repr \(aqecho "Hello: $FIRST_NAME"\(aq env=\(aq{FIRST_NAME: "Joe"}\(aq
.ft P
.fi
.SS Finding available minion functions
.sp
The Salt functions are self documenting, all of the function documentation can
be retried from the minions via the \fBsys.doc()\fP function:
.sp
.nf
.ft C
salt \(aq*\(aq sys.doc
.ft P
.fi
.SS Compound Command Execution
.sp
If a series of commands needs to be sent to a single target specification then
the commands can be sent in a single publish. This can make gathering
groups of information faster, and lowers the stress on the network for repeated
commands.
.sp
Compound command execution works by sending a list of functions and arguments
instead of sending a single function and argument. The functions are executed
on the minion in the order they are defined on the command line, and then the
data from all of the commands are returned in a dictionary. This means that
the set of commands are called in a predictable way, and the returned data can
be easily interpreted.
.sp
Executing compound commands if done by passing a comma delimited list of
functions, followed by a comma delimited list of arguments:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run,test.ping,test.echo \(aqcat /proc/cpuinfo\(aq,,foo
.ft P
.fi
.sp
The trick to look out for here, is that if a function is being passed no
arguments, then there needs to be a placeholder for the absent arguments. This
is why in the above example, there are two commas right next to each other.
\fBtest.ping\fP takes no arguments, so we need to add another comma, otherwise
Salt would attempt to pass "foo" to \fBtest.ping\fP.
.sp
If you need to pass arguments that include commas, then make sure you add
spaces around the commas that separate arguments. For example:
.sp
.nf
.ft C
salt \(aq*\(aq cmd.run,test.ping,test.echo \(aqecho "1,2,3"\(aq , , foo
.ft P
.fi
.sp
You may change the arguments separator using the \fB\-\-args\-separator\fP option:
.sp
.nf
.ft C
salt \-\-args\-separator=:: \(aq*\(aq some.fun,test.echo params with , comma :: foo
.ft P
.fi
.SH SALT
.SS Synopsis
.INDENT 0.0
.INDENT 3.5
salt \(aq*\(aq [ options ] sys.doc
.sp
salt \-E \(aq.*\(aq [ options ] sys.doc cmd
.sp
salt \-G \(aqos:Arch.*\(aq [ options ] test.ping
.sp
salt \-C \fI\%'G@os\fP:Arch.* and webserv* or \fI\%G@kernel\fP:FreeBSD\(aq [ options ] test.ping
.UNINDENT
.UNINDENT
.SS Description
.sp
Salt allows for commands to be executed across a swath of remote systems in
parallel. This means that remote systems can be both controlled and queried
with ease.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options
.UNINDENT
.INDENT 0.0
.TP
.B \-t TIMEOUT, \-\-timeout=TIMEOUT
The timeout in seconds to wait for replies from the Salt minions. The
timeout number specifies how long the command line client will wait to
query the minions and check on running jobs.
.UNINDENT
.INDENT 0.0
.TP
.B \-s, \-\-static
By default as of version 0.9.8 the salt command returns data to the
console as it is received from minions, but previous releases would return
data only after all data was received. To only return the data with a hard
timeout and after all minions have returned then use the static option.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-async
Instead of waiting for the job to run on minions only print the jod id of
the started execution and complete.
.UNINDENT
.INDENT 0.0
.TP
.B \-b BATCH, \-\-batch\-size=BATCH
Instead of executing on all targeted minions at once, execute on a
progressive set of minions. This option takes an argument in the form of
an explicit number of minions to execute at once, or a percentage of
minions to execute on.
.UNINDENT
.INDENT 0.0
.TP
.B \-a EAUTH, \-\-auth=EAUTH
Pass in an external authentication medium to validate against. The
credentials will be prompted for. Can be used with the \-T option.
.UNINDENT
.INDENT 0.0
.TP
.B \-T, \-\-make\-token
Used in conjunction with the \-a option. This creates a token that allows
for the authenticated user to send commands without needing to
re\-authenticate.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Print the version of Salt that is running.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-E, \-\-pcre
The target expression will be interpreted as a pcre regular expression
rather than a shell glob.
.UNINDENT
.INDENT 0.0
.TP
.B \-L, \-\-list
The target expression will be interpreted as a comma delimited list,
example: server1.foo.bar,server2.foo.bar,example7.quo.qux
.UNINDENT
.INDENT 0.0
.TP
.B \-G, \-\-grain
The target expression matches values returned by the Salt grains system on
the minions. The target expression is in the format of \(aq<grain value>:<glob
expression>\(aq; example: \(aqos:Arch*\(aq
.sp
This was changed in version 0.9.8 to accept glob expressions instead of
regular expression. To use regular expression matching with grains use
the \-\-grain\-pcre option.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-grain\-pcre
The target expression matches values returned by the Salt grains system on
the minions. The target expression is in the format of \(aq<grain value>:<
regular expression>\(aq; example: \(aqos:Arch.*\(aq
.UNINDENT
.INDENT 0.0
.TP
.B \-C, \-\-compound
Utilize many target definitions to make the call very granular. This option
takes a group of targets separated by and or or. The default matcher is a
glob as usual, if something other than a glob is used preface it with the
letter denoting the type, example: \(aqwebserv* and \fI\%G@os\fP:Debian or \fI\%E@db*\fP\(aq
make sure that the compound target is encapsulated in quotes.
.UNINDENT
.INDENT 0.0
.TP
.B \-X, \-\-exsel
Instead of using shell globs use the return code of a function.
.UNINDENT
.INDENT 0.0
.TP
.B \-N, \-\-nodegroup
Use a predefined compound target defined in the Salt master configuration
file.
.UNINDENT
.INDENT 0.0
.TP
.B \-I, \-\-pillar
Instead of using shell globs to evaluate the target use a pillar value to
identify targets, the syntax for the target is the pillar key followed by
a glob expression: "role:production*"
.UNINDENT
.INDENT 0.0
.TP
.B \-S, \-\-ipcidr
Match based on Subnet (CIDR notation) or IPv4 address.
.UNINDENT
.INDENT 0.0
.TP
.B \-R, \-\-range
Instead of using shell globs to evaluate the target use a range expression
to identify targets. Range expressions look like %cluster.
.sp
Using the Range option requires that a range server is set up and the
location of the range server is referenced in the master configuration
file.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-return
Chose an alternative returner to call on the minion, if an alternative
returner is used then the return will not come back to the command line
but will be sent to the specified return system.
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.INDENT 0.0
.TP
.B \-v VERBOSE, \-\-verbose
Turn on verbosity for the salt call, this will cause the salt command to
print out extra data like the job id.
.UNINDENT
.INDENT 0.0
.TP
.B \-d, \-\-doc, \-\-documentation
Return the documentation for the module functions available on the minions
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out
Pass in an alternative outputter to display the return of data. This
outputter can be any of the available outputters:
grains, highstate, json, key, overstatestage, pprint, raw, txt, yaml
Some outputters are formatted only for data returned from specific
functions, for instance the grains outputter will not work for non grains
data.
If an outputter is used that does not support the data passed into it, then
Salt will fall back on the pprint outputter and display the return data
using the python pprint library.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out\-indent OUTPUT_INDENT, \-\-output\-indent OUTPUT_INDENT
Print the output indented by the provided value in spaces. Negative values
disables indentation. Only applicable in outputters that support indentation.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-no\-color
Disable all colored output
.UNINDENT
.SS See also
.sp
\fIsalt(7)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH SALT-MASTER
.sp
The Salt master daemon, used to control the Salt minions
.SS Synopsis
.sp
salt\-master [ options ]
.SS Description
.sp
The master daemon controls the Salt minions
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-d, \-\-daemon
Run the Salt master as a daemon
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.INDENT 0.0
.TP
.B \-u USER, \-\-user=USER
Specify user to run minion
.UNINDENT
.INDENT 0.0
.TP
.B \-\-pid\-file PIDFILE
Specify the location of the pidfile.
.UNINDENT
.INDENT 0.0
.TP
.B \-l LOG_LEVEL, \-\-log\-level=LOG_LEVEL
Console log level. One of \fBinfo\fP, \fBnone\fP, \fBgarbage\fP,
\fBtrace\fP, \fBwarning\fP, \fBerror\fP, \fBdebug\fP. For the logfile
settings see the config file. Default: \fBwarning\fP.
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt(7)\fP
\fIsalt\-minion(1)\fP
.SH SALT-MINION
.sp
The Salt minion daemon, receives commands from a remote Salt master.
.SS Synopsis
.sp
salt\-minion [ options ]
.SS Description
.sp
The Salt minion receives commands from the central Salt master and replies with
the results of said commands.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options.
.UNINDENT
.INDENT 0.0
.TP
.B \-d, \-\-daemon
Run the Salt minion as a daemon
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.INDENT 0.0
.TP
.B \-u USER, \-\-user=USER
Specify user to run minion
.UNINDENT
.INDENT 0.0
.TP
.B \-\-pid\-file PIDFILE
Specify the location of the pidfile
.UNINDENT
.INDENT 0.0
.TP
.B \-l LOG_LEVEL, \-\-log\-level=LOG_LEVEL
Console log level. One of \fBinfo\fP, \fBnone\fP, \fBgarbage\fP,
\fBtrace\fP, \fBwarning\fP, \fBerror\fP, \fBdebug\fP. For the logfile
settings see the config file. Default: \fBwarning\fP.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt(7)\fP
\fIsalt\-master(1)\fP
.SH SALT-KEY
.SS Synopsis
.sp
salt\-key [ options ]
.SS Description
.sp
Salt\-key executes simple management of Salt server public keys used for
authentication.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options.
.UNINDENT
.INDENT 0.0
.TP
.B \-l ARG, \-\-list=ARG
List the public keys. The args "pre", "un", and "unaccepted" will list
unaccepted/unsigned keys. "acc" or "accepted" will list accepted/signed
keys. "rej" or "rejected" will list rejected keys. Finally, "all" will list
all keys.
.UNINDENT
.INDENT 0.0
.TP
.B \-L, \-\-list\-all
List all public keys on this Salt master: accepted, pending,
and rejected.
.UNINDENT
.INDENT 0.0
.TP
.B \-a ACCEPT, \-\-accept=ACCEPT
Accept the named minion public key for command execution.
.UNINDENT
.INDENT 0.0
.TP
.B \-A, \-\-accept\-all
Accepts all pending public keys.
.UNINDENT
.INDENT 0.0
.TP
.B \-r REJECT, \-\-reject=REJECT
Reject the named minion public key.
.UNINDENT
.INDENT 0.0
.TP
.B \-R, \-\-reject\-all
Rejects all pending public keys.
.UNINDENT
.INDENT 0.0
.TP
.B \-d DELETE, \-\-delete=DELETE
Delete the named minion key or minion keys matching a glob for command
execution.
.UNINDENT
.INDENT 0.0
.TP
.B \-D, \-\-delete\-all
Delete all keys
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.INDENT 0.0
.TP
.B \-p PRINT, \-\-print=PRINT
Print the specified public key
.UNINDENT
.INDENT 0.0
.TP
.B \-P, \-\-print\-all
Print all public keys
.UNINDENT
.INDENT 0.0
.TP
.B \-q, \-\-quiet
Supress output
.UNINDENT
.INDENT 0.0
.TP
.B \-y, \-\-yes
Answer \(aqYes\(aq to all questions presented, defaults to False
.UNINDENT
.INDENT 0.0
.TP
.B \-\-key\-logfile=KEY_LOGFILE
Send all output to a file. Default is /var/log/salt/key
.UNINDENT
.INDENT 0.0
.TP
.B \-\-gen\-keys=GEN_KEYS
Set a name to generate a keypair for use with salt
.UNINDENT
.INDENT 0.0
.TP
.B \-\-gen\-keys\-dir=GEN_KEYS_DIR
Set the directory to save the generated keypair.  Only works
with \(aqgen_keys_dir\(aq option; default is the current directory.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-keysize=KEYSIZE
Set the keysize for the generated key, only works with
the \(aq\-\-gen\-keys\(aq option, the key size must be 2048 or
higher, otherwise it will be rounded up to 2048. The
default is 2048.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out
Pass in an alternative outputter to display the return of data. This
outputter can be any of the available outputters:
grains, highstate, json, key, overstatestage, pprint, raw, txt, yaml
Some outputters are formatted only for data returned from specific
functions, for instance the grains outputter will not work for non grains
data.
If an outputter is used that does not support the data passed into it, then
Salt will fall back on the pprint outputter and display the return data
using the python pprint library.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out\-indent OUTPUT_INDENT, \-\-output\-indent OUTPUT_INDENT
Print the output indented by the provided value in spaces. Negative values
disables indentation. Only applicable in outputters that support indentation.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-no\-color
Disable all colored output
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.SS See also
.sp
\fIsalt(7)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH SALT-CP
.sp
Copy a file to a set of systems
.SS Synopsis
.sp
.nf
.ft C
salt\-cp \(aq*\(aq [ options ] SOURCE DEST

salt\-cp \-E \(aq.*\(aq [ options ] SOURCE DEST

salt\-cp \-G \(aqos:Arch.*\(aq [ options ] SOURCE DEST
.ft P
.fi
.SS Description
.sp
Salt copy copies a local file out to all of the Salt minions matched by the
given target.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options
.UNINDENT
.INDENT 0.0
.TP
.B \-t TIMEOUT, \-\-timeout=TIMEOUT
The timeout in seconds to wait for replies from the Salt minions.
.UNINDENT
.INDENT 0.0
.TP
.B \-E, \-\-pcre
The target expression will be interpreted as a PCRE regular expression
rather than a shell glob.
.UNINDENT
.INDENT 0.0
.TP
.B \-L, \-\-list
The target expression will be interpreted as a comma delimited list,
example: server1.foo.bar,server2.foo.bar,example7.quo.qux
.UNINDENT
.INDENT 0.0
.TP
.B \-G, \-\-grain
The target expression matches values returned by the Salt grains system on
the minions. The target expression is in the format of \(aq<grain value>:<glob
expression>\(aq; example: \(aqos:Arch*\(aq
.UNINDENT
.INDENT 0.0
.TP
.B \-\-grain\-pcre
The target expression matches values returned by the Salt grains system on
the minions. The target expression is in the format of \(aq<grain value>:<pcre
regular expression>\(aq; example: \(aqos:Arch.*\(aq
.UNINDENT
.INDENT 0.0
.TP
.B \-R, \-\-range
Instead of using shell globs to evaluate the target use a range expression
to identify targets. Range expressions look like %cluster.
.sp
Using the Range option requires that a range server is set up and the
location of the range server is referenced in the master configuration
file.
.UNINDENT
.INDENT 0.0
.TP
.B \-C, \-\-compound
Utilize many target definitions to make the call very granular. This option
takes a group of targets separated by and or or. The default matcher is a
glob as usual, if something other than a glob is used preface it with the
letter denoting the type, example: \(aqwebserv* and \fI\%G@os\fP:Debian or \fI\%E@db*\fP\(aq
make sure that the compound target is encapsulated in quotes.
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG, \-\-config=CONFIG
The location of the Salt master configuration file, the Salt master
settings are required to know where the connections are;
default=/etc/salt/master
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH SALT-CALL
.SS Synopsis
.sp
.nf
.ft C
salt\-call [options]
.ft P
.fi
.SS Description
.sp
The salt\-call command is used to run module functions locally on a minion
instead of executing them from the master.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options
.UNINDENT
.INDENT 0.0
.TP
.B \-g, \-\-grains
Return the information generated by the Salt grains
.UNINDENT
.INDENT 0.0
.TP
.B \-m MODULE_DIRS, \-\-module\-dirs=MODULE_DIRS
Specify an additional directories to pull modules from, multiple
directories can be delimited by commas
.UNINDENT
.INDENT 0.0
.TP
.B \-\-return RETURNER
Set salt\-call to pass the return data to one or many returner interfaces.
To use many returner interfaces specify a comma delimited list of
returners.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-local
Run salt\-call locally, as if there was no master running.
.UNINDENT
.INDENT 0.0
.TP
.B \-d, \-\-doc
Return the documentation for the specified module or for all modules if
none are specified
.UNINDENT
.INDENT 0.0
.TP
.B \-l LOG_LEVEL, \-\-log\-level=LOG_LEVEL
Console log level. One of \fBinfo\fP, \fBnone\fP, \fBgarbage\fP,
\fBtrace\fP, \fBwarning\fP, \fBerror\fP, \fBdebug\fP. For the logfile
settings see the config file. Default: \fBinfo\fP.
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out
Pass in an alternative outputter to display the return of data. This
outputter can be any of the available outputters:
grains, highstate, json, key, overstatestage, pprint, raw, txt, yaml
Some outputters are formatted only for data returned from specific
functions, for instance the grains outputter will not work for non grains
data.
If an outputter is used that does not support the data passed into it, then
Salt will fall back on the pprint outputter and display the return data
using the python pprint library.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-out\-indent OUTPUT_INDENT, \-\-output\-indent OUTPUT_INDENT
Print the output indented by the provided value in spaces. Negative values
disables indentation. Only applicable in outputters that support indentation.
.UNINDENT
.INDENT 0.0
.TP
.B \-\-no\-color
Disable all colored output
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH SALT-RUN
.sp
Execute a Salt runner
.SS Synopsis
.sp
.nf
.ft C
salt\-run RUNNER
.ft P
.fi
.SS Description
.sp
salt\-run is the frontend command for executing \fBSalt Runners\fP.
Salt runners are simple modules used to execute convenience functions on the
master
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH SALT-SYNDIC
.sp
The Salt syndic daemon, a special minion that passes through commands from a
higher master
.SS Synopsis
.sp
salt\-syndic [ options ]
.SS Description
.sp
The Salt syndic daemon, a special minion that passes through commands from a
higher master.
.SS Options
.INDENT 0.0
.TP
.B \-h, \-\-help
Print a usage message briefly summarizing these command\-line options.
.UNINDENT
.INDENT 0.0
.TP
.B \-d, \-\-daemon
Run the Salt syndic as a daemon
.UNINDENT
.INDENT 0.0
.TP
.B \-\-pid\-file PIDFILE
Specify the location of the pidfile
.UNINDENT
.INDENT 0.0
.TP
.B \-\-version
Show program\(aqs version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-\-versions\-report
Show program\(aqs dependencies version number and exit
.UNINDENT
.INDENT 0.0
.TP
.B \-c CONFIG_DIR, \-\-config\-dir=CONFIG_dir
The location of the Salt configuration directory, this directory contains
the configuration files for Salt master and minions. The default location
on most systems is /etc/salt.
.UNINDENT
.SS See also
.sp
\fIsalt(1)\fP
\fIsalt\-master(1)\fP
\fIsalt\-minion(1)\fP
.SH RELEASE NOTES AND UPGRADE INSTRUCTIONS
.SS Salt 0.10.0 Release Notes
.sp
0.10.0 has arrived! This release comes with MANY bug fixes, and new
capabilities which greatly enhance performance and reliability. This
release is primarily a bug fix release with many new tests and many repaired
bugs. This release also introduces a few new key features which were brought
in primarily to repair bugs and some limitations found in some of the
components of the original architecture.
.SS Major Features
.SS Event System
.sp
The Salt Master now comes equipped with a new event system. This event system
has replaced some of the back end of the Salt client and offers the beginning of
a system which will make plugging external applications into Salt. The event
system relies on a local ZeroMQ publish socket and other processes can connect
to this socket and listen for events. The new events can be easily managed via
Salt\(aqs event library.
.SS Unprivileged User Updates
.sp
Some enhancements have been added to Salt for running as a user other than
root. These new additions should make switching the user that the Salt Master
is running as very painless, simply change the \fBuser\fP option in the master
configuration and restart the master, Salt will take care of all of the
particulars for you.
.SS Peer Runner Execution
.sp
Salt has long had the peer communication system used to allow minions to send
commands via the salt master. 0.10.0 adds a new capability here, now the
master can be configured to allow for minions to execute Salt runners via
the \fBpeer_run\fP option in the salt master configuration.
.SS YAML Parsing Updates
.sp
In the past the YAML parser for sls files would return the incorrect numbers
when the file mode was set with a preceding 0. The YAML parser used in Salt
has been modified to no longer convert these number into octal but to keep
them as the correct value so that sls files can be a little cleaner to write.
.SS State Call Data Files
.sp
It was requested that the minion keep a local cache of the most recent executed
state run. This has been added and now with state runs the data is stored in a
msgpack file in the minion\(aqs cachedir.
.SS Turning Off the Job Cache
.sp
A new option has been added to the master configuration file. In previous
releases the Salt client would look over the Salt job cache to read in
the minion return data. With the addition of the event system the Salt client
can now watch for events directly from the master worker processes.
.sp
This means that the job cache is no longer a hard requirement. Keep in mind
though, that turning off the job cache means that historic job execution data
cannot be retrieved.
.SS Test Updates
.SS Minion Swarms Are Faster
.sp
To continue our efforts with testing Salt\(aqs ability to scale the minionswarm
script has been updated. The minionswarm can now start up minions much faster
than it could before and comes with a new feature allowing modules to be
disabled, thus lowering the minion\(aqs footprint when making a swarm. These new
updates have allows us to test
.sp
.nf
.ft C
# python minionswarm.py \-m 20 \-\-master salt\-master
.ft P
.fi
.SS Many Fixes
.sp
To get a good idea for the number of bugfixes this release offers take a look
at the closed tickets for 0.10.0, this is a very substantial update:
.sp
\fI\%https://github.com/saltstack/salt/issues?milestone=12&state=closed\fP
.SS Master and Minion Stability Fixes
.sp
As Salt deployments grow new ways to break Salt are discovered. 0.10.0 comes
with a number of fixes for the minions and master greatly improving Salt
stability.
.SS Salt 0.10.2 Release Notes
.sp
0.10.2 is out! This release comes with enhancements to the pillar interface,
cleaner ways to access the salt\-call capabilities in the API, minion data
caching and the event system has been added to salt minions.
.sp
There have also been updates to the ZeroMQ functions, many more tests
(thanks to sponsors, the code sprint and many contributors) and a swath
of bug fixes.
.SS Major Features
.SS Ext Pillar Modules
.sp
The ranks of available Salt modules directories sees a new member in 0.10.2.
With the popularity of pillar a higher demand has arisen for \fBext_pillar\fP
interfaces to be more like regular Salt module additions. Now ext_pillar
interfaces can be added in the same way as other modules, just drop it into
the pillar directory in the salt source.
.SS Minion Events
.sp
In 0.10.0 an event system was added to the Salt master. 0.10.2 adds the event
system to the minions as well. Now event can be published on a local minion
as well.
.sp
The minions can also send events back up to the master. This means that Salt is
able to communicate individual events from the minions back up to the Master
which are not associated with command.
.SS Minion Data Caching
.sp
When pillar was introduced the landscape for available data was greatly
enhanced. The minion\(aqs began sending grain data back to the master on a
regular basis.
.sp
The new config option on the master called \fBminion_data_cache\fP instructs the
Salt master to maintain a cache of the minion\(aqs grains and pillar data in the
cachedir. This option is turned off by default to avoid hitting the disk more,
but when enabled the cache is used to make grain matching from the salt command
more powerful, since the minions that will match can be predetermined.
.SS Backup Files
.sp
By default all files replaced by the file.managed and file.recurse states we
simply deleted. 0.10.2 adds a new option. By setting the backup option to
\fBminion\fP the files are backed up before they are replaced.
.sp
The backed up files are located in the cachedir under the file_backup
directory. On a default system this will be at:
\fB/var/cache/salt/file_backup\fP
.SS Configuration files
.sp
\fBsalt\-master\fP and \fBsalt\-minion\fP automatically load additional configuration
files from \fBmaster.d/*.conf\fP respective \fBminion.d/*.conf\fP where
\fBmaster.d\fP/\fBminion.d\fP is a directory in the same directory as the main
configuration file.
.SS Salt Key Verification
.sp
A number of users complained that they had inadvertently deleted the wrong salt
authentication keys. 0.10.2 now displays what keys are going to be deleted
and verifies that they are the keys that are intended for deletion.
.SS Key auto\-signing
.sp
If \fBautosign_file\fP is specified in the configuration file incoming keys
will be compared to the list of keynames in \fBautosign_file\fP. Regular
expressions as well as globbing is supported.
.sp
The file must only be writable by the user otherwise the file will be
ignored. To relax the permission and allow group write access set the
\fBpermissive_pki_access\fP option.
.SS Module changes
.SS Improved OpenBSD support
.sp
New modules for managing services and packages were provided by Joshua
Elsasser to further improve the support for OpenBSD.
.sp
Existing modules like the \fIdisk\fP module were also improved to support
OpenBSD.
.SS SQL Modules
.sp
The MySQL and PostgreSQL modules have both received a number of additions thanks
to the work of Avi Marcus and Roman Imankulov.
.SS ZFS Support on FreeBSD
.sp
A new ZFS module has been added by Kurtis Velarde for FreeBSD supporting
various ZFS operations like creating, extending or removing zpools.
.SS Augeas
.sp
A new Augeas module by Ulrich Dangel for editing and verifying config files.
.SS Native Debian Service module
.sp
The support for the Debian was further improved with an new service module
for Debian by Ahmad Khayyat supporting \fIdisable\fP and \fIenable\fP.
.SS Cassandra
.sp
Cassandra support has been added by Adam Garside. Currently only
status and diagnostic information are supported.
.SS Networking
.sp
The networking support for \fIRHEL\fP has been improved and supports bonding
support as well as zeroconf configuration.
.SS Monit
.sp
Basic monit support by Kurtis Velarde to control services via monit.
.SS nzbget
.sp
Basic support for controlling nzbget by Joseph Hall
.SS Bluetooth
.sp
Baisc \fBbluez\fP support for managing and controlling Bluetooth devices.
Supports scanning as well as pairing/unpairing by Joseph Hall.
.SS Test Updates
.SS Consistency Testing
.sp
Another testing script has been added. A bug was found in pillar when many
minions generated pillar data at the same time. The new \fBconsist.py\fP script
is the tests directory was created to reproduce bugs where data should always
be consistent.
.SS Many Fixes
.sp
To get a good idea for the number of bugfixes this release offers take a look
at the closed tickets for 0.10.2, this is a very substantial update:
.sp
\fI\%https://github.com/saltstack/salt/issues?milestone=24&page=1&state=closed\fP
.SS Master and Minion Stability Fixes
.sp
As Salt deployments grow new ways to break Salt are discovered. 0.10.2 comes
with a number of fixes for the minions and master greatly improving Salt
stability.
.SS Salt 0.10.3 Release Notes
.sp
The latest taste of Salt has come, this release has many fixes and feature
additions. Modifications have been made to make ZeroMQ connections more
reliable, the beginning of the ACL system is in place, a new command line
parsing system has been added, dynamic module distribution has become more
environment aware, the new \fImaster_finger\fP option and many more!
.SS Major Features
.SS ACL System
.sp
The new ACL system has been introduced. The ACL system allows for system users
other than root to execute salt commands. Users can be allowed to execute
specific commands in the same way that minions are opened up to the peer
system.
.sp
The configuration value to open up the ACL system is called \fBclient_acl\fP
and is configured like so:
.sp
.nf
.ft C
client_acl:
  fred:
    \- test..*
    \- pkg.list_pkgs
.ft P
.fi
.sp
Where \fIfred\fP is allowed access to functions in the test module and to the
\fBpkg.list_pkgs\fP function.
.SS Master Finger Option
.sp
The \fImaster_finger\fP option has been added to improve the security of minion
provisioning. The \fImaster_finger\fP option allows for the fingerprint of the
master public key to be set in the configuration file to double verify that the
master is valid. This option was added in response to a motivation to
pre\-authenticate the master when provisioning new minions to help prevent
man in the middle attacks in some situations.
.SS Salt Key Fingerprint Generation
.sp
The ability to generate fingerprints of keys used by Salt has been added to
\fBsalt\-key\fP. The new option \fIfinger\fP accepts the name of the key to generate
and display a fingerprint for.
.sp
.nf
.ft C
salt\-key \-F master
.ft P
.fi
.sp
Will display the fingerprints for the master public and private keys.
.SS Parsing System
.sp
Pedro Algavio, aka s0undt3ch, has added a substantial update to the command
line parsing system that makes the help message output much cleaner and easier
to search through. Salt parsers now have \fI\-\-versions\-report\fP besides usual
\fI\-\-version\fP info which you can provide when reporting any issues found.
.SS Key Generation
.sp
We have reduced the requirements needed for \fIsalt\-key\fP to generate minion keys.
You\(aqre no longer required to have salt configured and it\(aqs common directories
created just to generate keys. This might prove useful if you\(aqre batch creating
keys to pre\-load on minions.
.SS Startup States
.sp
A few configuration options have been added which allow for states to be run
when the minion daemon starts. This can be a great advantage when deploying
with Salt because the minion can apply states right when it first runs. To
use startup states set the \fBstartup_states\fP configuration option on the
minion to \fIhighstate\fP.
.SS New Exclude Declaration
.sp
Some users have asked about adding the ability to ensure that other sls files
or ids are excluded from a state run. The exclude statement will delete all of
the data loaded from the specified sls file or will delete the specified id:
.sp
.nf
.ft C
exclude:
  \- sls: http
  \- id: /etc/vimrc
.ft P
.fi
.SS Max Open Files
.sp
While we\(aqre currently unable to properly handle ZeroMQ\(aqs abort signals when the
max open files is reached, due to the way that\(aqs handled on ZeroMQ\(aqs, we have
minimized the chances of this happening without at least warning the user.
.SS More State Output Options
.sp
Some major changes have been made to the state output system. In the past state
return data was printed in a very verbose fashion and only states that failed
or made changes were printed by default. Now two options can be passed to the
master and minion configuration files to change the behavior of the state
output. State output can be set to verbose (default) or non\-verbose with the
\fBstate_verbose\fP option:
.sp
.nf
.ft C
state_verbose: False
.ft P
.fi
.sp
It is noteworthy that the state_verbose option used to be set to \fIFalse\fP by
default but has been changed to \fITrue\fP by default in 0.10.3 due to many
requests for the change.
.sp
Te next option to be aware of new and called \fBstate_output\fP. This option
allows for the state output to be set to \fIfull\fP (default) or \fIterse\fP.
.sp
The \fIfull\fP output is the standard state output, but the new \fIterse\fP output
will print only one line per state making the output much easier to follow when
executing a large state system.
.sp
.nf
.ft C
state_output: terse
.ft P
.fi
.SS \fIstate.file.append\fP Improvements
.sp
The salt state \fIfile.append()\fP tries \fInot\fP to append existing text. Previously
the matching check was being made line by line. While this kind of check might
be enough for most cases, if the text being appended was multi\-line, the check
would not work properly. This issue is now properly handled, the match is done
as a whole ignoring any white space addition or removal except inside commas.
For those thinking that, in order to properly match over multiple lines, salt
will load the whole file into memory, that\(aqs not true. For most cases this is
not important but an erroneous order to read a 4GB file, if not properly
handled, like salt does, could make salt chew that amount of memory.  Salt has
a buffered file reader which will keep in memory a maximum of 256KB and
iterates over the file in chunks of 32KB to test for the match, more than
enough, if not, explain your usage on a ticket. With this change, also
\fIsalt.modules.file.contains()\fP, \fIsalt.modules.file.contains_regex()\fP,
\fIsalt.modules.file.contains_glob()\fP and \fIsalt.utils.find\fP now do the searching
and/or matching using the buffered chunks approach explained above.
.sp
Two new keyword arguments were also added, \fImakedirs\fP and \fIsource\fP.
The first, \fImakedirs\fP will create the necessary directories in order to append
to the specified file, of course, it only applies if we\(aqre trying to append to
a non\-existing file on a non\-existing directory:
.sp
.nf
.ft C
/tmp/salttest/file\-append\-makedirs:
    file.append:
        text: foo
        makedirs: True
.ft P
.fi
.sp
The second, \fIsource\fP, allows one to append the contents of a file instead of
specifying the text.
.sp
.nf
.ft C
/tmp/salttest/file\-append\-source:

file.append:
    \- source: salt://testfile
.ft P
.fi
.SS Security Fix
.sp
A timing vulnerability was uncovered in the code which decrypts the AES
messages sent over the network. This has been fixed and upgrading is
strongly recommended.
.SS Salt 0.10.4 Release Notes
.sp
Salt 0.10.4 is a monumental release for the Salt team, with two new module
systems, many additions to allow granular access to Salt, improved platform
support and much more.
.sp
This release is also exciting because we have been able to shorten the release
cycle back to under a month. We are working hard to keep up the aggressive pace
and look forward to having releases happen more frequently!
.sp
This release also includes a serious security fix and all users are very
strongly recommended to upgrade. As usual, upgrade the master first, and then
the minion to ensure that the process is smooth.
.SS Major Features
.SS External Authentication System
.sp
The new external authentication system allows for Salt to pass through
authentication to any authentication system to determine if a user has
permission to execute a Salt command. The Unix PAM system is the first
supported system with more to come!
.sp
The external authentication system allows for specific users to be granted
access to execute specific functions on specific minions. Access is configured
in the master configuration file, and uses the new access control system:
.sp
.nf
.ft C
external_auth:
  pam:
    thatch:
      \- \(aqweb*\(aq:
        \- test.*
        \- network.*
.ft P
.fi
.sp
The configuration above allows the user \fIthatch\fP to execute functions in the
test and network modules on minions that match the web* target.
.SS Access Control System
.sp
All Salt systems can now be configured to grant access to non\-administrative
users in a granular way. The old configuration continues to work. Specific
functions can be opened up to specific minions from specific users in the case
of external auth and client ACLs, and for specific minions in the case of the
peer system.
.sp
Access controls are configured like this:
.sp
.nf
.ft C
client_acl:
  fred:
    \- web\e*:
      \- pkg.list_pkgs
      \- test.*
      \- apache.*
.ft P
.fi
.SS Target by Network
.sp
A new matcher has been added to the system which allows for minions to be
targeted by network. This new matcher can be called with the \fI\-S\fP flag on the
command line and is available in all places that the matcher system is
available. Using it is simple:
.sp
.nf
.ft C
$ salt \-S \(aq192.168.1.0/24\(aq test.ping
$ salt \-S \(aq192.168.1.100\(aq test.ping
.ft P
.fi
.SS Nodegroup Nesting
.sp
Previously a nodegroup was limited by not being able to include another
nodegroup, this restraint has been lifted and now nodegroups will be expanded
within other nodegroups with the \fIN@\fP classifier.
.SS Salt Key Delete by Glob
.sp
The ability to delete minion keys by glob has been added to \fBsalt\-key\fP.  To
delete all minion keys whose minion name starts with \(aqweb\(aq:
.sp
.nf
.ft C
$ salt\-key \-d \(aqweb*\(aq
.ft P
.fi
.SS Master Tops System
.sp
The \fIexternal_nodes\fP system has been upgraded to allow for modular subsystems
to be used to generate the top file data for a highstate run.
.sp
The \fIexternal_nodes\fP option still works but will be deprecated in the future in
favor of the new \fImaster_tops\fP option.
.sp
Example of using \fImaster_tops\fP:
.sp
.nf
.ft C
master_tops:
  ext_nodes: cobbler\-external\-nodes
.ft P
.fi
.SS Next Level Solaris Support
.sp
A lot of work has been put into improved Solaris support by Romeo Theriault.
Packaging modules (pkgadd/pkgrm and pkgutil) and states, cron support and user
and group management have all been added and improved upon. These additions
along with SMF (Service Management Facility) service support and improved
Solaris grain detection in 0.10.3 add up to Salt becoming a great tool
to manage Solaris servers with.
.SS Security
.sp
A vulnerability in the security handshake was found and has been repaired, old
minions should be able to connect to a new master, so as usual, the master
should be updated first and then the minions.
.SS Pillar Updates
.sp
The pillar communication has been updated to add some extra levels of
verification so that the intended minion is the only one allowed to gather the
data. Once all minions and the master are updated to salt 0.10.4 please
activate pillar \fI2\fP by changing the \fIpillar_version\fP in the master config to
\fI2\fP. This will be set to \fI2\fP by default in a future release.
.SS Salt 0.10.5 Release Notes
.sp
Salt 0.10.5 is ready, and comes with some great new features. A few more
interfaces have been modularized, like the outputter system. The job cache
system has been made more powerful and can now store and retrieve jobs archived
in external databases. The returner system has been extended to allow minions
to easily retrieve data from a returner interface.
.sp
As usual, this is an exciting release, with many noteworthy additions!
.SS Major Features
.SS External Job Cache
.sp
The external job cache is a system which allows for a returner interface to
also act as a job cache. This system is intended to allow users to store
job information in a central location for longer periods of time and to make
the act of looking up information from jobs executed on other minions easier.
.sp
Currently the external job cache is supported via the mongo and redis
returners:
.sp
.nf
.ft C
ext_job_cache: redis
redis.host: salt
.ft P
.fi
.sp
Once the external job cache is turned on the new \fIret\fP module can be used on
the minions to retrieve return information from the job cache. This can be a
great way for minions to respond and react to other minions.
.SS OpenStack Additions
.sp
OpenStack integration with Salt has been moving forward at a blistering pace.
The new \fInova\fP, \fIglance\fP and \fIkeystone\fP modules represent the beginning of
ongoing OpenStack integration.
.sp
The Salt team has had many conversations with core OpenStack developers and
is working on linking to OpenStack in powerful new ways.
.SS Wheel System
.sp
A new API was added to the Salt Master which allows the master to be managed
via an external API. This new system allows Salt API to easily hook into the
Salt Master and manage configs, modify the state tree, manage the pillar and
more. The main motivation for the wheel system is to enable features needed
in the upcoming web UI so users can manage the master just as easily as they
manage minions.
.sp
The wheel system has also been hooked into the external auth system. This
allows specific users to have granular access to manage components of the
Salt Master.
.SS Render Pipes
.sp
Jack Kuan has added a substantial new feature. The render pipes system allows
Salt to treat the render system like unix pipes. This new system enables sls
files to be passed through specific render engines. While the default renderer
is still recommended, different engines can now be more easily merged. So to
pipe the output of Mako used in YAML use this shebang line:
.sp
#!mako|yaml
.SS Salt Key Overhaul
.sp
The Salt Key system was originally developed as only a CLI interface, but as
time went on it was pressed into becoming a clumsy API. This release marks a
complete overhaul of Salt Key. Salt Key has been rewritten to function purely
from an API and to use the outputter system. The benefit here is that the
outputter system works much more cleanly with Salt Key now, and the internals
of Salt Key can be used much more cleanly.
.SS Modular Outputters
.sp
The outputter system is now loaded in a modular way. This means that output
systems can be more easily added by dropping a python file down on the master
that contains the function \fIoutput\fP.
.SS Gzip from Fileserver
.sp
Gzip compression has been added as an option to the cp.get_file and cp.get_dir
commands. This will make file transfers more efficient and faster, especially
over slower network links.
.SS Unified Module Configuration
.sp
In past releases of Salt, the minions needed to be configured for certain
modules to function. This was difficult because it required pre\-configuring the
minions. 0.10.5 changes this by making all module configs on minions search the
master config file for values.
.sp
Now if a single database server is needed, then it can be defined in the master
config and all minions will become aware of the configuration value.
.SS Salt Call Enhancements
.sp
The \fBsalt\-call\fP command has been updated in a few ways. Now, \fBsalt\-call\fP
can take the \-\-return option to send the data to a returner. Also,
\fBsalt\-call\fP now reports executions in the minion proc system, this allows the
master to be aware of the operation salt\-call is running.
.SS Death to pub_refresh and sub_timeout
.sp
The old configuration values \fIpub_refresh\fP and \fIsub_timeout\fP have been removed.
These options were in place to alleviate problems found in earlier versions of
ZeroMQ which have since been fixed. The continued use of these options has
proven to cause problems with message passing and have been completely removed.
.SS Git Revision Versions
.sp
When running Salt directly from git (for testing or development, of course)
it has been difficult to know exactly what code is being executed. The new
versioning system will detect the git revision when building and how many
commits have been made since the last release. A release from git will look
like this:
.sp
0.10.4\-736\-gec74d69
.SS Svn Module Addition
.sp
Anthony Cornehl (twinshadow) contributed a module that adds Subversion support
to Salt.  This great addition helps round out Salt\(aqs VCS support.
.SS Noteworthy Changes
.SS Arch Linux Defaults to Systemd
.sp
Arch Linux recently changed to use systemd by default and discontinued support
for init scripts. Salt has followed suit and defaults to systemd now for
managing services in Arch.
.SS Salt, Salt Cloud and Openstack
.sp
With the releases of Salt 0.10.5 and Salt Cloud 0.8.2, OpenStack becomes the
first (non\-OS) piece of software to include support both on the user level
(with Salt Cloud) and the admin level (with Salt). We are excited to continue
to extend support of other platforms at this level.
.SS Salt 0.11.0 Release Notes
.sp
Salt 0.11.0 is here, with some highly sought after and exciting features.
These features include the new overstate system, the reactor system, a new
state run scope component called __context__, the beginning of the search
system (still needs a great deal of work), multiple package states, the MySQL
returner and a better system to arbitrarily reference outputters.
.sp
It is also noteworthy that we are changing how we mark release numbers. For the
life of the project we have been pushing every release with features and fixes
as point releases. We will now be releasing point releases for only bug fixes
on a more regular basis and major feature releases on a slightly less regular
basis. This means that the next release will be a bugfix only release with a
version number of 0.11.1. The next feature release will be named 0.12.0 and
will mark the end of life for the 0.11 series.
.SS Major Features
.SS OverState
.sp
The overstate system is a simple way to manage rolling state executions across
many minions. The overstate allows for a state to depend on the successful
completion of another state.
.SS Reactor System
.sp
The new reactor system allows for a reactive logic engine to be created which
can respond to events within a salted environment. The reactor system uses sls
files to match events fired on the master with actions, enabling Salt
to react to problems in an infrastructure.
.sp
Your load\-balanced group of webservers is under extra load? Spin up a new VM
and add it to the group. Your fileserver is filling up? Send a notification to
your sysadmin on call. The possibilities are endless!
.SS Module Context
.sp
A new component has been added to the module loader system. The module context
is a data structure that can hold objects for a given scope within the module.
.sp
This allows for components that are initialized to be stored in a persistent
context which can greatly speed up ongoing connections. Right now the best
example can be found in the \fIcp\fP execution module.
.SS Multiple Package Management
.sp
A long desired feature has been added to package management. By definition Salt
States have always installed packages one at a time. On most platforms this is
not the fastest way to install packages. Erik Johnson, aka archtaku, has
modified the package modules for many providers and added new capabilities to
install groups of packages. These package groups can be defined as a list of
packages available in repository servers:
.sp
.nf
.ft C
python_pkgs:
  pkg.installed:
    \- pkgs:
      \- python\-mako
      \- whoosh
      \- python\-git
.ft P
.fi
.sp
or specify based on the location of specific packages:
.sp
.nf
.ft C
python_pkgs:
  pkg.installed:
    \- sources:
      \- python\-mako: http://some\-rpms.org/python\-mako.rpm
      \- whoosh: salt://whoosh/whoosh.rpm
      \- python\-git: ftp://companyserver.net/python\-git.rpm
.ft P
.fi
.SS Search System
.sp
The bones to the search system have been added. This is a very basic interface
that allows for search backends to be added as search modules. The first
supported search module is the whoosh search backend. Right now only the basic
paths for the search system are in place, making this very experimental.
Further development will involve improving the search routines and index
routines for whoosh and other search backends.
.sp
The search system has been made to allow for searching through all of the state
and pillar files, configuration files and all return data from minion
executions.
.SS Notable Changes
.sp
All previous versions of Salt have shared many directories between the master
and minion. The default locations for keys, cached data and sockets has been
shared by master and minion. This has created serious problems with running a
master and a minion on the same systems. 0.11.0 changes the defaults to be
separate directories. Salt will also attempt to migrate all of the old key data
into the correct new directories, but if it is not successful it may need to be
done manually. If your keys exhibit issues after updating make sure that they
have been moved from \fI/etc/salt/pki\fP to \fI/etc/salt/pki/{master,minion}\fP.
.sp
The old setup will look like this:
.sp
.nf
.ft C
/etc/salt/pki
|\-\- master.pem
|\-\- master.pub
|\-\- minions
|   \(ga\-\- ragnarok.saltstack.net
|\-\- minions_pre
|\-\- minion.pem
|\-\- minion.pub
|\-\- minion_master.pub
|\-\- minions_pre
\(ga\-\- minions_rejected
.ft P
.fi
.sp
With the accepted minion keys in /etc/salt/pki/minions, the new setup places the
accepted minion keys in /etc/salt/pki/master/minions
.sp
.nf
.ft C
/etc/salt/pki
|\-\- master
|   |\-\- master.pem
|   |\-\- master.pub
|   |\-\- minions
|   |   \(ga\-\- ragnarok.saltstack.net
|   |\-\- minions_pre
|   \(ga\-\- minions_rejected
|\-\- minion
|   |\-\- minion.pem
|   |\-\- minion.pub
|   \(ga\-\- minion_master.pub
.ft P
.fi
.SS Salt 0.12.0 Release Notes
.sp
Another feature release of Salt is here! Some exciting additions are included
with more ways to make salt modular and even easier management of the salt
file server.
.SS Major Features
.SS Modular Fileserver Backend
.sp
The new modular fileserver backend allows for any external system to be used as
a salt file server. The main benefit here is that it is now possible to tell
the master to directly use a git remote location, or many git remote locations,
automatically mapping git branches and tags to salt environments.
.SS Windows is First Class!
.sp
A new Salt Windows installer is now available! Much work has been put in to
improve Windows support. With this much easier method of getting Salt on your
Windows machines, we hope even more development and progress will occur. Please
file bug reports on the Salt github repo issue tracker so we can continue
improving.
.sp
One thing that is missing on Windows that Salt uses extensively is a software
package manager and a software package repository. The Salt pkg state allows
sys admins to install software across their infrastructure and across operating
systems. Software on Windows can now be managed in the same way. The SaltStack
team built a package manager that interfaces with the standard Salt pkg module
to allow for installing and removing software on Windows. In addition, a
software package repository has been built on top of the Salt fileserver. A
small YAML file provides the information necessary for the package manager to
install and remove software.
.sp
An interesting feature of the new Salt Windows software package repository is
that one or more remote git repositories can supplement the master\(aqs local
repository. The repository can point to software on the master\(aqs fileserver or
on an HTTP, HTTPS, or ftp server.
.SS New Default Outputter
.sp
Salt displays data to the terminal via the outputter system. For a long time
the default outputter for Salt has been the python pretty print library.  While
this has been a generally reasonable outputter, it did have many failings.  The
new default outputter is called "nested", it recursively scans return data
structures and prints them out cleanly.
.sp
If the result of the new nested outputter is not desired any other outputter
can be used via the \-\-out option, or the output option can be set in the master
and minion configs to change the default outputter.
.SS Internal Scheduler
.sp
The internal Salt scheduler is a new capability which allows for functions to
be executed at given intervals on the minion, and for runners to be executed
at given intervals on the master. The scheduler allows for sequences
such as executing state runs (locally on the minion or remotely via an
overstate) or continually gathering system data to be run at given intervals.
.sp
The configuration is simple, add the schedule option to the master or minion
config and specify jobs to run, this in the master config will execute the
state.over runner every 60 minutes:
.sp
.nf
.ft C
schedule:
  overstate:
    function: state.over
    minutes: 60
.ft P
.fi
.sp
This example for the minion configuration will execute a highstate every 30
minutes:
.sp
.nf
.ft C
schedule:
  highstate:
    function: state.highstate
    minutes: 30
.ft P
.fi
.SS Optional DSL for SLS Formulas
.sp
Jack Kuan, our renderer expert, has created something that is astonishing.
Salt, now comes with an optional Python based DSL, this is a very powerful
interface that makes writing SLS files in pure python easier than it was
with the raw py renderer. As usual this can be used with the renderer shebang
line, so a single sls can be written with the DSL if pure python power is
needed while keeping other sls files simple with YAML.
.SS Set Grains Remotely
.sp
A new execution function and state module have been added that allows for
grains to be set on the minion. Now grains can be set via a remote execution or
via states. Use the \fIgrains.present\fP state or the \fIgrains.setval\fP execution
functions.
.SS Gentoo Additions
.sp
Major additions to Gentoo specific components have been made. The encompasses
executions modules and states ranging from supporting the make.conf file to
tools like layman.
.SS Salt 0.13.0 Release Notes
.sp
The lucky number 13 has turned the corner! From CLI notifications when quitting
a salt command, to substantial improvements on Windows, Salt 0.13.0 has
arrived!
.SS Major Features
.SS Improved file.recurse Performance
.sp
The file.recurse system has been deployed and used in a vast array of
situations. Fixes to the file state and module have led towards opening up
new ways of running file.recurse to make it faster. Now the file.recurse
state will download fewer files and will run substantially faster.
.SS Windows Improvements
.sp
Minion stability on Windows has improved. Many file operations, including
file.recurse, have been fixed and improved. The network module works better, to
include network.interfaces. Both 32bit and 64bit installers are now available.
.SS Nodegroup Targeting in Peer System
.sp
In the past, nodegroups were not available for targeting via the peer system.
This has been fixed, allowing the new nodegroup expr_form argument for the
publish.publish function:
.INDENT 0.0
.INDENT 3.5
salt\-call publish.publish group1 test.ping expr_form=nodegroup
.UNINDENT
.UNINDENT
.SS Blacklist Additions
.sp
Additions allowing more granular blacklisting are available in 0.13.0. The
ability to blacklist users and functions in client_acl have been added, as
well as the ability to exclude state formulas from the command line.
.SS Command Line Pillar Embedding
.sp
Pillar data can now be embedded on the command line when calling \fBstate.sls\fP
and \fBstate.highstate\fP. This allows for on the fly changes or settings to
pillar and makes parameterizing state formulas even easier. This is done via
the keyword argument:
.INDENT 0.0
.INDENT 3.5
salt * state.highstate pillar=\(aq{"cheese": "spam"}\(aq
.UNINDENT
.UNINDENT
.sp
The above example will extend the existing pillar to hold the \fIcheese\fP key
with a value of \fIspam\fP. If the \fIcheese\fP key is already specified in the
minion\(aqs pillar then it will be overwritten.
.SS CLI Notifications
.sp
In the past hitting ctrl\-C and quitting from the \fBsalt\fP command would just
drop to a shell prompt, this caused confusion with users who expected the
remote executions to also quit. Now a message is displayed showing what
command can be used to track the execution and what the job id is for the
execution.
.SS Version Specification in Multiple\-Package States
.sp
Versions can now be specified within multiple\-package \fBpkg.installed\fP states. An example can be found below:
.sp
.nf
.ft C
mypkgs:
  pkg.installed:
    \- pkgs:
      \- foo
      \- bar: 1.2.3\-4
      \- baz
.ft P
.fi
.SS Noteworthy Changes
.sp
The configuration subsystem in Salt has been overhauled to make the \fBopts\fP
dict used by Salt applications more portable, the problem is that this is an
incompatible change with salt\-cloud, and salt\-cloud will need to be updated
to the latest git to work with Salt 0.13.0. Salt Cloud 0.8.5 will also require
Salt 0.13.0 or later to function.
.sp
The Salt Stack team is sorry for the inconvenience here, we work hard to make
sure these sorts of things do not happen, but sometimes hard changes get in.
.SS Salt 0.14.0 Release Notes
.sp
Salt 0.14.0 is here! This release was held up primarily by PyCon, Scale and
illness, but has arrived! 0.14.0 comes with many new features and is breaking
ground for Salt in the area of cloud management with the introduction of Salt
providing basic cloud controller functionality.
.SS Major Features
.SS Salt \- As a Cloud Controller
.sp
This is the first primitive inroad to using Salt as a cloud controller is
available in 0.14.0. Be advised that this is alpha, only tested in a few very
small environments.
.sp
The cloud controller is built using kvm and libvirt for the hypervisors.
Hypervisors are autodetected as minions and only need to have libvirt running
and kvm installed to function. The features of the Salt cloud controller are
as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Basic vm discovery and reporting
.IP \(bu 2
Creation of new virtual machines
.IP \(bu 2
Seeding virtual machines with Salt via qemu\-nbd or libguestfs
.IP \(bu 2
Live migration (shared and non shared storage)
.IP \(bu 2
Delete existing VMs
.UNINDENT
.UNINDENT
.UNINDENT
.sp
It is noteworthy that this feature is still Alpha, meaning that all rights
are reserved to change the interface if needs be in future releases!
.SS Libvirt State
.sp
One of the problems with libvirt is management of certificates needed for live
migration and cross communication between hypervisors. The new \fBlibvirt\fP
state makes the Salt Master hold a CA and manage the signing and distribution
of keys onto hypervisors, just add a call to the libvirt state in the sls
formulas used to set up a hypervisor:
.sp
.nf
.ft C
libvirt_keys:
  libvirt.keys
.ft P
.fi
.SS New get Functions
.sp
An easier way to manage data has been introduced. The pillar, grains and config
execution modules have been extended with the new \fBget\fP function. This
function works much in the same way as the get method in a python dict, but with
an enhancement, nested dict components can be extracted using a \fI:\fP delimiter.
.sp
If a structure like this is in pillar:
.sp
.nf
.ft C
foo:
  bar:
    baz: quo
.ft P
.fi
.sp
Extracting it from the raw pillar in an sls formula or file template is done
this way:
.sp
.nf
.ft C
{{ pillar[\(aqfoo\(aq][\(aqbar\(aq][\(aqbaz\(aq] }}
.ft P
.fi
.sp
Now with the new get function the data can be safely gathered and a default
can be set allowing the template to fall back if the value is not available:
.sp
.nf
.ft C
{{ salt[\(aqpillar.get\(aq](\(aqfoo:bar:baz\(aq, \(aqqux\(aq) }}
.ft P
.fi
.sp
This makes handling nested structures much easier, and defaults can be cleanly
set. This new function is being used extensively in the new formulae repository
of salt sls formulas.
.SS Salt 0.15.0 Release Notes
.sp
The many new features of Salt 0.15.0 have arrived! Salt 0.15.0 comes with many
smaller features and a few larger ones.
.sp
These features range from better debugging tools to the new Salt Mine system.
.SS Major Features
.SS The Salt Mine
.sp
First there was the peer system, allowing for commands to be executed from a
minion to other minions to gather data live. Then there was the external job
cache for storing and accessing long term data. Now the middle ground is being
filled in with the Salt Mine. The Salt Mine is a system used to execute
functions on a regular basis on minions and then store only the most recent
data from the functions on the master, then the data is looked up via targets.
.sp
The mine caches data that is public to all minions, so when a minion posts
data to the mine all other minions can see it.
.SS IPV6 Support
.sp
0.13.0 saw the addition of initial IPV6 support but errors were encountered and
it needed to be stripped out. This time the code covers more cases and must be
explicitly enabled. But the support is much more extensive than before.
.SS Copy Files From Minions to the Master
.sp
Minions have long been able to copy files down from the master file server, but
until now files could not be easily copied from the minion up to the master.
.sp
A new function called \fBcp.push\fP can push files from the minions up to the
master server. The uploaded files are then cached on the master in the master
cachedir for each minion.
.SS Better Template Debugging
.sp
Template errors have long been a burden when writing states and pillar. 0.15.0
will now send the compiled template data to the debug log, this makes tracking
down the intermittent stage templates much easier. So running state.sls or
state.highstate with \fI\-l debug\fP will now print out the rendered templates in
the debug information.
.SS State Event Firing
.sp
The state system is now more closely tied to the master\(aqs event bus. Now when
a state fails the failure will be fired on the master event bus so that the
reactor can respond to it.
.SS Major Syndic Updates
.sp
The Syndic system has been basically re\-written. Now it runs in a completely
asynchronous way and functions primarily as an event broker. This means that
the events fired on the syndic are now pushed up to the higher level master
instead of the old method used which waited for the client libraries to
return.
.sp
This makes the syndic much more accurate and powerful, it also means that
all events fired on the syndic master make it up the pipe as well making a
reactor on the higher level master able to react to minions further
downstream.
.SS Peer System Updates
.sp
The Peer System has been updated to run using the client libraries instead
of firing directly over the publish bus. This makes the peer system much more
consistent and reliable.
.SS Minion Key Revocation
.sp
In the past when a minion was decommissioned the key needed to be manually
deleted on the master, but now a function on the minion can be used to revoke
the calling minion\(aqs key:
.sp
.nf
.ft C
$ salt\-call saltutil.revoke_auth
.ft P
.fi
.SS Function Return Codes
.sp
Functions can now be assigned numeric return codes to determine if the function
executed successfully. While not all functions have been given return codes,
many have and it is an ongoing effort to fill out all functions that might
return a non\-zero return code.
.SS Functions in Overstate
.sp
The overstate system was originally created to just manage the execution of
states, but with the addition of return codes to functions, requisite logic can
now be used with respect to the overstate. This means that an overstate stage
can now run single functions instead of just state executions.
.SS Pillar Error Reporting
.sp
Previously if errors surfaced in pillar, then the pillar would consist of only
an empty dict. Now all data that was successfully rendered stays in pillar and
the render error is also made available. If errors are found in the pillar,
states will refuse to run.
.SS Using Cached State Data
.sp
Sometimes states are executed purely to maintain a specific state rather than
to update states with new configs. This is grounds for the new cached state
system. By adding \fIcache=True\fP to a state call the state will not be generated
fresh from the master but the last state data to be generated will be used.
If no previous state data is available then fresh data will be generated.
.SS Monitoring States
.sp
The new monitoring states system has been started. This is very young but
allows for states to be used to configure monitoring routines. So far only one
monitoring state is available, the \fBdisk.status\fP state. As more capabilities
are added to Salt UI the monitoring capabilities of Salt will continue to be
expanded.
.SS Salt 0.15.1 Release Notes
.sp
The 0.15.1 release has been posted, this release includes fixes to a number of
bugs in 0.15.1 and a three security patches.
.SS Security Updates
.sp
A number of security issues have been resolved via the 0.15.1 release.
.SS Path Injection in Minion IDs
.sp
Salt masters did not properly validate the id of a connecting minion. This can
lead to an attacker uploading files to the master in arbitrary locations.
In particular this can be used to bypass the manual validation of new unknown
minions. Exploiting this vulnerability does not require authentication.
.sp
This issue affects all known versions of Salt.
.sp
This issue was reported by Ronald Volgers.
.SS Patch
.sp
The issue is fixed in Salt 0.15.1. Updated packages are available in the usual
locations.
.sp
Specific commits:
.sp
\fI\%https://github.com/saltstack/salt/commit/5427b9438e452a5a8910d9128c6aafb45d8fd5d3\fP
.sp
\fI\%https://github.com/saltstack/salt/commit/7560908ee62351769c3cd43b03d74c1ca772cc52\fP
.sp
\fI\%https://github.com/saltstack/salt/commit/e200b8a7ff53780124e08d2bdefde7587e52bfca\fP
.SS RSA Key Generation Fault
.sp
RSA key generation was done incorrectly, leading to very insecure keys. It is
recommended to regenerate all RSA keys.
.sp
This issue can be used to impersonate Salt masters or minions, or decrypt any
transferred data.
.sp
This issue can only be exploited by attackers who are able to observe or modify
traffic between Salt minions and the legitimate Salt master.
.sp
A tool was included in 0.15.1 to assist in mass key regeneration, the
manage.regen_keys runner.
.sp
This issue affects all known versions of Salt.
.sp
This issue was reported by Ronald Volgers.
.SS Patch
.sp
The issue is fixed in Salt 0.15.1. Updated packages are available in the usual
locations.
.sp
Specific commits:
.sp
\fI\%https://github.com/saltstack/salt/commit/5dd304276ba5745ec21fc1e6686a0b28da29e6fc\fP
.SS Command Injection Via ext_pillar
.sp
Arbitrary shell commands could be executed on the master by an authenticated
minion through options passed when requesting a pillar.
.sp
Ext pillar options have been restricted to only allow safe external pillars to
be called when prompted by the minion.
.sp
This issue affects Salt versions from 0.14.0 to 0.15.0.
.sp
This issue was reported by Ronald Volgers.
.SS Patch
.sp
The issue is fixed in Salt 0.15.1. Updated packages are available in the usual locations.
.sp
Specific commits:
.sp
\fI\%https://github.com/saltstack/salt/commit/43d8c16bd26159d827d1a945c83ac28159ec5865\fP
.SS Salt 0.16.0 Release Notes
.sp
The 0.16.0 release is an exciting one, with new features in master redundancy,
and a new, powerful requisite.
.SS Major Features
.SS Multi\-Master
.sp
This new capability allows for a minion to be actively connected to multiple
salt masters at the same time. This allows for multiple masters to send out commands
to minions and for minions to automatically reconnect to masters that have gone
down. A tutorial is available to help get started here:
.sp
\fBMulti Master Tutorial\fP
.SS Prereq, the New Requisite
.sp
The new \fIprereq\fP requisite is very powerful! It allows for states to execute
based on a state that is expected to make changes in the future. This allows
for a change on the system to be preempted by another execution. A good example
is needing to shut down a service before modifying files associated with it,
allowing, for instance, a webserver to be shut down allowing a load balancer to
stop sending requests while server side code is updated. In this case, the
prereq will only run if changes are expected to happen in the prerequired
state, and the prerequired state will always run after the prereq state and
only if the prereq state succeeds.
.SS Peer System Improvements
.sp
The peer system has been revamped to make it more reliable, faster, and like
the rest of Salt, async. The peer calls when an updated minion and master are
used together will be much faster!
.SS Relative Includes
.sp
The ability to include an sls relative to the defined sls has been added, the
new syntax id documented here:
.sp
\fBIncludes\fP
.SS More State Output Options
.sp
The \fBstate_output\fP option in the past only supported \fIfull\fP and \fIterse\fP,
0.16.0 add the \fImixed\fP and \fIchanges\fP modes further refining how states are sent
to users\(aq eyes.
.SS Improved Windows Support
.sp
Support for Salt on Windows continues to improve. Software management on
Windows has become more seamless with Linux/UNIX/BSD software management.
Installed software is now recognized by the short names defined in the
\fBrepository SLS\fP. This makes it possible to
run \fBsalt \(aq*\(aq pkg.version firefox\fP and get back results from Windows and
non\-Windows minions alike.
.sp
When templating files on Windows, Salt will now correctly use Windows
appropriate line endings. This makes it much easier to edit and consume files
on Windows.
.sp
When using the cmd state the \fBshell\fP option now allows for specifying
Windows Powershell as an alternate shell to execute cmd.run and cmd.script.
This opens up Salt to all the power of Windows Powershell and its advanced
Windows management capabilities.
.sp
Several fixes and optimizations were added for the Windows networking modules,
especially when working with IPv6.
.sp
A system module was added that makes it easy to restart and shutdown Windows
minions.
.sp
The Salt Minion will now look for its config file in \fBc:\esalt\econf\fP by
default. This means that it\(aqs no longer necessary to specify the \fB\-c\fP option
to specify the location of the config file when starting the Salt Minion on
Windows in a terminal.
.SS Muliple Targets for pkg.removed, pkg.purged States
.sp
Both \fBpkg.removed\fP and \fBpkg.purged\fP now support the \fBpkgs\fP argument, which allow for
multiple packages to be targeted in a single state. This, as in
\fBpkg.installed\fP, helps speed up these
states by reducing the number of times that the package management tools (apt,
yum, etc.) need to be run.
.SS Random Times in Cron States
.sp
The temporal parameters in \fBcron.present\fP
states (minute, hour, etc.) can now be randomized by using \fBrandom\fP instead
of a specific value. For example, by using the \fBrandom\fP keyword in the
\fBminute\fP parameter of a cron state, the same cron job can be pushed to
hundreds or thousands of hosts, and they would each use a randomly\-generated
minute. This can be helpful when the cron job accesses a network resource, and
it is not desirable for all hosts to run the job concurrently.
.sp
.nf
.ft C
/path/to/cron/script:
  cron.present:
    \- user: root
    \- minute: random
    \- hour: 2
.ft P
.fi
.sp
Since Salt assumes a value of \fB*\fP for unspecified temporal parameters, adding
a parameter to the state and setting it to \fBrandom\fP will change that value
from \fB*\fP to a randomized numeric value. However, if that field in the cron
entry on the minion already contains a numeric value, then using the \fBrandom\fP
keyword will not modify it.
.SS Confirmation Prompt on Key Acceptance
.sp
When accepting new keys with \fBsalt\-key \-a minion\-id\fP or \fBsalt\-key \-A\fP,
there is now a prompt that will show the affected keys and ask for confirmation
before proceeding. This prompt can be bypassed using the \fB\-y\fP or \fB\-\-yes\fP
command line argument, as with other \fBsalt\-key\fP commands.
.SS Support for Setting Password Hashes on BSD Minions
.sp
FreeBSD, NetBSD, and OpenBSD all now support setting passwords in
\fBuser.present\fP states.
.SS Salt 0.6.0 release notes
.sp
The Salt remote execution manager has reached initial functionality! Salt is a
management application which can be used to execute commands on remote sets of
servers.
.sp
The whole idea behind Salt is to create a system where a group of servers can
be remotely controlled from a single master, not only can commands be executed
on remote systems, but salt can also be used to gather information about your
server environment.
.sp
Unlike similar systems, like Func and MCollective, Salt is extremely simple to
setup and use, the entire application is contained in a single package, and the
master and minion daemons require no running dependencies in the way that Func
requires Certmaster and MCollective requires activeMQ.
.sp
Salt also manages authentication and encryption. Rather than using SSL for
encryption, salt manages encryption on a payload level, so the data sent across
the network is encrypted with fast AES encryption, and authentication uses RSA
keys. This means that Salt is fast, secure, and very efficient.
.sp
Messaging in Salt is executed with ZeroMQ, so the message passing interface is
built into salt and does not require an external ZeroMQ server. This also adds
speed to Salt since there is no additional bloat on the networking layer, and
ZeroMQ has already proven itself as a very fast networking system.
.sp
The remote execution in Salt is "Lazy Execution", in that once the command is
sent the requesting network connection is closed. This makes it easier to
detach the execution from the calling process on the master, it also means that
replies are cached, so that information gathered from historic commands can be
queried in the future.
.sp
Salt also allows users to make execution modules in Python. Writers of these
modules should also be pleased to know that they have access to the impressive
information gathered from PuppetLabs\(aq Facter application, making Salt module
more flexible. In the future I hope to also allow Salt to group servers based
on Facter information as well.
.sp
All in all Salt is fast, efficient and clean, can be used from a simple command
line client or through an API, uses message queue technology to make network
execution extremely fast, and encryption is handled in a very fast and
efficient manner. Salt is also VERY easy to use and VERY easy to extend.
.sp
You can find the source code for Salt on my github page, I have also set up a
few wiki pages explaining how to use and set up Salt. If you are using Arch
Linux there is a package available in the Arch Linux AUR.
.sp
Salt 0.6.0 Source: \fI\%https://github.com/downloads/saltstack/salt/salt-0.6.0.tar.gz\fP
.sp
Github page: \fI\%https://github.com/saltstack/salt\fP
.sp
Wiki: \fI\%https://github.com/saltstack/salt/wiki\fP
.sp
Arch Linux Package: \fI\%https://aur.archlinux.org/packages.php?ID=47512\fP
.sp
I am very open to contributions, for instance I need packages for more Linux
distributions as well as BSD packages and testers.
.sp
Give Salt a try, this is the initial release and is not a 1.0 quality release,
but it has been working well for me! I am eager to get your feedback!
.SS Salt 0.7.0 release notes
.sp
I am pleased to announce the release of Salt 0.7.0!
.sp
This release marks what is the first stable release of salt, 0.7.0 should be
suitable for general use.
.sp
0.7.0 Brings the following new features to Salt:
.INDENT 0.0
.IP \(bu 2
Integration with Facter data from puppet labs
.IP \(bu 2
Allow for matching minions from the salt client via Facter information
.IP \(bu 2
Minion job threading, many jobs can be executed from the master at once
.IP \(bu 2
Preview of master clustering support \- Still experimental
.IP \(bu 2
Introduce new minion modules for stats, virtualization, service management and more
.IP \(bu 2
Add extensive logging to the master and minion daemons
.IP \(bu 2
Add sys.reload_functions for dynamic function reloading
.IP \(bu 2
Greatly improve authentication
.IP \(bu 2
Introduce the saltkey command for managing public keys
.IP \(bu 2
Begin backend development preparatory to introducing butter
.IP \(bu 2
Addition of man pages for the core commands
.IP \(bu 2
Extended and cleaned configuration
.UNINDENT
.sp
0.7.0 Fixes the following major bugs:
.INDENT 0.0
.IP \(bu 2
Fix crash in minions when matching failed
.IP \(bu 2
Fix configuration file lookups for the local client
.IP \(bu 2
Repair communication bugs in encryption
.IP \(bu 2
Numerous fixes in the minion modules
.UNINDENT
.sp
The next release of Salt should see the following features:
.INDENT 0.0
.IP \(bu 2
Stabilize the cluster support
.IP \(bu 2
Introduce a remote client for salt command tiers
.IP \(bu 2
salt\-ftp system for distributed file copies
.IP \(bu 2
Initial support for "butter"
.UNINDENT
.sp
Coming up next is a higher level management framework for salt called
Butter. I want salt to stay as a simple and effective communication
framework, and allow for more complicated executions to be managed via
Butter.
.sp
Right now Butter is being developed to act as a cloud controller using salt
as the communication layer, but features like system monitoring and advanced
configuration control (a puppet manager) are also in the pipe.
.sp
Special thanks to Joseph Hall for the status and network modules, and thanks
to Matthias Teege for tracking down some configuration bugs!
.sp
Salt can be downloaded from the following locations;
.sp
Source Tarball:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.7.0.tar.gz\fP
.sp
Arch Linux Package:
.sp
\fI\%https://aur.archlinux.org/packages.php?ID=47512\fP
.sp
Please enjoy the latest Salt release!
.SS Salt 0.8.0 release notes
.sp
Salt 0.8.0 is ready for general consumption!
The source tarball is available on github for download:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.8.0.tar.gz\fP
.sp
A lot of work has gone into salt since the last release just 2 weeks ago, and
salt has improved a great deal. A swath of new features are here along with
performance and threading improvements!
.sp
The main new features of salt 0.8.0 are:
.sp
Salt\-cp
.sp
Cython minion modules
.sp
Dynamic returners
.sp
Faster return handling
.sp
Lowered required Python version to 2.6
.sp
Advanced minion threading
.sp
Configurable minion modules
.SS Salt\-cp \-
.sp
The salt\-cp command introduces the ability to copy simple files via salt to
targeted servers. Using salt\-cp is very simple, just call salt\-cp with a target
specification, the source file(s) and where to copy the files on the minions.
For instance:
.sp
# salt\-cp â€˜*â€™ /etc/hosts /etc/hosts
.sp
Will copy the local /etc/hosts file to all of the minions.
.sp
Salt\-cp is very young, in the future more advanced features will be added, and
the functionality will much more closely resemble the cp command.
.SS Cython minion modules \-
.sp
Cython is an amazing tool used to compile Python modules down to c. This is
arguably the fastest way to run Python code, and since pyzmq requires cython,
adding support to salt for cython adds no new dependencies.
.sp
Cython minion modules allow minion modules to be written in cython and
therefore executed in compiled c. Simply write the salt module in cython and
use the file extension â€œ.pyxâ€ and the minion module will be compiled when
the minion is started. An example cython module is included in the main
distribution called cytest.pyx:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules/cytest.pyx\fP
.SS Dynamic Returners \-
.sp
By default salt returns command data back to the salt master, but now salt can
return command data to any system. This is enabled via the new returners
modules feature for salt. The returners modules take the return data and sends
it to a specific module. The returner modules work like minion modules, so any
returner can be added to the minions.
.sp
This means that a custom data returner can be added to communicate the return
data so anything from MySQL, Redis, MongoDB and more!
.sp
There are 2 simple stock returners in the returners directory:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/returners\fP
.sp
The documentation on writing returners will be added to the wiki shortly, and
returners can be written in pure Python, or in cython.
.SS Configurable Minion Modules \-
.sp
Minion modules may need to be configured, now the options passed to the minion
configuration file can be accessed inside of the minion modules via the __opt__
dict.
.sp
Information on how to use this simple addition has been added to the wiki:
\fI\%https://github.com/thatch45/salt/wiki/Writing-Salt-Modules\fP
.sp
The test module has an example of using the __opts__ dict, and how to set
default options:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/modules/test.py\fP
.SS Advanced Minion Threading:
.sp
In 0.7.0 the minion would block after receiving a command from the master, now
the minion will spawn a thread or multiprocess. By default Python threads are
used because for general use they have proved to be faster, but the minion can
now be configured to use the Python multiprocessing module instead. Using
multiprocessing will cause executions that are CPU bound or would otherwise
exploit the negative aspects of the Python GIL to run faster and more reliably,
but simple calls will still be faster with Python threading.
The configuration option can be found in the minion configuration file:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/conf/minion\fP
.sp
Lowered Supported Python to 2.6 \-
.sp
The requirement for Python 2.7 has been removed to support Python 2.6. I have
received requests to take the minimum Python version back to 2.4, but
unfortunately this will not be possible, since the ZeroMQ Python bindings do
not support Python 2.4.
.sp
Salt 0.8.0 is a very major update, it also changes the network protocol slightly
which makes communication with older salt daemons impossible, your master and
minions need to be upgraded together!
I could use some help bringing salt to the people! Right now I only have
packages for Arch Linux, Fedora 14 and Gentoo. We need packages for Debian and
people willing to help test on more platforms. We also need help writing more
minion modules and returner modules. If you want to contribute to salt please
hop on the mailing list and send in patches, make a fork on github and send in
pull requests! If you want to help but are not sure where you can, please email
me directly or post tot he mailing list!
.sp
I hope you enjoy salt, while it is not yet 1.0 salt is completely viable and
usable!
.sp
\-Thomas S. Hatch
.SS Salt 0.8.7 release notes
.sp
It has been a month since salt 0.8.0, and it has been a long month! But Salt is
still coming along strong. 0.8.7 has a lot of changes and a lot of updates.
This update makes Saltâ€™s ZeroMQ back end better, strips Facter from the
dependencies, and introduces interfaces to handle more capabilities.
.sp
Many of the major updates are in the background, but the changes should shine
through to the surface. A number of the new features are still a little thin,
but the back end to support expansion is in place.
.sp
I also recently gave a presentation to the Utah Python users group in Salt Lake
City, the slides from this presentation are available here:
\fI\%https://github.com/downloads/saltstack/salt/Salt.pdf\fP
.sp
The video from this presentation will be available shortly.
.sp
The major new features and changes in Salt 0.8.7 are:
.INDENT 0.0
.IP \(bu 2
Revamp ZeroMQ topology on the master for better scalability
.IP \(bu 2
State enforcement
.IP \(bu 2
Dynamic state enforcement managers
.IP \(bu 2
Extract the module loader into salt.loader
.IP \(bu 2
Make Job ids more granular
.IP \(bu 2
Replace Facter functionality with the new salt grains interface
.IP \(bu 2
Support for â€œvirtualâ€ salt modules
.IP \(bu 2
Introduce the salt\-call command
.IP \(bu 2
Better debugging for minion modules
.UNINDENT
.sp
The new ZeroMQ topology allows for better scalability, this will be required by
the need to execute massive file transfers to multiple machines in parallel and
state management. The new ZeroMQ topology is available in the aforementioned
presentation.
.sp
0.8.7 introduces the capability to declare states, this is similar to the
capabilities of Puppet. States in salt are declared via state data structures.
This system is very young, but the core feature set is available. Salt states
work around rendering files which represent Salt high data. More on the Salt
state system will be documented in the near future.
.sp
The system for loading salt modules has been pulled out of the minion class to
be a standalone module, this has enabled more dynamic loading of Salt modules
and enables many of the updates in 0.8.7 â€“
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/loader.py\fP
.sp
Salt Job ids are now microsecond precise, this was needed to repair a race
condition unveiled by the speed improvements in the new ZeroMQ topology.
.sp
The new grains interface replaces the functionality of Facter, the idea behind
grains differs from Facter in that the grains are only used for static system
data, dynamic data needs to be derived from a call to a salt module. This makes
grains much faster to use, since the grains data is generated when the minion
starts.
.sp
Virtual salt modules allows for a salt module to be presented as something
other than its module name. The idea here is that based on information from the
minion decisions about which module should be presented can be made. The best
example is the pacman module. The pacman module will only load on Arch Linux
minions, and will be called pkg. Similarly the yum module will be presented as
pkg when the minion starts on a Fedora/RedHat system.
.sp
The new salt\-call command allows for minion modules to be executed from the
minion. This means that on the minion a salt module can be executed, this is a
great tool for testing Salt modules. The salt\-call command can also be used to
view the grains data.
.sp
In previous releases when a minion module threw an exception very little data
was returned to the master. Now the stack trace from the failure is returned
making debugging of minion modules MUCH easier.
.sp
Salt is nearing the goal of 1.0, where the core feature set and capability is
complete!
.sp
Salt 0.8.7 can be downloaded from github here:
\fI\%https://github.com/downloads/saltstack/salt/salt-0.8.7.tar.gz\fP
.sp
\-Thomas S Hatch
.SS Salt 0.8.8 release notes
.sp
Salt 0.8.8 is here! This release adds a great deal of code and some serious new
features. The latest release can be downloaded here:
\fI\%https://github.com/downloads/saltstack/salt/salt-0.8.8.tar.gz\fP
.sp
Improved Documentation has been set up for salt using sphinx thanks to the
efforts of Seth House. This new documentation system will act as the back end
to the salt website which is still under heavy development. The new sphinx
documentation system has also been used to greatly clean up the salt manpages.
The salt 7 manpage in particular now contains extensive information which was
previously only in the wiki. The new documentation can be found at:
\fI\%http://thatch45.github.com/salt-www/\fP
We still have a lot to add, and when the domain is set up I will post another
announcement.
.sp
More additions have been made to the ZeroMQ setup, particularly in the realm
of file transfers. Salt 0.8.8 introduces a built in, stateless, encrypted file
server which allows salt minions to download files from the salt master using
the same encryption system used for all other salt communications. The main
motivation for the salt file server has been to facilitate the new salt state
system.
.sp
Much of the salt code has been cleaned up and a new cleaner logging system has
been introduced thanks to the efforts of Pedro Algarvio. These additions will
allow for much more flexible logging to be executed by salt, and fixed a great
deal of my poor spelling in the salt docstrings! Pedro Algarvio has also
cleaned up the API, making it easier to embed salt into another application.
.sp
The biggest addition to salt found in 0.8.8 is the new state system. The salt
module system has received a new front end which allows salt to be used as a
configuration management system. The configuration management system allows for
system configuration to be defined in data structures. The configuration
management system, or as it is called in salt, the â€œsalt state systemâ€ supports
many of the features found in other configuration managers, but allows for
system states to be written in a far simpler format, executes at blazing speeds,
and operates via the salt minion matching system. The state system also operates
within the normal scope of salt, and requires no additional configuration to
use.
.sp
The salt state system can enforce the following states with many more to come:
Packages
Files
Services
Executing commands
Hosts
.sp
The system used to define the salt states is based on a data structure, the
data structure used to define the salt states has been made to be as easy to
use as possible. The data structure is defined by default using a YAML file
rendered via a Jinja template. This means that the state definition language
supports all of the data structures that YAML supports, and all of the
programming constructs and logic that Jinja supports. If the user does not
like YAML or Jinja the states can be defined in yaml\-mako, json\-jinja, or
json\-mako. The system used to render the states is completely dynamic, and any
rendering system can be added to the capabilities of Salt, this means that a
rendering system that renders XML data in a cheetah template, or whatever you
can imagine, can be easily added to the capabilities of salt.
.sp
The salt state system also supports isolated environments, as well as matching
code from several environments to a single salt minion.
.sp
The feature base for Salt has grown quite a bit since my last serious
documentation push. As we approach 0.9.0 the goals are becoming very clear, and
the documentation needs a lot of work. The main goals for 0.9.0 are to further
refine the state system, fix any bugs we find, get Salt running on as many
platforms as we can, and get the documentation filled out. There is a lot more
to come as Salt moves forward to encapsulate a much larger scope, while
maintaining supreme usability and simplicity.
.sp
If you would like a more complete overview of Salt please watch the Salt
presentation:
Flash Video:
\fI\%http://blip.tv/thomas-s-hatch/salt-0-8-7-presentation-5180182\fP
OGV Video Download:
\fI\%http://blip.tv/file/get/Thatch45-Salt087Presentation416.ogv\fP
Slides:
\fI\%https://github.com/downloads/saltstack/salt/Salt.pdf\fP
.sp
\-Thomas S Hatch
.SS Salt 0.8.9 Release Notes
.sp
Salt 0.8.9 has finally arrived! Unfortunately this is much later than I had
hoped to release 0.8.9, life has been very crazy over the last month. But
despite challenges, Salt has moved forward!
.sp
This release, as expected, adds few new features and many refinements. One
of the most exciting aspect of this release is that the development community
for salt has grown a great deal and much of the code is from contributors.
.sp
Also, I have filled out the documentation a great deal. So information on
States is properly documented, and much of the documentation that was out of
date has been filled in.
.SS Download!
.sp
The Salt source can be downloaded from the salt github site:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.8.9.tar.gz\fP
.sp
Or from PyPI:
.sp
\fI\%http://pypi.python.org/packages/source/s/salt/salt-0.8.9.tar.gz\fP
.sp
Here s the md5sum:
.sp
7d5aca4633bc22f59045f59e82f43b56
.sp
For instructions on how to set up Salt please see the \fIinstallation\fP
instructions.
.SS New Features
.SS Salt Run
.sp
A big feature is the addition of Salt run, the \fBsalt\-run\fP command allows for
master side execution modules to be made that gather specific information or
execute custom routines from the master.
.sp
Documentation for salt\-run can be found here:
.sp
\fI\%http://saltstack.org/ref/runners.html\fP
.SS Refined Outputters
.sp
One problem often complained about in salt was the fact that the output was
so messy. Thanks to help from Jeff Schroeder a cleaner interface for the
command output for the Salt CLI has been made. This new interface makes
adding new printout formats easy and additions to the capabilities of minion
modules makes it possible to set the printout mode or \fBoutputter\fP for
functions in minion modules.
.SS Cross Calling Salt Modules
.sp
Salt modules can now call each other, the \fB__salt__\fP dict has been added to
the predefined references in minion modules. This new feature is documented in
the modules documentation:
.sp
\fI\%http://saltstack.org/ref/modules/index.html\fP
.SS Watch Option Added to Salt State System
.sp
Now in Salt states you can set the watch option, this will allow watch enabled
states to change based on a change in the other defined states. This is similar
to subscribe and notify statements in puppet.
.SS Root Dir Option
.sp
Travis Cline has added the ability to define the option \fBroot_dir\fP which
allows the salt minion to operate in a subdir. This is a strong move in
supporting the minion running as an unprivileged user
.SS Config Files Defined in Variables
.sp
Thanks again to Travis Cline, the master and minion configuration file locations
can be defined in environment variables now.
.SS New Modules
.sp
Quite a few new modules, states, returners and runners have been made.
.SS New Minion Modules
.SS apt
.sp
Support for apt\-get has been added, this adds greatly improved Debian and
Ubuntu support to Salt!
.SS useradd and groupadd
.sp
Support for manipulating users and groups on Unix\-like systems.
.SS moosefs
.sp
Initial support for reporting on aspects of the distributed file system,
MooseFS. For more information on MooseFS please see: \fI\%http://moosefs.org\fP
.sp
Thanks to Joseph Hall for his work on MooseFS support.
.SS mount
.sp
Manage mounts and the fstab.
.SS puppet
.sp
Execute puppet on remote systems.
.SS shadow
.sp
Manipulate and manage the user password file.
.SS ssh
.sp
Interact with ssh keys.
.SS New States
.SS user and group
.sp
Support for managing users and groups in Salt States.
.SS mount
.sp
Enforce mounts and the fstab.
.SS New Returners
.SS mongo_return
.sp
Send the return information to a MongoDB server.
.SS New Runners
.SS manage
.sp
Display minions that are up or down.
.SS Salt 0.9.0 Release Notes
.sp
Salt 0.9.0 is here. This is an exciting release, 0.9.0 includes the new network
topology features allowing peer salt commands and masters of masters via the
syndic interface.
.sp
0.9.0 also introduces many more modules, improvements to the API and
improvements to the ZeroMQ systems.
.SS Download!
.sp
The Salt source can be downloaded from the salt github site:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.9.0.tar.gz\fP
.sp
Or from PyPI:
.sp
\fI\%http://pypi.python.org/packages/source/s/salt/salt-0.9.0.tar.gz\fP
.sp
Here is the md5sum:
.sp
9a925da04981e65a0f237f2e77ddab37
.sp
For instructions on how to set up Salt please see the \fIinstallation\fP
instructions.
.SS New Features
.SS Salt Syndic
.sp
The new Syndic interface allows a master to be commanded via another higher
level salt master. This is a powerful solution allowing a master control
structure to exist, allowing salt to scale to much larger levels then before.
.sp
\fI\%http://saltstack.org/ref/syndic.html\fP
.SS Peer Communication
.sp
0.9.0 introduces the capability for a minion to call a publication on the
master and receive the return from another set of minions. This allows salt
to act as a communication channel between minions and as a general
infrastructure message bus.
.sp
Peer communication is turned off by default but can be enabled via the \fBpeer\fP
option in the master configuration file. Documentation on the new peer
interface can be found here:
.sp
\fI\%http://saltstack.org/ref/peer.html\fP
.SS Easily Extensible API
.sp
The minion and master classes have been redesigned to allow for specialized
minion and master servers to be easily created. An example on how this is done
for the master can be found in the \fBmaster.py\fP salt module:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/master.py\fP
.sp
The \fBMaster\fP class extends the \fBSMaster\fP class and set up the main master
server.
.sp
The minion functions can now also be easily added to another application via
the \fBSMinion\fP class, this class can be found in the \fBminion.py\fP module:
.sp
\fI\%https://github.com/saltstack/salt/blob/develop/salt/minion.py\fP
.SS Cleaner Key Management
.sp
This release changes some of the key naming to allow for multiple master keys
to be held based on the type of minion gathering the master key.
.sp
The \-d option has also been added to the salt\-key command allowing for easy
removal of accepted public keys.
.sp
The \-\-gen\-keys option is now available as well for salt\-key, this allows
for a salt specific RSA key pair to be easily generated from the command line.
.SS Improved 0MQ Master Workers
.sp
The 0MQ worker system has been further refined to be faster and more robust.
This new system has been able to handle a much larger load than the previous
setup. The new system uses the IPC protocol in 0MQ instead of TCP.
.SS New Modules
.sp
Quite a few new modules have been made.
.SS New Minion Modules
.SS apache
.sp
Work directly with apache servers, great for managing balanced web servers
.SS cron
.sp
Read out the contents of a systems crontabs
.SS mdadm
.sp
Module to manage raid devices in Linux, appears as the \fBraid\fP module
.SS mysql
.sp
Gather simple data from MySQL databases
.SS ps
.sp
Extensive utilities for managing processes
.SS publish
.sp
Used by the peer interface to allow minions to make publications
.SS Salt 0.9.2 Release Notes
.sp
Salt 0.9.2 has arrived! 0.9.2 is primarily a bugfix release, the exciting
component in 0.9.2 is greatly improved support for salt states. All of the
salt states interfaces have been more thoroughly tested and the new salt\-states
git repo is growing with example of how to use states.
.sp
This release introduces salt states for early developers and testers to start
helping us clean up the states interface and make it ready for the world!
.sp
0.9.2 also fixes a number of bugs found on Python 2.6.
.SS Download!
.sp
The Salt source can be downloaded from the salt github site:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.9.2.tar.gz\fP
.sp
Or from PyPI:
.sp
\fI\%http://pypi.python.org/packages/source/s/salt/salt-0.9.2.tar.gz\fP
.sp
For instructions on how to set up Salt please see the \fIinstallation\fP
instructions.
.SS New Features
.SS Salt\-Call Additions
.sp
The salt\-call command has received an overhaul, it now hooks into the outputter
system so command output looks clean, and the logging system has been hooked
into salt\-call, so the \-l option allows the logging output from salt minion
functions to be displayed.
.sp
The end result is that the salt\-call command can execute the state system and
return clean output:
.sp
.nf
.ft C
# salt\-call state.highstate
.ft P
.fi
.SS State System Fixes
.sp
The state system has been tested and better refined. As of this release the
state system is ready for early testers to start playing with. If you are
interested in working with the state system please check out the (still very
small) salt\-states github repo:
.sp
\fI\%https://github.com/thatch45/salt-states\fP
.sp
This git repo is the active development branch for determining how a clean
salt\-state database should look and act. Since the salt state system is still
very young a lot of help is still needed here. Please fork the salt\-states
repo and help us develop a truly large and scalable system for configuration
management!
.SS Notable Bug Fixes
.SS Python 2.6 String Formatting
.sp
Python 2.6 does not support format strings without an index identifier, all of
them have been repaired.
.SS Cython Loading Disabled by Default
.sp
Cython loading requires a development tool chain to be installed on the minion,
requiring this by default can cause problems for most Salt deployments. If
Cython auto loading is desired it will need to be turned on in the minion
config.
.SS Salt 0.9.3 Release Notes
.sp
Salt 0.9.3 is finally arrived. This is another big step forward for Salt, new
features range from proper FreeBSD support to fixing issues seen when
attaching a minion to a master over the Internet.
.sp
The biggest improvements in 0.9.3 though can be found in the state system, it
has progressed from something ready for early testers to a system ready to
compete with platforms such as Puppet and Chef. The backbone of the state
system has been greatly refined and many new features are available.
.SS Download!
.sp
The Salt source can be downloaded from the salt github site:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.9.3.tar.gz\fP
.sp
Or from PyPI:
.sp
\fI\%http://pypi.python.org/packages/source/s/salt/salt-0.9.3.tar.gz\fP
.sp
For instructions on how to set up Salt please see the \fIinstallation\fP
instructions.
.SS New Features
.SS WAN Support
.sp
Recently more people have been testing Salt minions connecting to Salt Masters
over the Internet. It was found that Minions would commonly loose their
connection to the master when working over the internet. The minions can now
detect if the connection has been lost and reconnect to the master, making
WAN connections much more reliable.
.SS State System Fixes
.sp
Substantial testing has gone into the state system and it is ready for real
world usage. A great deal has been added to the documentation for states and
the modules and functions available to states have been cleanly documented.
.sp
A number of State System bugs have also been founds and repaired, the output
from the state system has also been refined to be extremely clear and concise.
.sp
Error reporting has also been introduced, issues found in sls files will now
be clearly reported when executing Salt States.
.SS Extend Declaration
.sp
The Salt States have also gained the \fBextend\fP declaration. This declaration
allows for states to be cleanly modified in a post environment. Simply said,
if there is an apache.sls file that declares the apache service, then another
sls can include apache and then extend it:
.sp
.nf
.ft C
include:
  \- apache

extend:
  apache:
    service:
      \- require:
        \- pkg: mod_python

mod_python:
  pkg:
    \- installed
.ft P
.fi
.sp
The notable behavior with the extend functionality is that it literally extends
or overwrites a declaration set up in another sls module. This means that Salt
will behave as though the modifications were made directly to the apache sls.
This ensures that the apache service in this example is directly tied to all
requirements.
.SS Highstate Structure Specification
.sp
This release comes with a clear specification of the Highstate data structure
that is used to declare Salt States. This specification explains everything
that can be declared in the Salt SLS modules.
.sp
The specification is extremely simple, and illustrates how Salt has been able
to fulfill the requirements of a central configuration manager within a simple
and easy to understand format and specification.
.SS SheBang Renderer Switch
.sp
It came to our attention that having many renderers means that there may be a
situation where more than one State Renderer should be available within a
single State Tree.
.sp
The method chosen to accomplish this was something already familiar to
developers and systems administrators, a SheBang. The Python State Renderer
displays this new capability.
.SS Python State Renderer
.sp
Until now Salt States could only be declared in yaml or json using Jinja or
Mako. A new, very powerful, renderer has been added, making it possible to
write Salt States in pure Python:
.sp
.nf
.ft C
#!py

def run():
    \(aq\(aq\(aq
    Install the python\-mako package
    \(aq\(aq\(aq
    return {\(aqinclude\(aq: [\(aqpython\(aq],
            \(aqpython\-mako\(aq: {\(aqpkg\(aq: [\(aqinstalled\(aq]}}
.ft P
.fi
.sp
This renderer is used by making a run function that returns the Highstate data
structure. Any capabilities of Python can be used in pure Python sls modules.
.sp
This example of a pure Python sls module is the same as this example in yaml:
.sp
.nf
.ft C
include:
  \- python

python\-mako:
  pkg:
    \- installed
.ft P
.fi
.SS FreeBSD Support
.sp
Additional support has been added for FreeBSD, this is Salt\(aqs first branch out
of the Linux world and proves the viability of Salt on non\-Linux platforms.
.sp
Salt remote execution already worked on FreeBSD, and should work without issue
on any Unix\-like platform. But this support comes in the form of package
management and user support, so Salt States also work on FreeBSD now.
.sp
The new freebsdpkg module provides package management support for FreeBSD
and the new pw_user and pw_group provide user and group management.
.SS Module and State Additions
.SS Cron Support
.sp
Support for managing the system crontab has been added, declaring a cron state
can be done easily:
.sp
.nf
.ft C
date > /tmp/datestamp:
  cron:
    \- present
    \- user: fred
    \- minute: 5
    \- hour: 3
.ft P
.fi
.SS File State Additions
.sp
The file state has been given a number of new features, primarily the
directory, recurse, symlink and absent functions.
.INDENT 0.0
.TP
.B file.directory
Make sure that a directory exists and has the right permissions.
.sp
.nf
.ft C
/srv/foo:
  file:
    \- directory
    \- user: root
    \- group: root
    \- mode: 1755
.ft P
.fi
.TP
.B file.symlink
Make a symlink.
.sp
.nf
.ft C
/var/lib/www:
  file:
    \- symlink
    \- target: /srv/www
    \- force: True
.ft P
.fi
.TP
.B file.recurse
The recurse state function will recursively download a directory on the
master file server and place it on the minion. Any change in the files on
the master will be pushed to the minion. The recurse function is very
powerful and has been tested by pushing out the full Linux kernel source.
.sp
.nf
.ft C
/opt/code:
  file:
    \- recurse
    \- source: salt://linux
.ft P
.fi
.TP
.B file.absent
Make sure that the file is not on the system, recursively deletes
directories, files and symlinks.
.sp
.nf
.ft C
/etc/httpd/conf.d/somebogusfile.conf:
  file:
    \- absent
.ft P
.fi
.UNINDENT
.SS Sysctl Module and State
.sp
The sysctl module and state allows for sysctl components in the kernel to be
managed easily. the sysctl module contains the following functions:
.INDENT 0.0
.TP
.B sysctl.show
Return a list of sysctl parameters for this minion
.TP
.B sysctl.get
Return a single sysctl parameter for this minion
.TP
.B sysctl.assign
Assign a single sysctl parameter for this minion
.TP
.B sysctl.persist
Assign and persist a simple sysctl parameter for this minion
.UNINDENT
.sp
The sysctl state allows for sysctl parameters to be assigned:
.sp
.nf
.ft C
vm.swappiness:
  sysctl:
    \- present
    \- value: 20
.ft P
.fi
.SS Kernel Module Management
.sp
A module for managing Linux kernel modules has been added. The new functions
are as follows:
.INDENT 0.0
.TP
.B kmod.available
Return a list of all available kernel modules
.TP
.B kmod.check_available
Check to see if the specified kernel module is available
.TP
.B kmod.lsmod
Return a dict containing information about currently loaded modules
.TP
.B kmod.load
Load the specified kernel module
.TP
.B kmod.remove
Unload the specified kernel module
.UNINDENT
.sp
The kmod state can enforce modules be either present or absent:
.sp
.nf
.ft C
kvm_intel:
  kmod:
    \- present
.ft P
.fi
.SS Ssh Authorized Keys
.sp
The ssh_auth state can distribute ssh authorized keys out to minions. Ssh
authorized keys can be present or absent.
.sp
.nf
.ft C
AAAAB3NzaC1kc3MAAACBAL0sQ9fJ5bYTEyYvlRBsJdDOo49CNfhlWHWXQRqul6rwL4KIuPrhY7hBw0tV7UNC7J9IZRNO4iGod9C+OYutuWGJ2x5YNf7P4uGhH9AhBQGQ4LKOLxhDyT1OrDKXVFw3wgY3rHiJYAbd1PXNuclJHOKL27QZCRFjWSEaSrUOoczvAAAAFQD9d4jp2dCJSIseSkk4Lez3LqFcqQAAAIAmovHIVSrbLbXAXQE8eyPoL9x5C+x2GRpEcA7AeMH6bGx/xw6NtnQZVMcmZIre5Elrw3OKgxcDNomjYFNHuOYaQLBBMosyO++tJe1KTAr3A2zGj2xbWO9JhEzu8xvSdF8jRu0N5SRXPpzSyU4o1WGIPLVZSeSq1VFTHRT4lXB7PQAAAIBXUz6ZO0bregF5xtJRuxUN583HlfQkXvxLqHAGY8WSEVlTnuG/x75wolBDbVzeTlxWxgxhafj7P6Ncdv25Wz9wvc6ko/puww0b3rcLNqK+XCNJlsM/7lB8Q26iK5mRZzNsGeGwGTyzNIMBekGYQ5MRdIcPv5dBIP/1M6fQDEsAXQ==:
  ssh_auth:
    \- present
    \- user: frank
    \- enc: dsa
    \- comment: \(aqFrank\(aqs key\(aq
.ft P
.fi
.SS Salt 0.9.4 Release Notes
.sp
Salt 0.9.4 has arrived. This is a critical update that repairs a number of
key bugs found in 0.9.3. But this update is not without feature additions
as well! 0.9.4 adds support for Gentoo portage to the pkg module and state
system. Also there are 2 major new state additions, the failhard option and
the ability to set up finite state ordering with the \fBorder\fP option.
.sp
This release also sees our largest increase in community contributions.
These contributors have and continue to be the life blood of the Salt
project, and the team continues to grow. I want to put out a big thanks to
our new and existing contributors.
.SS Download!
.sp
The Salt source can be downloaded from the salt github site:
.sp
\fI\%https://github.com/downloads/saltstack/salt/salt-0.9.4.tar.gz\fP
.sp
Or from PyPI:
.sp
\fI\%http://pypi.python.org/packages/source/s/salt/salt-0.9.4.tar.gz\fP
.sp
For instructions on how to set up Salt please see the \fIinstallation\fP
instructions.
.SS New Features
.SS Failhard State Option
.sp
Normally, when a state fails Salt continues to execute the remainder of the
defined states and will only refuse to execute states that require the failed
state.
.sp
But the situation may exist, where you would want all state execution to stop
if a single state execution fails. The capability to do this is called
\fBfailing hard\fP.
.SS State Level Failhard
.sp
A single state can have a failhard set, this means that if this individual
state fails that all state execution will immediately stop. This is a great
thing to do if there is a state that sets up a critical config file and
setting a require for each state that reads the config would be cumbersome.
A good example of this would be setting up a package manager early on:
.sp
.nf
.ft C
/etc/yum.repos.d/company.repo:
  file:
    \- managed
    \- source: salt://company/yumrepo.conf
    \- user: root
    \- group: root
    \- mode: 644
    \- order: 1
    \- failhard: True
.ft P
.fi
.sp
In this situation, the yum repo is going to be configured before other states,
and if it fails to lay down the config file, than no other states will be
executed.
.SS Global Failhard
.sp
It may be desired to have failhard be applied to every state that is executed,
if this is the case, then failhard can be set in the master configuration
file. Setting failhard in the master configuration file will result in failing
hard when any minion gathering states from the master have a state fail.
.sp
This is NOT the default behavior, normally Salt will only fail states that
require a failed state.
.sp
Using the global failhard is generally not recommended, since it can result
in states not being executed or even checked. It can also be confusing to
see states failhard if an admin is not actively aware that the failhard has
been set.
.sp
To use the global failhard set failhard: True in the master configuration
.SS Finite Ordering of State Execution
.sp
When creating salt sls files, it is often important to ensure that they run in
a specific order. While states will always execute in the same order, that
order is not necessarily defined the way you want it.
.sp
A few tools exist in Salt to set up the correct state ordering, these tools
consist of requisite declarations and order options.
.SS The Order Option
.sp
Before using the order option, remember that the majority of state ordering
should be done with requisite statements, and that a requisite statement
will override an order option.
.sp
The order option is used by adding an order number to a state declaration
with the option \fIorder\fP:
.sp
.nf
.ft C
vim:
  pkg:
    \- installed
    \- order: 1
.ft P
.fi
.sp
By adding the order option to \fI1\fP this ensures that the vim package will be
installed in tandem with any other state declaration set to the order \fI1\fP.
.sp
Any state declared without an order option will be executed after all states
with order options are executed.
.sp
But this construct can only handle ordering states from the beginning.
Sometimes you may want to send a state to the end of the line, to do this
set the order to last:
.sp
.nf
.ft C
vim:
  pkg:
    \- installed
    \- order: last
.ft P
.fi
.sp
Substantial testing has gone into the state system and it is ready for real
world usage. A great deal has been added to the documentation for states and
the modules and functions available to states have been cleanly documented.
.sp
A number of State System bugs have also been founds and repaired, the output
from the state system has also been refined to be extremely clear and concise.
.sp
Error reporting has also been introduced, issues found in sls files will now
be clearly reported when executing Salt States.
.SS Gentoo Support
.sp
Additional experimental support has been added for Gentoo. This is found in
the contribution from Doug Renn, aka nestegg.
.SS Salt 0.9.5 Release Notes
.sp
Salt 0.9.5 is one of the largest steps forward in the development of Salt.
.sp
0.9.5 comes with many milestones, this release has seen the community of
developers grow out to an international team of 46 code contributors and has
many feature additions, feature enhancements, bug fixes and speed improvements.
.IP Warning
Be sure to \fIread the upgrade instructions\fP about the
switch to msgpack before upgrading!
.RE
.SS Community
.sp
Nothing has proven to have more value to the development of Salt that the
outstanding community that has been growing at such a great pace around Salt.
This has proven not only that Salt has great value, but also the
expandability of Salt is as exponential as I originally intended.
.sp
0.9.5 has received over 600 additional commits since 0.9.4 with a swath of new
committers. The following individuals have contributed to the development of
0.9.5:
.INDENT 0.0
.IP \(bu 2
Aaron Bull Schaefer
.IP \(bu 2
Antti Kaihola
.IP \(bu 2
Bas Tichelaar
.IP \(bu 2
Brad Barden
.IP \(bu 2
Brian Wagner
.IP \(bu 2
Byron Clark
.IP \(bu 2
Chris Scheller
.IP \(bu 2
Christer Edwards
.IP \(bu 2
Clint Savage
.IP \(bu 2
Corey Quinn
.IP \(bu 2
David Boucha
.IP \(bu 2
Eivind Uggedal
.IP \(bu 2
Eric Poelke
.IP \(bu 2
Evan Borgstrom
.IP \(bu 2
Jed Glazner
.IP \(bu 2
Jeff Schroeder
.IP \(bu 2
Jeffrey C. Ollie
.IP \(bu 2
Jonas Buckner
.IP \(bu 2
Kent Tenney
.IP \(bu 2
Martin Schnabel
.IP \(bu 2
Maxim Burgerhout
.IP \(bu 2
Mitch Anderson
.IP \(bu 2
Nathaniel Whiteinge
.IP \(bu 2
Seth House
.IP \(bu 2
Thomas S Hatch
.IP \(bu 2
Thomas Schreiber
.IP \(bu 2
Tor Hveem
.IP \(bu 2
lzyeval
.IP \(bu 2
syphernl
.UNINDENT
.sp
This makes 21 new developers since 0.9.4 was released!
.sp
To keep up with the growing community follow Salt on Ohloh
(\fI\%http://www.ohloh.net/p/salt\fP), to join the Salt development community, fork
Salt on Github, and get coding (\fI\%https://github.com/saltstack/salt\fP)!
.SS Major Features
.SS SPEED! Pickle to msgpack
.sp
For a few months now we have been talking about moving away from Python
pickles for network serialization, but a preferred serialization format
had not yet been found. After an extensive performance testing period
involving everything from JSON to protocol buffers, a clear winner emerged.
Message Pack (\fI\%http://msgpack.org/\fP) proved to not only be the fastest and most
compact, but also the most "salt like". Message Pack is simple, and the code
involved is very small. The msgpack library for Python has been added directly
to Salt.
.sp
This move introduces a few changes to Salt. First off, Salt is no longer a
"noarch" package, since the msgpack lib is written in C. Salt 0.9.5 will also
have compatibility issues with 0.9.4 with the default configuration.
.sp
We have gone through great lengths to avoid backwards compatibility issues with
Salt, but changing the serialization medium was going to create issues
regardless. Salt 0.9.5 is somewhat backwards compatible with earlier minions. A
0.9.5 master can command older minions, but only if the \fBserial\fP
config value in the master is set to \fBpickle\fP. This will tell the master to
publish messages in pickle format and will allow the master to receive messages
in both msgpack and pickle formats.
.sp
Therefore \fBthe suggested methods for upgrading\fP are either to just upgrade
everything at once, or:
.INDENT 0.0
.IP 1. 3
Upgrade the master to 0.9.5
.IP 2. 3
Set \fBserial\fP to \fBpickle\fP in the master config
.IP 3. 3
Upgrade the minions
.IP 4. 3
Remove the \fBserial\fP option from the master config
.UNINDENT
.sp
Since pickles can be used as a security exploit the ability for a master to
accept pickles from minions at all will be removed in a future release.
.SS C Bindings for YAML
.sp
All of the YAML rendering is now done with the YAML C bindings. This speeds up
all of the sls files when running states.
.SS Experimental Windows Support
.sp
David Boucha has worked tirelessly to bring initial support to Salt for
Microsoft Windows operating systems. Right now the Salt Minion can run as a
native Windows service and accept commands.
.sp
In the weeks and months to come Windows will receive the full treatment and
will have support for Salt States and more robust support for managing Windows
systems. This is a big step forward for Salt to move entirely outside of the
Unix world, and proves Salt is a viable cross platform solution. Big Thanks
to Dave for his contribution here!
.SS Dynamic Module Distribution
.sp
Many Salt users have expressed the desire to have Salt distribute in\-house
modules, states, renderers, returners, and grains. This support has been added
in a number of ways:
.SS Modules via States
.sp
Now when salt modules are deployed to a minion via the state system as a file,
then the modules will be automatically loaded into the active running minion
\- no restart required \- and into the active running state. So custom state
modules can be deployed and used in the same state run.
.SS Modules via Module Environment Directories
.sp
Under the file_roots each environment can now have directories that are used
to deploy large groups of modules. These directories sync modules at the
beginning of a state run on the minion, or can be manually synced via the Salt
module \fBsalt.modules.saltutil.sync_all\fP.
.sp
The directories are named:
.INDENT 0.0
.IP \(bu 2
\fB_modules\fP
.IP \(bu 2
\fB_states\fP
.IP \(bu 2
\fB_grains\fP
.IP \(bu 2
\fB_renderers\fP
.IP \(bu 2
\fB_returners\fP
.UNINDENT
.sp
The modules are pushed to their respective scopes on the minions.
.SS Module Reloading
.sp
Modules can now be reloaded without restarting the minion, this is done by
calling the \fBsalt.modules.sys.reload_modules\fP function.
.sp
But wait, there\(aqs more! Now when a salt module of any type is added via
states the modules will be automatically reloaded, allowing for modules to be
laid down with states and then immediately used.
.sp
Finally, all modules are reloaded when modules are dynamically distributed
from the salt master.
.SS Enable / Disable Added to Service
.sp
A great deal of demand has existed for adding the capability to set services
to be started at boot in the service module. This feature also comes with an
overhaul of the service modules and initial systemd support.
.sp
This means that the \fBservice state\fP can now
accept \fB\- enable: True\fP to make sure a service is enabled at boot, and \fB\-
enable: False\fP to make sure it is disabled.
.SS Compound Target
.sp
A new target type has been added to the lineup, the compound target. In
previous versions the desired minions could only be targeted via a single
specific target type, but now many target specifications can be declared.
.sp
These targets can also be separated by and/or operators, so certain properties
can be used to omit a node:
.sp
.nf
.ft C
salt \-C \(aqwebserv* and G@os:Debian or E@db.*\(aq test.ping
.ft P
.fi
.sp
will match all minions with ids starting with webserv via a glob and minions
matching the \fBos:Debian\fP grain. Or minions that match the \fBdb.*\fP regular
expression.
.SS Node Groups
.sp
Often the convenience of having a predefined group of minions to execute
targets on is desired. This can be accomplished with the new nodegroups
feature. Nodegroups allow for predefined compound targets to be declared in
the master configuration file:
.sp
.nf
.ft C
nodegroups:
  group1: \(aqL@foo.domain.com,bar.domain.com,baz.domain.com and bl*.domain.com\(aq
  group2: \(aqG@os:Debian and foo.domain.com\(aq
.ft P
.fi
.sp
And then used via the \fB\-N\fP option:
.sp
.nf
.ft C
salt \-N group1 test.ping
.ft P
.fi
.SS Minion Side Data Store
.sp
The data module introduces the initial approach into storing persistent data on
the minions, specific to the minions. This allows for data to be stored on
minions that can be accessed from the master or from the minion.
.sp
The Minion datastore is young, and will eventually provide an interface similar
to a more mature key/value pair server.
.SS Major Grains Improvement
.sp
The Salt grains have been overhauled to include a massive amount of extra data.
this includes hardware data, os data and salt specific data.
.SS Salt \-Q is Useful Now
.sp
In the past the salt query system, which would display the data from recent
executions would be displayed in pure Python, and it was unreadable.
.sp
0.9.5 has added the outputter system to the \fB\-Q\fP option, thus enabling the
salt query system to return readable output.
.SS Packaging Updates
.sp
Huge strides have been made in packaging Salt for distributions. These
additions are thanks to our wonderful community where the work to set up
packages has proceeded tirelessly.
.SS FreeBSD
.sp
Salt on FreeBSD? There a port for that:
.sp
\fI\%http://www.freebsd.org/cgi/cvsweb.cgi/ports/sysutils/salt/pkg-descr\fP
.sp
This port was developed and added by Christer Edwards. This also marks the
first time Salt has been included in an upstream packaging system!
.SS Fedora and Red Hat Enterprise
.sp
Salt packages have been prepared for inclusion in the Fedora Project and in
EPEL for Red Hat Enterprise 5 and 6. These packages are the result of the
efforts made by Clint Savage (herlo).
.SS Debian/Ubuntu
.sp
A team of many contributors have assisted in developing packages for Debian
and Ubuntu. Salt is still actively seeking inclusion in upstream Debian and
Ubuntu and the package data that has been prepared is being pushed through
the needed channels for inclusion.
.sp
These packages have been prepared with the help of:
.INDENT 0.0
.IP \(bu 2
Corey
.IP \(bu 2
Aaron Toponce
.IP \(bu 2
and\(ga
.UNINDENT
.SS More to Come
.sp
We are actively seeking inclusion in more distributions. Primarily getting
Salt into Gentoo, SUSE, OpenBSD and preparing Solaris support are all turning
into higher priorities.
.SS Refinement
.sp
Salt continues to be refined into a faster, more stable and more usable
application. 0.9.5 comes with more debug logging, more bug fixes and more
complete support.
.SS More Testing, More BugFixes
.sp
0.9.5 comes with more bugfixes due to more testing than any previous release.
The growing community and the introduction a a dedicated QA environment have
unearthed many issues that were hiding under the covers. This has further
refined and cleaned the state interface, taking care of things from minor
visual issues to repairing misleading data.
.SS Custom Exceptions
.sp
A custom exception module has been added to throw salt specific exceptions.
This allows Salt to give much more granular error information.
.SS New Modules
.SS \fBdata\fP
.sp
The new data module manages a persistent datastore on the minion.
Big thanks to bastichelaar for his help refining this module
.SS \fBfreebsdkmod\fP
.sp
FreeBSD kernel modules can now be managed in the same way Salt handles Linux
kernel modules.
.sp
This module was contributed thanks to the efforts of Christer Edwards
.SS \fBgentoo_service\fP
.sp
Support has been added for managing services in Gentoo. Now Gentoo services
can be started, stopped, restarted, enabled, disabled and viewed.
.SS \fBpip\fP
.sp
The pip module introduces management for pip installed applications.
Thanks goes to whitinge for the addition of the pip module
.SS \fBrh_service\fP
.sp
The rh_service module enables Red Hat and Fedora specific service management.
Now Red Hat like systems come with extensive management of the classic init
system used by Red Hat
.SS \fBsaltutil\fP
.sp
The saltutil module has been added as a place to hold functions used in the
maintenance and management of salt itself. Saltutil is used to salt the salt
minion. The saltutil module is presently used only to sync extension modules
from the master server.
.SS \fBsystemd\fP
.sp
Systemd support has been added to Salt, now systems using this next generation
init system are supported on systems running systemd.
.SS \fBvirtualenv\fP
.sp
The virtualenv module has been added to allow salt to create virtual Python
environments.
Thanks goes to whitinge for the addition of the virtualenv module
.SS \fBwin_disk\fP
.sp
Support for gathering disk information on Microsoft Windows minions
The windows modules come courtesy of Utah_Dave
.SS \fBwin_service\fP
.sp
The win_service module adds service support to Salt for Microsoft Windows
services
.SS \fBwin_useradd\fP
.sp
Salt can now manage local users on Microsoft Windows Systems
.SS \fByumpkg5\fP
.sp
The yumpkg module introduces in 0.9.4 uses the yum API to interact with the
yum package manager. Unfortunately, on Red Hat 5 systems salt does not have
access to the yum API because the yum API is running under Python 2.4 and Salt
needs to run under Python 2.6.
.sp
The yumpkg5 module bypasses this issue by shelling out to yum on systems where
the yum API is not available.
.SS New States
.SS \fBmysql_database\fP
.sp
The new mysql_database state adds the ability to systems running a mysql
server to manage the existence of mysql databases.
.sp
The mysql states are thanks to syphernl
.SS \fBmysql_user\fP
.sp
The mysql_user state enables mysql user management.
.SS \fBvirtualenv\fP
.sp
The virtualenv state can manage the state of Python virtual environments.
Thanks to Whitinge for the virtualenv state
.SS New Returners
.SS \fBcassandra_returner\fP
.sp
A returner allowing Salt to send data to a cassandra server.
Thanks to Byron Clark for contributing this returner
.SS Salt 0.9.6 Release Notes
.sp
Salt 0.9.6 is a release targeting a few bugs and changes. This is primarily
targeting an issue found in the names declaration in the state system. But a
few other bugs were also repaired, like missing support for grains in extmods.
.sp
Due to a conflict in distribution packaging msgpack will no longer be bundled
with Salt, and is required as a dependency.
.SS New Features
.SS HTTP and ftp support in files.managed
.sp
Now under the source option in the file.managed state a HTTP or ftp address
can be used instead of a file located on the salt master.
.SS Allow Multiple Returners
.sp
Now the returner interface can define multiple returners, and will also return
data back to the master, making the process less ambiguous.
.SS Minion Memory Improvements
.sp
A number of modules have been taken out of the minion if the underlying
systems required by said modules are not present on the minion system.
A number of other modules need to be stripped out in this same way which
should continue to make the minion more efficient.
.SS Minions Can Locally Cache Return Data
.sp
A new option, cache_jobs, has been added to the minion to allow for all of the
historically run jobs to cache on the minion, allowing for looking up historic
returns. By default cache_jobs is set to False.
.SS Pure Python Template Support For file.managed
.sp
Templates in the file.managed state can now be defined in a Python script.
This script needs to have a run function that returns the string that needs to
be in the named file.
.SS Salt 0.9.7 Release Notes
.sp
Salt 0.9.7 is here! The latest iteration of Salt brings more features and many
fixes. This release is a great refinement over 0.9.6, adding many conveniences
under the hood, as well as some features that make working with Salt much
better.
.sp
A few highlights include the new Job system, refinements to the requisite
system in states, the \fBmod_init\fP interface for states, external node
classification, search path to managed files in the file state, and refinements
and additions to dynamic module loading.
.sp
0.9.7 also introduces the long developed (and oft changed) unit test framework
and the initial unit tests.
.SS Major Features
.SS Salt Jobs Interface
.sp
The new jobs interface makes the management of running executions much cleaner
and more transparent. Building on the existing execution framework the jobs
system allows clear introspection into the active running state of the
running Salt interface.
.sp
The Jobs interface is centered in the new minion side proc system. The
minions now store msgpack serialized files under \fB/var/cache/salt/proc\fP.
These files keep track of the active state of processes on the minion.
.SS Functions in the saltutil Module
.sp
A number of functions have been added to the saltutil module to manage and
view the jobs:
.sp
\fBrunning\fP \- Returns the data of all running jobs that are found in the proc
directory.
.sp
\fBfind_job\fP \- Returns specific data about a certain job based on job id.
.sp
\fBsignal_job\fP \- Allows for a given jid to be sent a signal.
.sp
\fBterm_job\fP \- Sends a termination signal (\fBSIGTERM, 15\fP) to the process
controlling the specified job.
.sp
\fBkill_job\fP Sends a kill signal (\fBSIGKILL, 9\fP) to the process controlling the
specified job.
.SS The jobs Runner
.sp
A convenience runner front end and reporting system has been added as well.
The jobs runner contains functions to make viewing data easier and cleaner.
.sp
The jobs runner contains a number of functions...
.SS active
.sp
The active function runs \fBsaltutil.running\fP on all minions and formats the
return data about all running jobs in a much more usable and compact format.
The active function will also compare jobs that have returned and jobs that
are still running, making it easier to see what systems have completed a job
and what systems are still being waited on.
.SS lookup_jid
.sp
When jobs are executed the return data is sent back to the master and cached.
By default is is cached for 24 hours, but this can be configured via the
\fBkeep_jobs\fP option in the master configuration.
.sp
Using the \fBlookup_jid\fP runner will display the same return data that the
initial job invocation with the salt command would display.
.SS list_jobs
.sp
Before finding a historic job, it may be required to find the job id.
\fBlist_jobs\fP will parse the cached execution data and display all of the job
data for jobs that have already, or partially returned.
.SS External Node Classification
.sp
Salt can now use external node classifiers like Cobbler\(aqs
\fBcobbler\-ext\-nodes\fP.
.sp
Salt uses specific data from the external node classifier. In particular the
classes value denotes which sls modules to run, and the environment value sets
to another environment.
.sp
An external node classification can be set in the master configuration file via
the \fBexternal_nodes\fP option:
\fI\%http://salt.readthedocs.org/en/latest/ref/configuration/master.html#external-nodes\fP
.sp
External nodes are loaded in addition to the top files. If it is intended to
only use external nodes, do not deploy any top files.
.SS State Mod Init System
.sp
An issue arose with the pkg state. Every time a package was run Salt would
need to refresh the package database. This made systems with slower package
metadata refresh speeds much slower to work with. To alleviate this issue the
\fBmod_init\fP interface has been added to salt states.
.sp
The \fBmod_init\fP interface is a function that can be added to a state file.
This function is called with the first state called. In the case of the pkg
state, the \fBmod_init\fP function sets up a tag which makes the package database
only refresh on the first attempt to install a package.
.sp
In a nutshell, the \fBmod_init\fP interface allows a state to run any command that
only needs to be run once, or can be used to set up an environment for working
with the state.
.SS Source File Search Path
.sp
The file state continues to be refined, adding speed and capabilities. This
release adds the ability to pass a list to the source option. This list is then
iterated over until the source file is found, and the first found file is used.
.sp
The new syntax looks like this:
.sp
.nf
.ft C
/etc/httpd/conf/httpd.conf:
  file:
    \- managed
    \- source:
      \- salt://httpd/httpd.conf
      \- http://myserver/httpd.conf: md5=8c1fe119e6f1fd96bc06614473509bf1
.ft P
.fi
.sp
The source option can take sources in the list from the salt file server
as well as an arbitrary web source. If using an arbitrary web source the
checksum needs to be passed as well for file verification.
.SS Refinements to the Requisite System
.sp
A few discrepancies were still lingering in the requisite system, in
particular, it was not possible to have a \fBrequire\fP and a \fBwatch\fP requisite
declared in the same state declaration.
.sp
This issue has been alleviated, as well as making the requisite system run
more quickly.
.SS Initial Unit Testing Framework
.sp
Because of the module system, and the need to test real scenarios, the
development of a viable unit testing system has been difficult, but unit
testing has finally arrived. Only a small amount of unit testing coverage
has been developed, much more coverage will be in place soon.
.sp
A huge thanks goes out to those who have helped with unit testing, and the
contributions that have been made to get us where we are. Without these
contributions unit tests would still be in the dark.
.SS Compound Targets Expanded
.sp
Originally only support for \fBand\fP and \fBor\fP were available in the compound
target. 0.9.7 adds the capability to negate compound targets with \fBnot\fP.
.SS Nodegroups in the Top File
.sp
Previously the nodegroups defined in the master configuration file could not
be used to match nodes for states. The nodegroups support has been expanded
and the nodegroups defined in the master configuration can now be used to
match minions in the top file.
.SS Salt 0.9.8 Release Notes
.sp
Salt 0.9.8 is a big step forward, with many additions and enhancements, as
well as a number of precursors to advanced future developments.
.sp
This version of Salt adds much more power to the command line, making the
old hard timeout issues a thing of the past and adds keyword argument
support. These additions are also available in the salt client API, making
the available API tools much more powerful.
.sp
The new pillar system allows for data to be stored on the master and
assigned to minions in a granular way similar to the state system. It also
allows flexibility for users who want to keep data out of their state tree
similar to \(aqexternal lookup\(aq functionality in other tools.
.sp
A new way to extend requisites was added, the "requisite in" statement.
This makes adding requires or watch statements to external state decs
much easier.
.sp
Additions to requisites making them much more powerful have been added as well
as improved error checking for sls files in the state system. A new provider
system has been added to allow for redirecting what modules run in the
background for individual states.
.sp
Support for OpenSUSE has been added and support for Solaris has begun
serious development. Windows support has been significantly enhanced as well.
.sp
The matcher and target systems have received a great deal of attention. The
default behavior of grain matching has changed slightly to reflect the rest
of salt and the compound matcher system has been refined.
.sp
A number of impressive features with keyword arguments have been added to both
the CLI and to the state system. This makes states much more powerful and
flexible while maintaining the simple configuration everyone loves.
.sp
The new batch size capability allows for executions to be rolled through a
group of targeted minions a percentage or specific number at a time. This
was added to prevent the "thundering herd" problem when targeting large
numbers of minions for things like service restarts or file downloads.
.SS Upgrade Considerations
.SS Upgrade Issues
.sp
There was a previously missed oversight which could cause a newer minion to
crash an older master. That oversight has been resolved so the version
incompatibility issue will no longer occur. When upgrading to 0.9.8 make
sure to upgrade the master first, followed by the minions.
.SS Debian/Ubuntu Packages
.sp
The original Debian/Ubuntu packages were called salt and included all salt
applications. New packages in the ppa are split by function. If an old salt
package is installed then it should be manually removed and the new split
packages need to be freshly installed.
.sp
On the master:
.sp
.nf
.ft C
# apt\-get purge salt
# apt\-get install salt\-{master,minion}
.ft P
.fi
.sp
On the minions:
.sp
.nf
.ft C
# apt\-get purge salt
# apt\-get install salt\-minion
.ft P
.fi
.sp
And on any Syndics:
.sp
.nf
.ft C
# apt\-get install salt\-syndic
.ft P
.fi
.sp
The official salt stack ppa for Ubuntu is located at:
\fI\%https://launchpad.net/~saltstack/+archive/salt\fP
.SS Major Features
.SS Pillar
.sp
\fBPillar\fP offers an interface to declare variable data on the master that is then
assigned to the minions. The pillar data is made available to all modules,
states, sls files etc. It is compiled on the master and is declared using the
existing renderer system. This means that learning pillar should be fairly
trivial to those already familiar with salt states.
.SS CLI Additions
.sp
The \fBsalt\fP command has received a serious overhaul and is more powerful
than ever. Data is returned to the terminal as it is received, and the salt
command will now wait for all running minions to return data before stopping.
This makes adding very large \fI\-\-timeout\fP arguments completely unnecessary and
gets rid of long running operations returning empty \fB{}\fP when the timeout is
exceeded.
.sp
When calling salt via sudo, the user originally running salt is saved to the
log for auditing purposes. This makes it easy to see who ran what by just
looking through the minion logs.
.sp
The \fIsalt\-key\fP command gained the \fI\-D\fP and \fI\-\-delete\-all\fP arguments for
removing all keys. Be careful with this one!
.SS Running States Without a Master
.sp
The addition of running states without a salt\-master has been added
to 0.9.8. This feature allows for the unmodified salt state tree to be
read locally from a minion. The result is that the UNMODIFIED state tree
has just become portable, allowing minions to have a local copy of states
or to manage states without a master entirely.
.sp
This is accomplished via the new file client interface in Salt that allows
for the \fBsalt://\fP URI to be redirected to custom interfaces. This means that
there are now two interfaces for the salt file server, calling the master
or looking in a local, minion defined \fBfile_roots\fP.
.sp
This new feature can be used by modifying the minion config to point to a
local \fBfile_roots\fP and setting the \fBfile_client\fP option to \fBlocal\fP.
.SS Keyword Arguments and States
.sp
State modules now accept the \fB**kwargs\fP argument. This results in all data
in a sls file assigned to a state being made available to the state function.
.sp
This passes data in a transparent way back to the modules executing the logic.
In particular, this allows adding arguments to the \fBpkg.install\fP module that
enable more advanced and granular controls with respect to what the state is
capable of.
.sp
An example of this along with the new debconf module for installing ldap
client packages on Debian:
.sp
.nf
.ft C
ldap\-client\-packages:
  pkg:
    \- debconf: salt://debconf/ldap\-client.ans
    \- installed
    \- names:
      \- nslcd
      \- libpam\-ldapd
      \- libnss\-ldapd
.ft P
.fi
.SS Keyword Arguments and the CLI
.sp
In the past it was required that all arguments be passed in the proper order to
the \fIsalt\fP and \fIsalt\-call\fP commands. As of 0.9.8, keyword arguments can be
passed in the form of \fBkwarg=argument\fP.
.sp
.nf
.ft C
# salt \-G \(aqtype:dev\(aq git.clone \e
    repository=https://github.com/saltstack/salt.git cwd=/tmp/salt user=jeff
.ft P
.fi
.SS Matcher Refinements and Changes
.sp
A number of fixes and changes have been applied to the Matcher system. The
most noteworthy is the change in the grain matcher. The grain matcher used to
use a regular expression to match the passed data to a grain, but now defaults
to a shell glob like the majority of match interfaces in Salt. A new option
is available that still uses the old style regex matching to grain data called
\fBgrain\-pcre\fP. To use regex matching in compound matches use the letter \fIP\fP.
.sp
For example, this would match any ArchLinux or Fedora minions:
.sp
.nf
.ft C
# salt \-\-grain\-pcre \(aqos:(Arch:Fed).*\(aq test.ping
.ft P
.fi
.sp
And the associated compound matcher suitable for \fBtop.sls\fP is \fIP\fP:
.sp
.nf
.ft C
P@os:(Arch|Fed).*
.ft P
.fi
.sp
\fBNOTE\fP: Changing the grains matcher from pcre to glob is backwards
incompatible.
.sp
Support has been added for matching minions with Yahoo\(aqs range library. This
is handled by passing range syntax with \fI\-R\fP or \fI\-\-range\fP arguments to salt.
.sp
More information at:
\fI\%https://github.com/grierj/range/wiki/Introduction-to-Range-with-YAML-files\fP
.SS Requisite "in"
.sp
A new means to updating requisite statements has been added to make adding
watchers and requires to external states easier. Before 0.9.8 the only way
to extend the states that were watched by a state outside of the sls was to
use an extend statement:
.sp
.nf
.ft C
include:
  \- http
extend:
  apache:
    service:
      \- watch:
        \- pkg: tomcat

tomcat:
  pkg:
    \- installed
.ft P
.fi
.sp
But the new \fBRequisite in\fP statement allows for easier extends for
requisites:
.sp
.nf
.ft C
include:
  \- http

tomcat:
  pkg:
    \- installed
    \- watch_in:
      \- service: apache
.ft P
.fi
.sp
Requisite in is part of the extend system, so still remember to always include
the sls that is being extended!
.SS Providers
.sp
Salt predetermines what modules should be mapped to what uses based on the
properties of a system. These determinations are generally made for modules
that provide things like package and service management. The apt module
maps to pkg on Debian and the yum module maps to pkg on Fedora for instance.
.sp
Sometimes in states, it may be necessary for a non\-default module to be used
for the desired functionality. For instance, an Arch Linux system may have
been set up with systemd support. Instead of using the default service module
detected for Arch Linux, the systemd module can be used:
.sp
.nf
.ft C
http:
  service:
    \- running
    \- enable: True
    \- provider: systemd
.ft P
.fi
.sp
Default providers can also be defined in the minion config file:
.sp
.nf
.ft C
providers:
  pkg: yumpkg5
  service: systemd
.ft P
.fi
.sp
When default providers are passed in the minion config, then those providers
will be applied to all functionality in Salt, this means that the functions
called by the minion will use these modules, as well as states.
.SS Requisite Glob Matching
.sp
Requisites can now be defined with glob expansion. This means that if there are
many requisites, they can be defined on a single line.
.sp
To watch all files in a directory:
.sp
.nf
.ft C
http:
  service:
    \- running
    \- enable: True
    \- watch:
      \- file: /etc/http/conf.d/*
.ft P
.fi
.sp
This example will watch all defined files that match the glob
\fB/etc/http/conf.d/*\fP
.SS Batch Size
.sp
The new batch size option allows commands to be executed while maintaining that
only so many hosts are executing the command at one time. This option can
take a percentage or a finite number:
.sp
.nf
.ft C
salt \e* \-b 10 test.ping

salt \-G \(aqos:RedHat\(aq \-\-batch\-size 25% apache.signal restart
.ft P
.fi
.sp
This will only run test.ping on 10 of the targeted minions at a time and then
restart apache on 25% of the minions matching \fBos:RedHat\fP at a time and work
through them all until the task is complete. This makes jobs like rolling web
server restarts behind a load balancer or doing maintenance on BSD firewalls
using carp much easier with salt.
.SS Module Updates
.sp
This is a list of notable, but non\-exhaustive updates with new and existing
modules.
.sp
Windows support has seen a flurry of support this release cycle. We\(aqve gained
all new \fBfile\fP,
\fBnetwork\fP, and
\fBshadow\fP modules. Please note
that these are still a work in progress.
.sp
For our ruby users, new \fBrvm\fP and
\fBgem\fP modules have been added along
with the \fBassociated\fP
\fBstates\fP
.sp
The \fBvirt\fP module gained basic Xen support.
.sp
The \fByum\fP
\fBpkg\fP modules gained Scientific
Linux support.
.sp
The \fBpkg\fP module on Debian, Ubuntu,
and derivatives force apt to run in a non\-interactive mode. This prevents
issues when package installation waits for confirmation.
.sp
A \fBpkg\fP module for OpenSUSE\(aqs
zypper was added.
.sp
The \fBservice\fP module on Ubuntu
natively supports upstart.
.sp
A new \fBdebconf\fP module was
contributed by our community for more advanced control over deb package
deployments on Debian based distributions.
.sp
The \fBmysql.user\fP state and
\fBmysql\fP module gained a
\fIpassword_hash\fP argument.
.sp
The \fBcmd\fP module and state gained
a \fIshell\fP keyword argument for specifying a shell other than \fB/bin/sh\fP on
Linux / Unix systems.
.sp
New \fBgit\fP and
\fBmercurial\fP modules have been added
for fans of distributed version control.
.SS In Progress Development
.SS Master Side State Compiling
.sp
While we feel strongly that the advantages gained with minion side state
compiling are very critical, it does prevent certain features that may be
desired. 0.9.8 has support for initial master side state compiling, but many
more components still need to be developed, it is hoped that these can be
finished for 0.9.9.
.sp
The goal is that states can be compiled on both the master and the minion
allowing for compilation to be split between master and minion. Why will
this be great? It will allow storing sensitive data on the master and sending
it to some minions without all minions having access to it. This will be
good for handling ssl certificates on front\-end web servers for instance.
.SS Solaris Support
.sp
Salt 0.9.8 sees the introduction of basic Solaris support. The daemon runs
well, but grains and more of the modules need updating and testing.
.SS Windows Support
.sp
Salt states on windows are now much more viable thanks to contributions from
our community! States for file, service, local user, and local group management are more fully
fleshed out along with network and disk modules. Windows users can also now manage
registry entries using the new "reg" module.
.SS Salt 0.9.9 Release Notes
.sp
0.9.9 is out and comes with some serious bug fixes and even more serious
features. This release is the last major feature release before 1.0.0 and
could be considered the 1.0.0 release candidate.
.sp
A few updates include more advanced kwargs support, the ability for salt
states to more safely configure a running salt minion, better job directory
management and the new state test interface.
.sp
Many new tests have been added as well, including the new minion swarm test
that allows for easier testing of Salt working with large groups of minions.
This means that if you have experienced stability issues with Salt before,
particularly in larger deployments, that these bugs have been tested for,
found, and killed.
.SS Major Features
.SS State Test Interface
.sp
Until 0.9.9 the only option when running states to see what was going to be
changed was to print out the highstate with state.show_highstate and manually
look it over. But now states can be run to discover what is going to be
changed.
.sp
Passing the option \fBtest=True\fP to many of the state functions will now cause
the salt state system to only check for what is going to be changed and report
on those changes.
.sp
.nf
.ft C
# salt \e* state.highstate test=True
.ft P
.fi
.sp
Now states that would have made changes report them back in yellow.
.SS State Syntax Update
.sp
A shorthand syntax has been added to sls files, and it will be the default
syntax in documentation going forward. The old syntax is still fully supported
and will not be deprecated, but it is recommended to move to the new syntax in
the future. This change moves the state function up into the state name using
a dot notation. This is in\-line with how state functions are generally referred
to as well:
.sp
The new way:
.sp
.nf
.ft C
/etc/sudoers:
  file.present:
    \- source: salt://sudo/sudoers
    \- user: root
    \- mode: 400
.ft P
.fi
.SS Use and Use_in Requisites
.sp
Two new requisite statements are available in 0.9.9. The use and use_in
requisite and requisite\-in allow for the transparent duplication of data
between states. When a state "uses" another state it copies the other state\(aqs
arguments as defaults. This was created in direct response to the new network
state, and allows for many network interfaces to be configured in the same way
easily. A simple example:
.sp
.nf
.ft C
root_file:
  file.absent:
    \- name: /tmp/nothing
    \- user: root
    \- mode: 644
    \- group: root
    \- use_in:
      \- file: /etc/vimrc

fred_file:
  file.absent:
    \- name: /tmp/nothing
    \- user: fred
    \- group: marketing
    \- mode: 660

/files/marketing/district7.rst:
  file.present:
    \- source: salt://marketing/district7.rst
    \- template: jinja
    \- use:
      \- file: fred_file

/etc/vimrc:
  file.present:
    \- source: salt://edit/vimrc
.ft P
.fi
.sp
This makes the 2 lower state decs inherit the options from their respectively
"used" state decs.
.SS Network State
.sp
The new network state allows for the configuration of network devices via salt
states and the ip salt module. This addition has been given to the project by
Jeff Hutchins and Bret Palsson from Jive Communications.
.sp
Currently the only network configuration backend available is for Red Hat
based systems, like Red Hat Enterprise, CentOS, and Fedora.
.SS Exponential Jobs
.sp
Originally the jobs executed were stored on the master in the format:
\fB<cachedir>/jobs/jid/{minion ids}\fP
But this format restricted the number of jobs in the cache to the number of
subdirectories allowed on the filesystem. Ext3 for instance limits
subdirectories to 32000. To combat this the new format for 0.9.9 is:
\fB<cachedir>/jobs/jid_hash[:2]/jid_hash[2:]/{minion ids}\fP
So that now the number of maximum jobs that can be run before the cleanup
cycle hits the job directory is substantially higher.
.SS ssh_auth Additions
.sp
The original ssh_auth state was limited to accepting only arguments to apply
to a public key, and the key itself. This was restrictive due to the way the
we learned that many people were using the state, so the key section has been
expanded to accept options and arguments to the key that over ride arguments
passed in the state. This gives substantial power to using ssh_auth with names:
.sp
.nf
.ft C
sshkeys:
  ssh_auth:
    \- present
    \- user: backup
    \- enc: ssh\-dss
    \- options:
      \- option1="value1"
      \- option2="value2 flag2"
    \- comment: backup
    \- names:
      \- AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0111==
      \- AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0222== override
      \- ssh\-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0333== override
      \- ssh\-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0444==
      \- option3="value3",option4="value4 flag4" ssh\-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0555== override
      \- option3="value3" ssh\-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAlyE26SMFFVY5YJvnL7AF5CRTPtAigSW1U887ASfBt6FDa7Qr1YdO5ochiLoz8aSiMKd5h4dhB6ymHbmntMPjQena29jQjXAK4AK0500rMShG1Y1HYEjTXjQxIy/SMjq2aycHI+abiVDn3sciQjsLsNW59t48Udivl2RjWG7Eo+LYiB17MKD5M40r5CP2K4B8nuL+r4oAZEHKOJUF3rzA20MZXHRQuki7vVeWcW7ie8JHNBcq8iObVSoruylXav4aKG02d/I4bz/l0UdGh18SpMB8zVnT3YF5nukQQ/ATspmhpU66s4ntMehULC+ljLvZL40ByNmF0TZc2sdSkA0666==
.ft P
.fi
.SS LocalClient Additions
.sp
To follow up the recent additions in 0.9.8 of additional kwargs support,
0.9.9 also adds the capability to send kwargs into commands via a dict.
This addition to the LocalClient api can be used like so:
.sp
.nf
.ft C
import salt.client

client = salt.client.LocalClient(\(aq/etc/salt/master\(aq)
ret = client.cmd(\(aq*\(aq, \(aqcmd.run\(aq, [\(aqls \-l\(aq], kwarg={\(aqcwd\(aq: \(aq/etc\(aq})
.ft P
.fi
.sp
This update has been added to all cmd methods in the LocalClient class.
.SS Better Self Salting
.sp
One problem faced with running Salt states, is that it has been difficult
to manage the Salt minion via states, this is due to the fact that if the
minion is called to restart while a state run is happening then the state
run would be killed. 0.9.9 slightly changes the process scope of the state
runs, so now when salt is executing states it can safely restart the
salt\-minion daemon.
.sp
In addition to daemonizing the state run, the apt module also daemonizes.
This update makes it possible to cleanly update the salt\-minion package on
Debian/Ubuntu systems without leaving apt in an inconsistent state or killing
the active minion process mid\-execution.
.SS Wildcards for SLS Modules
.sp
Now, when including sls modules in include statements or in the top file,
shell globs can be used. This can greatly simplify listing matched sls
modules in the top file and include statements:
.sp
.nf
.ft C
base:
  \(aq*\(aq:
    \- files*
    \- core*
.ft P
.fi
.sp
.nf
.ft C
include:
  \- users.dev.*
  \- apache.ser*
.ft P
.fi
.SS External Pillar
.sp
Since the pillar data is just, data, it does not need to come expressly from
the pillar interface. The external pillar system allows for hooks to be added
making it possible to extract pillar data from any arbitrary external
interface. The external pillar interface is configured via the \fBext_pillar\fP
option. Currently interfaces exist to gather external pillar data via hiera
or via a shell command that sends yaml data to the terminal:
.sp
.nf
.ft C
ext_pillar:
  \- cmd_yaml: cat /etc/salt/ext.yaml
  \- hiera: /etc/hirea.yaml
.ft P
.fi
.sp
The initial external pillar interfaces and extra interfaces can be added to
the file salt/pillar.py, it is planned to add more external pillar interfaces.
If the need arises a new module loader interface will be created in the future
to manage external pillar interfaces.
.SS Single State Executions
.sp
The new state.single function allows for single states to be cleanly executed.
This is a great tool for setting up a small group of states on a system or for
testing out the behavior of single states:
.sp
.nf
.ft C
# salt \e* state.single user.present name=wade uid=2000
.ft P
.fi
.sp
The test interface functions here as well, so changes can also be tested
against as:
.sp
.nf
.ft C
# salt \e* state.single user.present name=wade uid=2000 test=True
.ft P
.fi
.SS New Tests
.sp
A few exciting new test interfaces have been added, the minion swarm allows
not only testing of larger loads, but also allows users to see how Salt behaves
with large groups of minions without having to create a large deployment.
.SS Minion Swarm
.sp
The minion swarm test system allows for large groups of minions to be tested
against easily without requiring large numbers of servers or virtual
machines. The minion swarm creates as many minions as a system can handle and
roots them in the /tmp directory and connects them to a master.
.sp
The benefit here is that we were able to replicate issues that happen only
when there are large numbers of minions. A number of elusive bugs which were
causing stability issues in masters and minions have since been hunted down.
Bugs that used to take careful watch by users over several days can now be
reliably replicated in minutes, and fixed in minutes.
.sp
Using the swarm is easy, make sure a master is up for the swarm to connect to,
and then use the minionswarm.py script in the tests directory to spin up
as many minions as you want. Remember, this is a fork bomb, don\(aqt spin up more
than your hardware can handle!
.sp
.nf
.ft C
# python minionswarm.py \-m 20 \-\-master salt\-master
.ft P
.fi
.SS Shell Tests
.sp
The new Shell testing system allows us to test the behavior of commands
executed from a high level. This allows for the high level testing of salt
runners and commands like salt\-key.
.SS Client Tests
.sp
Tests have been added to test the aspects of the client APIs and ensure that
the client calls work, and that they manage passed data, in a desirable way.
.SH AUTHOR
Thomas S. Hatch <thatch45@gmail.com> and many others, please see the Authors file
.SH COPYRIGHT
2013, Thomas S. Hatch
.\" Generated by docutils manpage writer.
.\" 
.
