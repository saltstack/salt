# -*- coding: utf-8 -*-
'''
Validate SLS data against the salt state API.

.. versionadded:: 2015.8.4
'''

# Import python libs
from __future__ import absolute_import
import inspect
import logging

# Import salt libs
import salt.state

# Import 3rd-party libs
import salt.ext.six as six
try:
    import voluptuous as V
    HAS_VOLUPTUOUS = True
except ImportError:
    HAS_VOLUPTUOUS = False

log = logging.getLogger(__name__)


def high_schema(high, states):
    '''
    Dynamically construct a schema for the highstate data in ``high`` and
    validate the data against the schema using the voluptuous library.

    :param dict high: Highstate data generated by salt's state compiler from
                      input SLS data.
    :param dict states: Salt's state functions normally available as
                        ``__states__``.
    '''
    if not HAS_VOLUPTUOUS:
        return _error('state.validate requires voluptuous library to be installed')

    dunders = ('__env__', '__sls__')
    schema_struct = {}
    for id_ in high:
        schema_struct[id_] = {}
        for key in high[id_]:
            if key in dunders:
                schema_struct[id_][key] = high[id_][key]
                continue
            mod_name = key
            for item in high[id_][mod_name]:
                if isinstance(item, six.string_types):
                    fun_name = item
                    break
            schema_struct[id_][mod_name] = _arg_schema(states, mod_name, fun_name)
    schema = V.Schema(schema_struct)

    try:
        return schema(high)
    except V.Invalid as exc:
        return _error('SLS failed to validate: {0}'.format(exc))


def _arg_schema(states, mod_name, fun_name):
    '''
    Dynamically construct argument schema for the ``<mod_name>.<fun_name>``
    state function.

    :param dict states: Salt's state functions normally available as
                        ``__states__``.
    :param str mod_name: The name of the state module.
    :param str fun_name: The name of the state function.
    '''
    str_type = basestring if six.PY2 else str
    # ``None`` may be the identity type for all types
    none_schema = V.Any(*[type(None), object, bool,
                          float, str_type, list, dict] + list(six.integer_types))

    arg_spec = inspect.getargspec(states[mod_name + '.' + fun_name])
    arg_names = arg_spec.args
    arg_dflts = () if arg_spec.defaults is None else arg_spec.defaults
    arg_dflts = (len(arg_names) - len(arg_dflts))*[None] + list(arg_dflts)

    arg_names += list(salt.state.STATE_INTERNAL_KEYWORDS)
    arg_dflts += len(salt.state.STATE_INTERNAL_KEYWORDS)*[None]

    arg_types = []
    for ind, name in enumerate(arg_names):
        dflt = arg_dflts[ind]
        if isinstance(dflt, type(None)):
            arg_types.append({name: none_schema})
        elif isinstance(dflt, str_type):
            # always type strings against the base string class
            arg_types.append({name: str_type})
        else:
            arg_types.append({name: type(dflt)})

    return [V.Any(*arg_types + [fun_name, {'order': int}])]

def _error(message):
    '''
    Log and return an error message

    :param str message: The message.
    '''
    log.error(message)
    return message
