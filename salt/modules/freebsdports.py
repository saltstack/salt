# -*- coding: utf-8 -*-
'''
Install software from the FreeBSD ``ports(7)`` system

.. versionadded:: Hydrogen

This module allows you to install ports using ``BATCH=yes`` to bypass
configuration prompts. It is recommended to use the the :mod:`ports state
<salt.states.freebsdports>` to install ports, but it it also possible to use
this module exclusively from the command line.

.. code-block:: bash

    salt minion-id ports.config sysutils/tmux LIBEVENT_STATIC=on
    salt minion-id ports.install sysutils/tmux
'''

# Import python libs
import os
import re

# Import salt libs
import salt.utils
from salt._compat import string_types
from salt.exceptions import SaltInvocationError, CommandExecutionError


def __virtual__():
    return 'ports' if __grains__.get('os', '') == 'FreeBSD' else False


def _check_portname(name):
    '''
    Check if portname is valid and whether or not the directory exists in the
    ports tree.
    '''
    if not isinstance(name, string_types) or '/' not in name:
        raise SaltInvocationError(
            'Invalid port name {0!r} (category required)'.format(name)
        )

    path = os.path.join('/usr/ports', name)
    if not os.path.isdir(path):
        raise SaltInvocationError('Path {0!r} does not exist'.format(path))

    return path


def _write_options(name, pkg, config):
    '''
    Writes a new OPTIONS file
    '''
    _check_portname(name)
    _root = '/var/db/ports'

    # New path: /var/db/ports/category_portname
    dirname = os.path.join(_root, name.replace('/', '_'))
    # Old path: /var/db/ports/portname
    old_dir = os.path.join(_root, name.split('/')[-1])

    if os.path.isdir(old_dir):
        dirname = old_dir

    if not os.path.isdir(dirname):
        try:
            os.makedirs(dirname)
        except OSError as exc:
            raise CommandExecutionError(
                'Unable to make {0}: {1}'.format(dirname, exc)
            )

    with salt.utils.fopen(os.path.join(dirname, 'options'), 'w') as fp_:
        fp_.write(
            '# This file was auto-generated by Salt (http://saltstack.com)\n'
            '# Options for {0}\n'
            '_OPTIONS_READ={0}\n'
            '_FILE_COMPLETE_OPTIONS_LIST={1}\n'
            .format(pkg, ' '.join(sorted(config)))
        )
        opt_tmpl = 'OPTIONS_FILE_{0}SET+={1}\n'
        for opt in sorted(config):
            fp_.write(
                opt_tmpl.format(
                    '' if config[opt] == 'on' else 'UN',
                    opt
                )
            )


def rmconfig(name):
    '''
    Clear the cached options for the specified port; run a ``make rmconfig``

    name
        The name of the port to clear

    CLI Example:

    .. code-block:: bash

        salt '*' ports.rmconfig sysutils/tmux
    '''
    portpath = _check_portname(name)
    return __salt__['cmd.run']('make rmconfig', cwd=portpath)


def showconfig(name, dict_return=False):
    '''
    Show the configuration options for a given port.

    CLI Example:

    .. code-block:: bash

        salt '*' ports.showconfig sysutils/tmux
    '''
    portpath = _check_portname(name)

    try:
        result = __salt__['cmd.run_all']('make showconfig', cwd=portpath)
        output = result['stdout'].splitlines()
        if result['retcode'] != 0:
            error = result['stderr']
        else:
            error = ''
    except TypeError:
        error = result

    if error:
        msg = ('Error running \'make showconfig\' for {0}: {1}'
               .format(name, error))
        log.error(msg)
        raise SaltInvocationError(msg)

    if not dict_return:
        return '\n'.join(output)

    if ((not output) or ('configuration options' not in output[0])):
        return {}

    try:
        pkg = output[0].split()[-1].rstrip(':')
    except (IndexError, AttributeError, TypeError) as exc:
        log.error(
            'Unable to get pkg-version string: {0}'.format(exc)
        )
        return {}

    ret = {pkg: {}}
    output = output[1:]
    for line in output:
        try:
            opt, val, desc = re.match(
                r'\s+([^=]+)=(off|on): (.+)', line
            ).groups()
        except AttributeError:
            continue
        ret[pkg][opt] = val

    if not ret[pkg]:
        return {}
    return ret


def config(name, reset=False, **kwargs):
    '''
    Modify configuration options for a given port. Multiple options can be
    specified. To see the available options for a port, use
    :mod:`ports.showconfig <salt.modules.freebsdports.showconfig>`

    name
        The port name, in ``category/name`` format

    reset : False
        If true, runs a ``make rmconfig`` for the port, clearing its
        configuration before setting the desired options

    CLI Examples:

    .. code-block:: bash

        salt '*' ports.config sysutils/tmux LIBEVENT_STATIC=on
    '''
    portpath = _check_portname(name)

    if reset:
        rmconfig(name)

    config = showconfig(name, dict_return=True)

    if not config:
        raise CommandExecutionError(
            'Unable to get port configuration for {0!r}'.format(name)
        )

    # Unpack return data from showconfig
    pkg = next(iter(config))
    config = config[pkg]

    def _on_off(val):
        '''
        Fix Salt's yaml-ification of on/off, and otherwise normalize the on/off
        values to be used in writing the options file
        '''
        if isinstance(val, bool):
            return 'on' if val else 'off'
        return str(val).lower()

    opts = dict(
        (x, _on_off(kwargs[x])) for x in kwargs if not x.startswith('_')
    )

    bad_opts = [x for x in opts if x not in config]
    if bad_opts:
        raise SaltInvocationError(
            'The following opts are not valid for port {0}: {1}'
            .format(name, ', '.join(bad_opts))
        )

    bad_vals = [
        '{0}={1}'.format(x, y) for x, y in opts.iteritems()
        if y not in ('on', 'off')
    ]
    if bad_vals:
        raise SaltInvocationError(
            'The following key/value pairs are invalid: {0}'
            .format(', '.join(bad_vals))
        )

    for opt, val in opts.iteritems():
        config[opt] = val

    _write_options(name, pkg, config)

    new_config = showconfig(name, dict_return=True)
    try:
        new_config = new_config[next(iter(new_config))]
    except (StopIteration, TypeError):
        return False

    return all(config[x] == new_config.get(x) for x in config)
